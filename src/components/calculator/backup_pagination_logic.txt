// CORRECT PAGINATION APPROACH FOR FULL OPTIONS CHAIN

// After getting stock price, use this code:

// Now try to get ALL options contracts (with pagination to ensure we get everything)
console.log(`üìä Attempting to get ALL options contracts for ${upperSymbol}...`);

let allContracts: any[] = [];
// Get contracts expiring from TODAY onwards
const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
let nextUrl: string | null = `https://api.polygon.io/v3/reference/options/contracts?underlying_ticker=${upperSymbol}&active=true&expiration_date.gte=${today}&limit=1000&apikey=${POLYGON_API_KEY}`;
let pageCount = 0;

console.log(`üîç Fetching contracts expiring from ${today} onwards`);

// Paginate through ALL available contracts
while (nextUrl && pageCount < 50) { // Safety limit
  pageCount++;
  console.log(`üîó FETCHING PAGE ${pageCount}: ${nextUrl}`);
  
  const contractsResponse: Response = await fetch(nextUrl);
  console.log(`üì° PAGE ${pageCount} STATUS: ${contractsResponse.status} ${contractsResponse.statusText}`);
  
  if (!contractsResponse.ok) {
    const errorText = await contractsResponse.text();
    console.warn(`‚ö†Ô∏è Contracts API failed on page ${pageCount} for ${upperSymbol}:`, errorText);
    break;
  }
  
  const contractsData: any = await contractsResponse.json();
  console.log(`üìä PAGE ${pageCount} - Status: ${contractsData.status}, Results: ${contractsData.results?.length || 0}`);
  
  if (contractsData.status !== 'OK' || !contractsData.results) {
    console.warn(`‚ö†Ô∏è Invalid response on page ${pageCount}:`, contractsData);
    break;
  }
  
  // Add contracts from this page
  allContracts.push(...contractsData.results);
  console.log(`üìà Total contracts so far: ${allContracts.length}`);
  
  // Check for next page
  nextUrl = contractsData.next_url || null;
  if (nextUrl && !nextUrl.includes('apikey=')) {
    nextUrl += `&apikey=${POLYGON_API_KEY}`;
  }
  
  // Break if no more pages
  if (!nextUrl) {
    console.log(`‚úÖ Pagination complete - fetched all ${allContracts.length} contracts`);
    break;
  }
}

if (allContracts.length === 0) {
  console.warn(`‚ö†Ô∏è No contracts found for ${upperSymbol}`);
  setRealOptionsData({});
  setAvailableExpirations([]);
  setLoading(false);
  return;
}

console.log(`üéØ FINAL RESULT: ${allContracts.length} total contracts for ${upperSymbol}`);

// Process ALL collected contracts
console.log(`üîç Processing ${allContracts.length} contracts...`);
const processedOptions: RealOptionsData = {};
const uniqueExpirations = new Set<string>();

allContracts.forEach((contract: any, index: number) => {
  // Debug first few contracts to see structure
  if (index < 3) {
    console.log(`üîç Contract ${index} structure:`, {
      ticker: contract.ticker,
      strike: contract.strike_price,
      expiration: contract.expiration_date,
      type: contract.contract_type,
      allKeys: Object.keys(contract)
    });
  }
  
  // For options contracts API, the data structure is different
  let expDate = contract.expiration_date;
  let strike = contract.strike_price;
  let optionType = contract.contract_type?.toLowerCase();
  
  if (expDate && strike && optionType) {
    // Calculate days to expiration
    const expiry = new Date(expDate);
    const now = new Date();
    const daysToExp = Math.ceil((expiry.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
    
    // Only filter out expired options
    if (daysToExp <= 0) {
      console.log(`‚ùå SKIPPING EXPIRED option: ${expDate} (${daysToExp} days ago)`);
      return; // Skip this expired contract
    }
    
    uniqueExpirations.add(expDate);
    console.log(`‚úÖ KEEPING valid option: ${expDate} (${daysToExp} days, ${(daysToExp/365).toFixed(1)} years)`);
    
    const key = `${strike}-${expDate}-${optionType}`;
    const contractTicker = contract.ticker;
    
    processedOptions[key] = {
      strike: strike,
      expiration: expDate,
      daysToExpiration: daysToExp,
      type: optionType as 'call' | 'put',
      bid: 0, // Will be filled later with real pricing API
      ask: 0, // Will be filled later with real pricing API
      lastPrice: 0, // Will be filled later with real pricing API
      volume: 0, // Will be filled later with real pricing API
      openInterest: 0, // Will be filled later with real pricing API
      impliedVolatility: null, // Will be filled with real pricing data only
      ticker: contractTicker
    };
  }
});