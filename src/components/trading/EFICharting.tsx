'use client';

import React, { useRef, useEffect, useState, useCallback, useMemo, useLayoutEffect } from 'react';
import { createPortal } from 'react-dom';
import { flushSync } from 'react-dom';
import {
  TbChartLine,
  TbNews,
  TbBellRinging,
  TbBellOff,
  TbTrendingUp,
  TbTrendingDown,
  TbX,
  TbSend,
  TbPhoto,
  TbUser,
  TbLock,
  TbCalculator,
  TbLink,
  TbPhoneCall,
  TbPencil,
  TbArrowsHorizontal,
  TbBoxMultiple,
  TbBrush,
  TbCurrencyDollar,
  TbChartCandle,
  TbChartInfographic,
  TbMail,
  TbBell,
  TbCheck,
  TbActivity,
  TbChartBar,
  TbCalendar,
  TbArrowsShuffle,
  TbFilter,
  TbChartDots,
  TbArrowUp,
  TbArrowDown,
  TbArrowsSort,
  TbLine,
  TbMinus,
  TbSquare,
  TbTextSize,
  TbArrowsVertical,
  TbArrowUpRight,
  TbSlash,
  TbStar,
  TbStarFilled
} from 'react-icons/tb';
import { IndustryAnalysisService, MarketRegimeData, IndustryPerformance, TimeframeAnalysis } from '../../lib/industryAnalysisService';
import PolygonService from '../../lib/polygonService';
import ElectionCycleService from '../../lib/electionCycleService';
import ETFHoldingsModal from '../ETFHoldingsModal';
import { useMarketRegime } from '../../contexts/MarketRegimeContext';
import { OptionsFlowTable } from '../OptionsFlowTable';
import EnhancedRegimeDisplay from '../terminal/EnhancedRegimeDisplay';

// Enhanced Market Regime Types
interface SectorAnalysis {
  sector: string;
  change: number;
  relativeToSPY: number;
}

interface RegimeAnalysis {
  defensiveAvg: number;
  growthAvg: number;
  valueAvg: number;
  defensiveGrowthSpread: number;
  spreadStrength: 'STRONG' | 'MODERATE' | 'WEAK';
  regime: 'STRONG DEFENSIVE' | 'MODERATE DEFENSIVE' | 'DEFENSIVE + VALUE' | 'RISK ON' | 'STRONG RISK ON' | 'GROWTH + RISK ON' | 'VALUE' | 'MIXED' | 'RISK OFF';
  confidence: number;
  defensiveSectors: SectorAnalysis[];
  growthSectors: SectorAnalysis[];
  valueSectors: SectorAnalysis[];
}

// Global type declarations
declare global {
  interface Window {
    MARKET_REGIMES_DEBUG?: any;
  }
}
import ChartDataCache from '../../lib/chartDataCache';
import NewsPanel from '../news/NewsPanel';
import TradingPlan from './TradingPlan';
import OptionsChain from './OptionsChain';
import DealerAttraction from '../analytics/DealerAttraction';
import { gexService } from '../../lib/gexService';
import MultiChartView from './MultiChartView';
import { useGEXData } from '../../hooks/useGEXData';
import { GEXChartOverlay } from '../GEXChartOverlay';
import { getExpirationDates, getExpirationDatesFromAPI, getDaysUntilExpiration } from '../../lib/optionsExpirationUtils';
import { createApiUrl } from '../../lib/apiConfig';
import GuideChatbot from '../chatbot/GuideChatbot';
import { useChatStore } from '../../store/chatStore';
import HVScreener from '../HVScreener';
import RSScreener from '../RSScreener';
import LeadershipScan from '../LeadershipScan';
import RRGScreener from '../RRGScreener';
import RRGAnalytics from '../analytics/RRGAnalytics';
import IVRRGAnalytics from '../analytics/IVRRGAnalytics';
import SeasonalityChart from '../analytics/SeasonalityChart';
import HorizontalMonthlyReturns from '../analytics/HorizontalMonthlyReturns';
import SeasonaxLanding from '../seasonax/SeasonaxLanding';
import LWChartDrawingTools from './LWChartDrawingTools';

// Wrapper component to auto-trigger screener with external controls
const SeasonalScreenerWrapper: React.FC<{
  market: string;
  timePeriod: string;
  filters: { highWinRate: boolean; startingSoon: boolean; fiftyTwoWeek: boolean };
  trigger: boolean;
}> = ({ market, timePeriod, filters, trigger }) => {
  return (
    <div className="seasonality-screener-wrapper">
      <style>{`
        .seasonality-screener-wrapper .pro-hero {
          display: none !important;
        }
        
        /* Date/Period text - white, 100% bigger (2x size) */
        .seasonality-screener-wrapper .opp-symbol + div {
          color: #ffffff !important;
          opacity: 1 !important;
          font-size: 22px !important;
        }
        
        /* Target the period div directly by finding divs with the text pattern */
        .seasonality-screener-wrapper [style*="color: rgb(153, 153, 153)"],
        .seasonality-screener-wrapper [style*="color:#999999"] {
          color: #ffffff !important;
          opacity: 1 !important;
          font-size: 22px !important;
        }
        
        /* Expected return and Win Rate values - crispy white, 50% bigger (1.5x size) */
        .seasonality-screener-wrapper .opp-expected-positive,
        .seasonality-screener-wrapper .opp-expected-negative,
        .seasonality-screener-wrapper .opp-winrate {
          color: #ffffff !important;
          opacity: 1 !important;
          font-size: 21px !important;
        }
      `}</style>
      <SeasonaxLanding
        autoStart={trigger}
        initialMarket={market}
        initialTimePeriod={timePeriod}
        externalFilters={filters}
        sidebarMode={true}
      />
    </div>
  );
};

// Add custom styles for 3D carved effect and holographic animations
const carvedTextStyles = `
 .text-shadow-carved {
 text-shadow: 
 1px 1px 0px rgba(0, 0, 0, 0.9),
 -1px -1px 0px rgba(255, 255, 255, 0.1),
 0px -1px 0px rgba(255, 255, 255, 0.05),
 0px 1px 0px rgba(0, 0, 0, 0.8);
 }
 
 .glow-yellow {
 text-shadow: 0 0 5px rgba(255, 255, 0, 0.5), 0 0 10px rgba(255, 255, 0, 0.3);
 }
 
 .glow-green {
 text-shadow: 0 0 5px rgba(0, 255, 0, 0.5), 0 0 10px rgba(0, 255, 0, 0.3);
 }
 
 .glow-red {
 text-shadow: 0 0 5px rgba(255, 0, 0, 0.5), 0 0 10px rgba(255, 0, 0, 0.3);
 }
 
 /* Holographic Channel Animations */
 @keyframes shimmer {
 0% { transform: translateX(-100%) skewX(-12deg); }
 100% { transform: translateX(200%) skewX(-12deg); }
 }
 
 @keyframes spin-slow {
 0% { transform: rotate(0deg); }
 100% { transform: rotate(360deg); }
 }
 
 @keyframes fadeInSlide {
 0% { 
 opacity: 0;
 transform: translateX(-10px);
 }
 100% { 
 opacity: 1;
 transform: translateX(0);
 }
 }
 
 .animate-shimmer {
 animation: shimmer 2s infinite;
 }
 
 .animate-spin-slow {
 animation: spin-slow 8s linear infinite;
 }
`;

// TradingView-style Chart Data Interface
interface ChartDataPoint {
  timestamp: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  date: string;
  time: string;
}

// ==================================================================================
// ALERTS SYSTEM INTERFACES
// ==================================================================================

interface PriceAlert {
  id: string;
  symbol: string;
  price: number;
  condition: 'above' | 'below' | 'crossesAbove' | 'crossesBelow' |
  'closeAbove5m' | 'closeAbove15m' | 'closeAbove30m' | 'closeAbove1h' | 'closeAbove4h' | 'closeAbove1d' |
  'closeBelow5m' | 'closeBelow15m' | 'closeBelow30m' | 'closeBelow1h' | 'closeBelow4h' | 'closeBelow1d' |
  'staysInRange' | 'breaksOutOfRange';
  message: string;
  triggered: boolean;
  createdAt: Date;
  once: boolean;
  soundEnabled: boolean;
  emailEnabled: boolean;
  type: 'price' | 'options' | 'technical';
  optionsData?: {
    strike: number;
    expiration: string;
    optionType: 'call' | 'put';
    metric: 'iv' | 'volume' | 'oi' | 'delta';
    value: number;
  };
  technicalData?: {
    indicator: string;
    value: number;
  };
  rangeData?: {
    upper: number;
    lower: number;
    duration: number;
  };
}

// TECHNALYSIS PRICE ACTION SYSTEM INTERFACES
// ==================================================================================

interface OrderBlock {
  type: 'bullish' | 'bearish';
  price: number;
  high: number;
  low: number;
  index: number;
  strength: number;
  isValid: boolean;
  isMitigated: boolean;
  volumeConfirmation: boolean;
}

interface FairValueGap {
  type: 'bullish' | 'bearish';
  topPrice: number;
  bottomPrice: number;
  startIndex: number;
  endIndex: number;
  gapSize: number;
  isValid: boolean;
  isFilled: boolean;
}

interface LiquidityZone {
  type: 'buy_side' | 'sell_side';
  price: number;
  strength: number;
  index: number;
  isSwept: boolean;
  expectedReaction: 'reversal' | 'continuation';
}

interface MarketStructure {
  type: 'higher_high' | 'higher_low' | 'lower_high' | 'lower_low';
  price: number;
  index: number;
  trendDirection: 'bullish' | 'bearish' | 'ranging';
}

interface BreakOfStructure {
  type: 'bos' | 'choch';
  direction: 'bullish' | 'bearish';
  price: number;
  index: number;
  previousStructure: MarketStructure;
}

interface OptimalTradeEntry {
  type: 'premium' | 'discount' | 'equilibrium';
  priceLevel: number;
  confidence: number;
  setupType: string;
  index: number;
}

// Drawing types for proper TypeScript support
interface DrawingPoint {
  x: number;
  y: number;
  // TradingView-style time+price coordinates for absolute positioning
  timestamp?: number; // Actual timestamp for precise anchoring
  price?: number; // Actual price for precise anchoring
}

// Data coordinates for persistent drawings
interface DataPoint {
  candleIndex: number;
  price: number;
}

interface DrawingMetadata {
  [key: string]: unknown;
}

// Specific metadata interfaces for different drawing types
interface MeasureDrawingMetadata extends DrawingMetadata {
  distance: number;
  angle: number;
  priceDistance: number;
}

// Horizontal Ray interface for drawing horizontal lines
interface HorizontalRay {
  id: string;
  price: number;
  color: string;
  lineWidth: number;
  lineStyle: 'solid' | 'dashed' | 'dotted';
  extendLeft: boolean;
  extendRight: boolean;
  label: string;
  startX?: number; // For backward compatibility
  isSelected?: boolean; // For selection state
}

// Parallel Channels interface for drawing parallel channel lines (3-point system)
interface ParallelChannel {
  id: string;
  point1: { timestamp: number; price: number }; // Start of main trend line
  point2: { timestamp: number; price: number }; // End of main trend line 
  point3: { timestamp: number; price: number }; // Point to define channel width
  color: string;
  lineWidth: number;
  lineStyle: 'solid' | 'dashed' | 'dotted';
  fillOpacity: number;
  fillColor?: string; // Fill color for the channel area
  showFill?: boolean; // Whether to show the fill
  label: string;
  isSelected?: boolean;
}

// Drawing Brush interface for freehand drawing
interface DrawingBrush {
  id: string;
  strokes: Array<{ timestamp: number; price: number }>;
  color: string;
  lineWidth: number;
  opacity: number;
  label: string;
  isSelected?: boolean;
}

interface PolygonDataItem {
  c: number;
  h: number;
  l: number;
  o: number;
  t: number;
  v: number;
  vw: number;
  n: number;
}

// TradingView-style Chart Configuration
interface ChartConfig {
  symbol: string;
  timeframe: string;
  chartType: 'candlestick' | 'line';
  theme: 'dark' | 'light';
  drawings: Drawing[];
  crosshair: boolean;
  timezone: string;
  showGrid: boolean;
  axisStyle: {
    xAxis: {
      textSize: number;
      textColor: string;
    };
    yAxis: {
      textSize: number;
      textColor: string;
    };
  };
  colors: {
    bullish: {
      body: string;
      wick: string;
      border: string;
    };
    bearish: {
      body: string;
      wick: string;
      border: string;
    };
    volume: {
      bullish: string;
      bearish: string;
    };
  };
}

// Drawing Style Interface
interface DrawingStyle {
  color?: string;
  lineWidth?: number;
  lineDash?: number[];
  fillOpacity?: number;
  textSize?: number;
  showLabels?: boolean;
  showLevels?: boolean;
}

// Enhanced TradingView-style Drawing interface with all professional features
interface Drawing {
  id: string | number;
  type: string;
  name?: string;

  // Time/Price Coordinates (TradingView standard)
  startTimestamp?: number;
  startPrice?: number;
  endTimestamp?: number;
  endPrice?: number;
  timestamp?: number; // For single-point drawings
  price?: number; // For single-point drawings

  // Multi-point drawings (patterns, etc.)
  points?: DrawingPoint[];

  // Text and annotations
  text?: string;
  richText?: {
    content: string;
    fontSize: number;
    fontFamily: string;
    fontWeight: 'normal' | 'bold';
    fontStyle: 'normal' | 'italic';
    textAlign: 'left' | 'center' | 'right';
    verticalAlign: 'top' | 'middle' | 'bottom';
    backgroundColor?: string;
    borderColor?: string;
    borderWidth?: number;
    borderRadius?: number;
    padding?: number;
  };

  // Enhanced styling with full TradingView feature set
  style?: {
    color: string;
    lineWidth: number;
    lineStyle: 'solid' | 'dashed' | 'dotted';
    fillColor?: string;
    fillOpacity?: number;
    transparency?: number;

    // Line specific
    extendLeft?: boolean;
    extendRight?: boolean;
    showPriceLabels?: boolean;
    showTimeLabels?: boolean;

    // Text specific
    textColor?: string;
    fontSize?: number;
    fontFamily?: string;
    bold?: boolean;
    italic?: boolean;

    // Shape specific
    borderColor?: string;
    borderWidth?: number;
    cornerRadius?: number;

    // Legacy compatibility
    lineDash?: number[];
    textSize?: number;
    showLabels?: boolean;
    showLevels?: boolean;

    // Advanced
    zIndex?: number;
    locked?: boolean;
    visible?: boolean;
    selected?: boolean;
  };

  // Drawing state and metadata
  metadata?: DrawingMetadata & {
    createdAt?: number;
    updatedAt?: number;
    version?: number;
    creator?: string;
    description?: string;
    tags?: string[];
  };

  // Interaction state
  isSelected?: boolean;
  isHovered?: boolean;
  isEditing?: boolean;
  isLocked?: boolean;
  isDragging?: boolean;

  // Drawing-specific properties
  channelWidth?: number;
  arrowHead?: 'none' | 'start' | 'end' | 'both';
  patternType?: string;

  // Legacy compatibility
  startPoint?: DrawingPoint;
  endPoint?: DrawingPoint;
  startX?: number;
  startY?: number;
  endX?: number;
  endY?: number;
  time?: number;
  price1?: number;
  time1?: number;
  price2?: number;
  time2?: number;
  startDataPoint?: DataPoint;
  endDataPoint?: DataPoint;
  dataPoints?: DataPoint[];
  absoluteScreenY?: number;
  clickX?: number;
  clickY?: number;
}

// TradingView Professional Timeframes with extensive historical data
const TRADINGVIEW_TIMEFRAMES = [
  { label: '1m', value: '1m', lookback: 7 }, // 7 days for 1-minute data
  { label: '5m', value: '5m', lookback: 30 }, // 30 days for 5-minute data
  { label: '15m', value: '15m', lookback: 90 }, // 90 days for 15-minute data 
  { label: '30m', value: '30m', lookback: 180 }, // 180 days for 30-minute data
  { label: '1H', value: '1h', lookback: 365 }, // 1 year for hourly data
  { label: '4H', value: '4h', lookback: 1095 }, // 3 years for 4-hour data
  { label: '1D', value: '1d', lookback: 5475 }, // 15 years for daily data (like TradingView Pro)
  { label: '1W', value: '1w', lookback: 7300 }, // 20 years for weekly data
  { label: '1M', value: '1mo', lookback: 10950 }, // 30 years for monthly data
  { label: '1Y', value: '1y', lookback: 14600 } // 40 years for yearly data
];

// Chart Types
const MAIN_CHART_TYPES = [
  {
    label: 'Candles',
    value: 'candlestick',
    icon: (
      <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
        {/* Candlestick 1 */}
        <line x1="3" y1="2" x2="3" y2="14" stroke="currentColor" strokeWidth="1" />
        <rect x="2" y="4" width="2" height="4" fill="currentColor" />

        {/* Candlestick 2 */}
        <line x1="7" y1="1" x2="7" y2="13" stroke="currentColor" strokeWidth="1" />
        <rect x="6" y="3" width="2" height="6" fill="none" stroke="currentColor" strokeWidth="1" />

        {/* Candlestick 3 */}
        <line x1="11" y1="3" x2="11" y2="15" stroke="currentColor" strokeWidth="1" />
        <rect x="10" y="5" width="2" height="3" fill="currentColor" />
      </svg>
    )
  },
  {
    label: 'Line',
    value: 'line',
    icon: (
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
        <path
          d="M1 13 L4 9 L7 11 L10 6 L13 8 L15 4"
          stroke="currentColor"
          strokeWidth="2"
          fill="none"
          strokeLinecap="round"
          strokeLinejoin="round"
        />
        {/* Add small dots at connection points */}
        <circle cx="1" cy="13" r="1.5" fill="currentColor" />
        <circle cx="4" cy="9" r="1.5" fill="currentColor" />
        <circle cx="7" cy="11" r="1.5" fill="currentColor" />
        <circle cx="10" cy="6" r="1.5" fill="currentColor" />
        <circle cx="13" cy="8" r="1.5" fill="currentColor" />
        <circle cx="15" cy="4" r="1.5" fill="currentColor" />
      </svg>
    )
  }
];

const DROPDOWN_CHART_TYPES: { label: string; value: string; icon: string }[] = [
  // Only Candlestick and Line chart types are now supported
];

const CHART_TYPES = [...MAIN_CHART_TYPES, ...DROPDOWN_CHART_TYPES];

// ? TradingView-Style Drawing Properties Panel Component
interface DrawingPropertiesPanelProps {
  selectedDrawing: Drawing | null;
  isOpen: boolean;
  onClose: () => void;
  onUpdate: (updatedDrawing: Partial<Drawing>) => void;
  position: { x: number; y: number };
}

const DrawingPropertiesPanel: React.FC<DrawingPropertiesPanelProps> = ({
  selectedDrawing,
  isOpen,
  onClose,
  onUpdate,
  position
}) => {
  const [activeTab, setActiveTab] = useState<'style' | 'text' | 'coordinates'>('style');

  if (!isOpen || !selectedDrawing) return null;

  const updateStyle = (styleUpdates: Partial<Drawing['style']>) => {
    const currentStyle = selectedDrawing.style || {
      color: '#FFFF00',
      lineWidth: 2,
      lineStyle: 'solid' as const
    };
    onUpdate({
      style: {
        ...currentStyle,
        color: currentStyle.color || '#FFFF00',
        lineWidth: currentStyle.lineWidth || 2,
        lineStyle: currentStyle.lineStyle || 'solid',
        ...styleUpdates
      } as Drawing['style']
    });
  };

  const updateText = (textUpdates: Partial<Drawing['richText']>) => {
    onUpdate({
      richText: {
        ...selectedDrawing.richText,
        ...textUpdates
      } as Drawing['richText']
    });
  };

  return (
    <div
      className="fixed z-[9999] bg-[#131722] border border-[#2a2e39] rounded-lg shadow-2xl min-w-[300px] max-w-[400px]"
      style={{
        left: Math.min(position.x, window.innerWidth - 320),
        top: Math.min(position.y, window.innerHeight - 400),
        maxHeight: '400px'
      }}
    >
      {/* Header */}
      <div className="flex items-center justify-between p-3 border-b border-[#2a2e39]">
        <h3 className="text-white text-sm font-medium">Drawing Properties</h3>
        <button
          onClick={onClose}
          className="text-[#868993] hover:text-white text-lg leading-none"
        >

        </button>
      </div>

      {/* Tabs */}
      <div className="flex border-b border-[#2a2e39]">
        {[
          { id: 'style', label: 'Style', icon: '??' },
          { id: 'text', label: 'Text', icon: 'T' },
          { id: 'coordinates', label: 'Position', icon: '??' }
        ].map(tab => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id as any)}
            className={`flex-1 px-3 py-2 text-xs font-medium transition-colors ${activeTab === tab.id
              ? 'text-[#2962ff] border-b-2 border-[#2962ff] bg-[#1e222d]'
              : 'text-[#868993] hover:text-white'
              }`}
          >
            <span className="mr-1">{tab.icon}</span>
            {tab.label}
          </button>
        ))}
      </div>

      {/* Content */}
      <div className="p-3 max-h-[300px] overflow-y-auto">
        {activeTab === 'style' && (
          <div className="space-y-4">
            {/* Color Picker */}
            <div>
              <label className="block text-xs text-[#868993] mb-2">Line Color</label>
              <div className="flex items-center space-x-2">
                <input
                  type="color"
                  value={selectedDrawing.style?.color || '#00ff88'}
                  onChange={(e) => updateStyle({ color: e.target.value })}
                  style={{ background: '#000000', border: '1px solid rgba(255, 255, 255, 0.15)', borderRadius: '4px' }}
                  className="w-8 h-8 rounded cursor-pointer"
                />
                <input
                  type="text"
                  value={selectedDrawing.style?.color || '#00ff88'}
                  onChange={(e) => updateStyle({ color: e.target.value })}
                  style={{ background: '#000000', border: '1px solid rgba(255, 255, 255, 0.15)', borderRadius: '4px', outline: 'none' }}
                  className="flex-1 px-2 py-1 text-xs rounded text-white"
                  placeholder="#00ff88"
                />
              </div>
            </div>

            {/* Line Width */}
            <div>
              <label className="block text-xs text-[#868993] mb-2">Line Width</label>
              <div className="flex items-center space-x-2">
                <input
                  type="range"
                  min="1"
                  max="10"
                  value={selectedDrawing.style?.lineWidth || 2}
                  onChange={(e) => updateStyle({ lineWidth: parseInt(e.target.value) })}
                  className="flex-1"
                />
                <span className="text-xs text-white w-6 text-center">
                  {selectedDrawing.style?.lineWidth || 2}
                </span>
              </div>
            </div>

            {/* Line Style */}
            <div>
              <label className="block text-xs text-[#868993] mb-2">Line Style</label>
              <select
                value={selectedDrawing.style?.lineStyle || 'solid'}
                onChange={(e) => updateStyle({ lineStyle: e.target.value as any })}
                className="w-full px-2 py-1 text-xs rounded text-white"
                style={{
                  background: '#000000',
                  border: '1px solid rgba(255, 255, 255, 0.15)',
                  borderRadius: '4px',
                  boxShadow: 'inset 0 1px 0 rgba(255, 255, 255, 0.05)',
                  outline: 'none'
                }}
              >
                <option value="solid">Solid</option>
                <option value="dashed">Dashed</option>
                <option value="dotted">Dotted</option>
              </select>
            </div>

            {/* Fill Options */}
            {['rectangle', 'circle', 'ellipse'].includes(selectedDrawing.type) && (
              <>
                <div>
                  <label className="block text-xs text-[#868993] mb-2">Fill Color</label>
                  <div className="flex items-center space-x-2">
                    <input
                      type="color"
                      value={selectedDrawing.style?.fillColor || '#00ff8844'}
                      onChange={(e) => updateStyle({ fillColor: e.target.value })}
                      style={{ background: '#000000', border: '1px solid rgba(255, 255, 255, 0.15)', borderRadius: '4px' }}
                      className="w-8 h-8 rounded cursor-pointer"
                    />
                    <input
                      type="text"
                      value={selectedDrawing.style?.fillColor || '#00ff8844'}
                      onChange={(e) => updateStyle({ fillColor: e.target.value })}
                      style={{ background: '#000000', border: '1px solid rgba(255, 255, 255, 0.15)', borderRadius: '4px', outline: 'none' }}
                      className="flex-1 px-2 py-1 text-xs rounded text-white"
                      placeholder="#00ff8844"
                    />
                  </div>
                </div>

                <div>
                  <label className="block text-xs text-[#868993] mb-2">Fill Opacity</label>
                  <div className="flex items-center space-x-2">
                    <input
                      type="range"
                      min="0"
                      max="1"
                      step="0.1"
                      value={selectedDrawing.style?.fillOpacity || 0.1}
                      onChange={(e) => updateStyle({ fillOpacity: parseFloat(e.target.value) })}
                      className="flex-1"
                    />
                    <span className="text-xs text-white w-8 text-center">
                      {Math.round((selectedDrawing.style?.fillOpacity || 0.1) * 100)}%
                    </span>
                  </div>
                </div>
              </>
            )}

            {/* Extensions for lines */}
            {['trend_line', 'horizontal_line'].includes(selectedDrawing.type) && (
              <div className="space-y-2">
                <label className="flex items-center space-x-2">
                  <input
                    type="checkbox"
                    checked={selectedDrawing.style?.extendLeft || false}
                    onChange={(e) => updateStyle({ extendLeft: e.target.checked })}
                    className="rounded"
                  />
                  <span className="text-xs text-white">Extend Left</span>
                </label>
                <label className="flex items-center space-x-2">
                  <input
                    type="checkbox"
                    checked={selectedDrawing.style?.extendRight || false}
                    onChange={(e) => updateStyle({ extendRight: e.target.checked })}
                    className="rounded"
                  />
                  <span className="text-xs text-white">Extend Right</span>
                </label>
                <label className="flex items-center space-x-2">
                  <input
                    type="checkbox"
                    checked={selectedDrawing.style?.showPriceLabels || false}
                    onChange={(e) => updateStyle({ showPriceLabels: e.target.checked })}
                    className="rounded"
                  />
                  <span className="text-xs text-white">Show Price Labels</span>
                </label>
              </div>
            )}
          </div>
        )}

        {activeTab === 'text' && (
          <div className="space-y-4">
            {/* Text Content */}
            <div>
              <label className="block text-xs text-[#868993] mb-2">Text</label>
              <textarea
                value={selectedDrawing.text || selectedDrawing.richText?.content || ''}
                onChange={(e) => {
                  onUpdate({ text: e.target.value });
                  updateText({ content: e.target.value });
                }}
                className="w-full px-2 py-1 text-xs bg-[#1e222d] border border-[#2a2e39] rounded text-white resize-none"
                rows={3}
                placeholder="Enter text..."
              />
            </div>

            {/* Font Size */}
            <div>
              <label className="block text-xs text-[#868993] mb-2">Font Size</label>
              <div className="flex items-center space-x-2">
                <input
                  type="range"
                  min="8"
                  max="32"
                  value={selectedDrawing.richText?.fontSize || selectedDrawing.style?.fontSize || 12}
                  onChange={(e) => {
                    const size = parseInt(e.target.value);
                    updateText({ fontSize: size });
                    updateStyle({ fontSize: size });
                  }}
                  className="flex-1"
                />
                <span className="text-xs text-white w-6 text-center">
                  {selectedDrawing.richText?.fontSize || selectedDrawing.style?.fontSize || 12}
                </span>
              </div>
            </div>

            {/* Font Family */}
            <div>
              <label className="block text-xs text-[#868993] mb-2">Font</label>
              <select
                value={selectedDrawing.richText?.fontFamily || selectedDrawing.style?.fontFamily || 'Arial'}
                onChange={(e) => {
                  updateText({ fontFamily: e.target.value });
                  updateStyle({ fontFamily: e.target.value });
                }}
                className="w-full px-2 py-1 text-xs rounded text-white"
                style={{
                  background: '#000000',
                  border: '1px solid rgba(255, 255, 255, 0.15)',
                  borderRadius: '4px',
                  boxShadow: 'inset 0 1px 0 rgba(255, 255, 255, 0.05)',
                  outline: 'none'
                }}
              >
                <option value="Arial">Arial</option>
                <option value="Helvetica">Helvetica</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Courier New">Courier New</option>
                <option value="Georgia">Georgia</option>
              </select>
            </div>

            {/* Font Style */}
            <div className="flex space-x-2">
              <label className="flex items-center space-x-1">
                <input
                  type="checkbox"
                  checked={selectedDrawing.richText?.fontWeight === 'bold' || selectedDrawing.style?.bold || false}
                  onChange={(e) => {
                    updateText({ fontWeight: e.target.checked ? 'bold' : 'normal' });
                    updateStyle({ bold: e.target.checked });
                  }}
                  className="rounded"
                />
                <span className="text-xs text-white font-bold">B</span>
              </label>
              <label className="flex items-center space-x-1">
                <input
                  type="checkbox"
                  checked={selectedDrawing.richText?.fontStyle === 'italic' || selectedDrawing.style?.italic || false}
                  onChange={(e) => {
                    updateText({ fontStyle: e.target.checked ? 'italic' : 'normal' });
                    updateStyle({ italic: e.target.checked });
                  }}
                  className="rounded"
                />
                <span className="text-xs text-white italic">I</span>
              </label>
            </div>

            {/* Text Color */}
            <div>
              <label className="block text-xs text-[#868993] mb-2">Text Color</label>
              <div className="flex items-center space-x-2">
                <input
                  type="color"
                  value={selectedDrawing.richText?.backgroundColor || selectedDrawing.style?.textColor || '#ffffff'}
                  onChange={(e) => {
                    updateText({ backgroundColor: e.target.value });
                    updateStyle({ textColor: e.target.value });
                  }}
                  className="w-8 h-8 rounded border border-[#2a2e39] bg-transparent cursor-pointer"
                />
                <input
                  type="text"
                  value={selectedDrawing.richText?.backgroundColor || selectedDrawing.style?.textColor || '#ffffff'}
                  onChange={(e) => {
                    updateText({ backgroundColor: e.target.value });
                    updateStyle({ textColor: e.target.value });
                  }}
                  className="flex-1 px-2 py-1 text-xs bg-[#1e222d] border border-[#2a2e39] rounded text-white"
                  placeholder="#ffffff"
                />
              </div>
            </div>

            {/* Text Alignment */}
            <div>
              <label className="block text-xs text-[#868993] mb-2">Text Alignment</label>
              <div className="flex space-x-1">
                {[
                  { value: 'left', icon: '??' },
                  { value: 'center', icon: '??' },
                  { value: 'right', icon: '??' }
                ].map(align => (
                  <button
                    key={align.value}
                    onClick={() => updateText({ textAlign: align.value as any })}
                    className={`flex-1 px-2 py-1 text-xs rounded transition-colors ${(selectedDrawing.richText?.textAlign || 'left') === align.value
                      ? 'bg-[#2962ff] text-white'
                      : 'bg-[#1e222d] text-[#868993] hover:text-white'
                      }`}
                  >
                    {align.icon}
                  </button>
                ))}
              </div>
            </div>
          </div>
        )}

        {activeTab === 'coordinates' && (
          <div className="space-y-4">
            {/* Time/Price Coordinates */}
            <div className="grid grid-cols-2 gap-2">
              <div>
                <label className="block text-xs text-[#868993] mb-1">Start Time</label>
                <input
                  type="datetime-local"
                  value={selectedDrawing.startTimestamp ? new Date(selectedDrawing.startTimestamp).toISOString().slice(0, 16) : ''}
                  onChange={(e) => onUpdate({ startTimestamp: new Date(e.target.value).getTime() })}
                  className="w-full px-2 py-1 text-xs bg-[#1e222d] border border-[#2a2e39] rounded text-white"
                />
              </div>
              <div>
                <label className="block text-xs text-[#868993] mb-1">Start Price</label>
                <input
                  type="number"
                  step="0.01"
                  value={selectedDrawing.startPrice || ''}
                  onChange={(e) => onUpdate({ startPrice: parseFloat(e.target.value) })}
                  className="w-full px-2 py-1 text-xs bg-[#1e222d] border border-[#2a2e39] rounded text-white"
                />
              </div>
              {selectedDrawing.endTimestamp !== undefined && (
                <>
                  <div>
                    <label className="block text-xs text-[#868993] mb-1">End Time</label>
                    <input
                      type="datetime-local"
                      value={selectedDrawing.endTimestamp ? new Date(selectedDrawing.endTimestamp).toISOString().slice(0, 16) : ''}
                      onChange={(e) => onUpdate({ endTimestamp: new Date(e.target.value).getTime() })}
                      className="w-full px-2 py-1 text-xs bg-[#1e222d] border border-[#2a2e39] rounded text-white"
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-[#868993] mb-1">End Price</label>
                    <input
                      type="number"
                      step="0.01"
                      value={selectedDrawing.endPrice || ''}
                      onChange={(e) => onUpdate({ endPrice: parseFloat(e.target.value) })}
                      className="w-full px-2 py-1 text-xs bg-[#1e222d] border border-[#2a2e39] rounded text-white"
                    />
                  </div>
                </>
              )}
            </div>

            {/* Lock/Unlock Drawing */}
            <div>
              <label className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={selectedDrawing.isLocked || false}
                  onChange={(e) => onUpdate({ isLocked: e.target.checked })}
                  className="rounded"
                />
                <span className="text-xs text-white">?? Lock Drawing</span>
              </label>
              <p className="text-xs text-[#868993] mt-1">
                Locked drawings cannot be moved or edited
              </p>
            </div>

            {/* Layer Management */}
            <div>
              <label className="block text-xs text-[#868993] mb-2">Layer Order</label>
              <div className="flex space-x-1">
                <button
                  onClick={() => updateStyle({ zIndex: (selectedDrawing.style?.zIndex || 0) + 1 })}
                  className="flex-1 px-2 py-1 text-xs bg-[#1e222d] border border-[#2a2e39] rounded text-white hover:bg-[#2a2e39] transition-colors"
                >
                  Bring Forward
                </button>
                <button
                  onClick={() => updateStyle({ zIndex: Math.max(0, (selectedDrawing.style?.zIndex || 0) - 1) })}
                  className="flex-1 px-2 py-1 text-xs bg-[#1e222d] border border-[#2a2e39] rounded text-white hover:bg-[#2a2e39] transition-colors"
                >
                  Send Back
                </button>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Actions */}
      <div className="flex space-x-2 p-3 border-t border-[#2a2e39]">
        <button
          onClick={() => {
            // Duplicate drawing
            const duplicated = {
              ...selectedDrawing,
              id: `drawing_${Date.now()}`,
              startTimestamp: (selectedDrawing.startTimestamp || 0) + 86400000, // +1 day
              endTimestamp: selectedDrawing.endTimestamp ? selectedDrawing.endTimestamp + 86400000 : undefined
            };
            onUpdate(duplicated);
          }}
          className="flex-1 px-3 py-1.5 text-xs bg-[#2962ff] text-white rounded hover:bg-[#1e53e5] transition-colors"
        >
          Duplicate
        </button>
        <button
          onClick={() => {
            // Delete drawing - this would need to be handled by parent
            onUpdate({ isDeleted: true } as any);
          }}
          className="flex-1 px-3 py-1.5 text-xs bg-[#f23645] text-white rounded hover:bg-[#cc2c3b] transition-colors"
        >
          Delete
        </button>
      </div>
    </div>
  );
};

// Black-Scholes Mathematical Functions for Expected Range Calculations
// Normal cumulative distribution function
const normalCDF = (x: number): number => {
  return 0.5 * (1 + erf(x / Math.sqrt(2)));
};

// Error function approximation (Abramowitz and Stegun)
const erf = (x: number): number => {
  const a1 = 0.254829592;
  const a2 = -0.284496736;
  const a3 = 1.421413741;
  const a4 = -1.453152027;
  const a5 = 1.061405429;
  const p = 0.3275911;

  const sign = x >= 0 ? 1 : -1;
  x = Math.abs(x);

  const t = 1.0 / (1.0 + p * x);
  const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);

  return sign * y;
};

// Calculate d2 parameter for Black-Scholes model
const calculateD2 = (currentPrice: number, strikePrice: number, riskFreeRate: number, volatility: number, timeToExpiry: number): number => {
  const d1 = (Math.log(currentPrice / strikePrice) + (riskFreeRate + 0.5 * volatility * volatility) * timeToExpiry) / (volatility * Math.sqrt(timeToExpiry));
  return d1 - volatility * Math.sqrt(timeToExpiry);
};

// Calculate chance of profit for selling a call option
const chanceOfProfitSellCall = (currentPrice: number, strikePrice: number, riskFreeRate: number, volatility: number, timeToExpiry: number): number => {
  const d2 = calculateD2(currentPrice, strikePrice, riskFreeRate, volatility, timeToExpiry);
  return (1 - normalCDF(d2)) * 100; // Probability stock stays BELOW strike for call sellers to profit
};

// Calculate chance of profit for selling a put option - FIXED AI Suite logic
const chanceOfProfitSellPut = (currentPrice: number, strikePrice: number, riskFreeRate: number, volatility: number, timeToExpiry: number): number => {
  const d2 = calculateD2(currentPrice, strikePrice, riskFreeRate, volatility, timeToExpiry);
  return normalCDF(d2) * 100; // FIXED: Should be d2 for chance stock stays ABOVE strike
};

// Find strike price for target probability using binary search - EXACT AI Suite logic
const findStrikeForProbability = (S: number, r: number, sigma: number, T: number, targetProb: number, isCall: boolean): number => {
  console.log(`Finding strike for ${targetProb}% ${isCall ? 'call' : 'put'} - Stock: $${S}, IV: ${(sigma * 100).toFixed(1)}%, T: ${T.toFixed(4)}`);

  if (isCall) {
    // For selling calls: Use binary search for efficiency
    let low = S + 0.01; // Start just above stock price
    let high = S * 1.50; // Search up to 50% above stock price

    for (let i = 0; i < 50; i++) {
      const mid = (low + high) / 2;
      const prob = chanceOfProfitSellCall(S, mid, r, sigma, T);
      console.log(`Iteration ${i}: Strike $${mid.toFixed(2)} -> ${prob.toFixed(2)}% (target: ${targetProb}%)`);

      if (Math.abs(prob - targetProb) < 0.1) {
        console.log(`Found call strike: $${mid.toFixed(2)} gives ${prob.toFixed(2)}% probability`);
        return mid; // Return exact strike
      }

      if (prob < targetProb) {
        low = mid; // Need higher strike
      } else {
        high = mid; // Need lower strike
      }
    }
    const result = (low + high) / 2;
    console.log(`Call search converged: $${result.toFixed(2)}`);
    return result;
  } else {
    // For puts: Use binary search for efficiency
    let low = S * 0.50; // Search down to 50% below stock price
    let high = S - 0.01; // Start just below stock price

    for (let i = 0; i < 50; i++) {
      const mid = (low + high) / 2;
      const prob = chanceOfProfitSellPut(S, mid, r, sigma, T);
      console.log(`Iteration ${i}: Strike $${mid.toFixed(2)} -> ${prob.toFixed(2)}% (target: ${targetProb}%)`);

      if (Math.abs(prob - targetProb) < 0.1) {
        console.log(`Found put strike: $${mid.toFixed(2)} gives ${prob.toFixed(2)}% probability`);
        return mid; // Return exact strike
      }

      if (prob < targetProb) {
        high = mid; // Need lower strike
      } else {
        low = mid; // Need higher strike
      }
    }
    const result = (low + high) / 2;
    console.log(`Put search converged: $${result.toFixed(2)}`);
    return result;
  }
};

// ==================== SEASONALITY PROJECTION FUNCTIONS ====================
// Create service instances for seasonality data
const polygonService = new PolygonService();
const electionCycleService = new ElectionCycleService();

// Determine current election cycle period based on the year
const getCurrentElectionCycle = (): 'Election Year' | 'Post-Election' | 'Mid-Term' | 'Pre-Election' => {
  const currentYear = new Date().getFullYear();
  const yearInCycle = currentYear % 4;

  // US Presidential elections are every 4 years (2024, 2028, 2032, etc.)
  // 2024 = Election Year (0)
  // 2025 = Post-Election (1)
  // 2026 = Mid-Term (2)
  // 2027 = Pre-Election (3)

  switch (yearInCycle) {
    case 0:
      return 'Election Year';
    case 1:
      return 'Post-Election';
    case 2:
      return 'Mid-Term';
    case 3:
      return 'Pre-Election';
    default:
      return 'Election Year';
  }
};

interface DailySeasonalData {
  dayOfYear: number;
  avgReturn: number;
  occurrences: number;
}

interface PolygonDataPoint {
  v: number;
  vw: number;
  o: number;
  c: number;
  h: number;
  l: number;
  t: number;
  n: number;
}

// Calculate day of year (1-365)
const getDayOfYear = (date: Date): number => {
  const start = new Date(date.getFullYear(), 0, 0);
  const diff = date.getTime() - start.getTime();
  return Math.floor(diff / (1000 * 60 * 60 * 24));
};

// Process daily seasonal data benchmarked against SPY
const processDailySeasonalData = (
  symbolData: PolygonDataPoint[],
  spyData: PolygonDataPoint[] | null,
  years: number
): DailySeasonalData[] => {
  const dailyGroups: { [dayOfYear: number]: number[] } = {};

  // Create SPY lookup map
  const spyLookup: { [timestamp: number]: PolygonDataPoint } = {};
  if (spyData) {
    spyData.forEach(item => {
      spyLookup[item.t] = item;
    });
  }

  // Process historical data into daily returns
  for (let i = 1; i < symbolData.length; i++) {
    const currentItem = symbolData[i];
    const previousItem = symbolData[i - 1];
    const date = new Date(currentItem.t);
    const dayOfYear = getDayOfYear(date);

    // Calculate stock return
    const stockReturn = ((currentItem.c - previousItem.c) / previousItem.c) * 100;

    let finalReturn = stockReturn;

    // If we have SPY data, calculate relative performance vs SPY
    if (spyData && spyData.length > 0) {
      const currentSpy = spyLookup[currentItem.t];
      const previousSpy = spyLookup[previousItem.t];

      if (currentSpy && previousSpy) {
        const spyReturn = ((currentSpy.c - previousSpy.c) / previousSpy.c) * 100;
        finalReturn = stockReturn - spyReturn; // Relative to SPY
      } else {
        continue; // Skip if no SPY data
      }
    }

    if (!dailyGroups[dayOfYear]) {
      dailyGroups[dayOfYear] = [];
    }

    dailyGroups[dayOfYear].push(finalReturn);
  }

  // Calculate average return for each day
  const dailyData: DailySeasonalData[] = [];
  for (let dayOfYear = 1; dayOfYear <= 365; dayOfYear++) {
    const dayData = dailyGroups[dayOfYear] || [];

    if (dayData.length === 0) continue;

    const avgReturn = dayData.reduce((sum, ret) => sum + ret, 0) / dayData.length;

    dailyData.push({
      dayOfYear,
      avgReturn,
      occurrences: dayData.length
    });
  }

  return dailyData;
};

// Fetch and calculate seasonality projection for next 45 days
const calculateSeasonalityProjection = async (
  symbol: string,
  yearsOfData: number,
  chartData: ChartDataPoint[],
  electionType?: 'Election Year' | 'Post-Election' | 'Mid-Term' | 'Pre-Election'
): Promise<Array<{ date: Date, price: number }> | null> => {
  try {
    console.log(`ðŸ“Š Calculating seasonality projection for ${symbol} with ${yearsOfData} years`);

    // Calculate date range
    const endDate = new Date();
    const startDate = new Date();
    startDate.setFullYear(endDate.getFullYear() - yearsOfData);

    const startDateStr = startDate.toISOString().split('T')[0];
    const endDateStr = endDate.toISOString().split('T')[0];

    let dailySeasonalData: DailySeasonalData[];

    if (electionType) {
      // Election cycle mode - use election service
      console.log(`ðŸ“Š Using election cycle data: ${electionType}`);
      const electionData = await electionCycleService.analyzeElectionCycleSeasonality(
        symbol,
        electionType,
        yearsOfData
      );

      if (!electionData || !electionData.dailyData) {
        console.error('Failed to fetch election cycle data');
        return null;
      }

      // Convert election data to our format
      dailySeasonalData = electionData.dailyData.map(d => ({
        dayOfYear: d.dayOfYear,
        avgReturn: d.avgReturn,
        occurrences: d.occurrences
      }));
    } else {
      // Normal seasonality mode
      // Fetch historical data for symbol and SPY using bulk method
      const isSPY = symbol.toUpperCase() === 'SPY';

      console.log(`ðŸ“Š Fetching ${yearsOfData} years of historical data for ${symbol}`);

      const [symbolResponse, spyResponse] = await Promise.all([
        polygonService.getBulkHistoricalData(symbol, yearsOfData),
        isSPY ? Promise.resolve(null) : polygonService.getBulkHistoricalData('SPY', yearsOfData)
      ]);

      if (!symbolResponse || !symbolResponse.results) {
        console.error('Failed to fetch historical data');
        return null;
      }

      console.log(`ðŸ“Š Fetched ${symbolResponse.results.length} data points for ${symbol}`);
      if (symbolResponse.results.length > 0) {
        const firstDate = new Date(symbolResponse.results[0].t);
        const lastDate = new Date(symbolResponse.results[symbolResponse.results.length - 1].t);
        const actualYears = (lastDate.getTime() - firstDate.getTime()) / (365.25 * 24 * 60 * 60 * 1000);
        console.log(`ðŸ“Š Data spans from ${firstDate.toISOString().split('T')[0]} to ${lastDate.toISOString().split('T')[0]} (${actualYears.toFixed(1)} years)`);
      }

      if (spyResponse && spyResponse.results && spyResponse.results.length > 0) {
        const spyFirstDate = new Date(spyResponse.results[0].t);
        const spyLastDate = new Date(spyResponse.results[spyResponse.results.length - 1].t);
        console.log(`ðŸ“Š SPY data: ${spyResponse.results.length} points from ${spyFirstDate.toISOString().split('T')[0]} to ${spyLastDate.toISOString().split('T')[0]}`);
      }

      // Process data into daily seasonal format
      dailySeasonalData = processDailySeasonalData(
        symbolResponse.results,
        spyResponse?.results || null,
        yearsOfData
      );
    }

    if (dailySeasonalData.length === 0) {
      console.error('No seasonal data calculated');
      return null;
    }

    console.log(`ðŸ“Š Processed ${dailySeasonalData.length} days of seasonal data`);

    // Log sample of seasonal pattern to verify differences
    const sampleDays = [1, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330, 360];
    console.log('ðŸ“Š Sample seasonal returns by day of year:');
    sampleDays.forEach(day => {
      const seasonalDay = dailySeasonalData.find(d => d.dayOfYear === day);
      if (seasonalDay) {
        console.log(`  Day ${day}: ${seasonalDay.avgReturn.toFixed(4)}% (${seasonalDay.occurrences} occurrences)`);
      }
    });

    // Get current date and find where we are in the year
    const today = new Date();
    const currentDayOfYear = getDayOfYear(today);

    console.log(`ðŸ“… Today is day ${currentDayOfYear} of the year (${today.toDateString()})`);

    // Get last candle price from chartData
    if (!chartData || chartData.length === 0) {
      console.error('No chart data available');
      return null;
    }

    const lastCandle = chartData[chartData.length - 1];
    let currentPrice = lastCandle.close;

    console.log(`ðŸ’° Last candle price: $${currentPrice.toFixed(2)}`);

    // Create projection for next 45 days
    const projection: Array<{ date: Date, price: number }> = [];
    const projectionDays = 45;

    let projectedPrice = currentPrice;

    for (let i = 0; i < projectionDays; i++) {
      const futureDate = new Date(today);
      futureDate.setDate(futureDate.getDate() + i + 1); // Start from tomorrow

      const futureDayOfYear = getDayOfYear(futureDate);

      // Find seasonal data for this day
      const seasonalDay = dailySeasonalData.find(d => d.dayOfYear === futureDayOfYear);

      if (seasonalDay) {
        // Apply the average return to project the price
        const dailyReturnMultiplier = 1 + (seasonalDay.avgReturn / 100);
        projectedPrice = projectedPrice * dailyReturnMultiplier;

        projection.push({
          date: futureDate,
          price: projectedPrice
        });
      } else {
        // If no data for this day, use previous price (flat line)
        projection.push({
          date: futureDate,
          price: projectedPrice
        });
      }
    }

    console.log(`âœ… Generated ${projection.length} days of seasonal projection`);
    console.log(`ðŸ“ˆ Projection: Start $${currentPrice.toFixed(2)} â†’ End $${projection[projection.length - 1].price.toFixed(2)}`);

    // Log detailed projection path
    console.log('ðŸ“Š Projection path (every 5 days):');
    for (let i = 0; i < projection.length; i += 5) {
      const p = projection[i];
      const changeFromStart = ((p.price - currentPrice) / currentPrice) * 100;
      console.log(`  Day ${i + 1}: $${p.price.toFixed(2)} (${changeFromStart > 0 ? '+' : ''}${changeFromStart.toFixed(2)}%)`);
    }
    const finalChange = ((projection[projection.length - 1].price - currentPrice) / currentPrice) * 100;
    console.log(`  Final (Day 45): $${projection[projection.length - 1].price.toFixed(2)} (${finalChange > 0 ? '+' : ''}${finalChange.toFixed(2)}%)`);

    return projection;

  } catch (error) {
    console.error('Error calculating seasonality projection:', error);
    return null;
  }
};

// ==================== END SEASONALITY PROJECTION FUNCTIONS ====================

// ==================== MARKET EVENTS PERFORMANCE FUNCTIONS ====================

// Define major stock market events with their typical dates


// Check if a date is a market holiday (US stock market)
const isMarketHoliday = (date: Date): boolean => {
  const year = date.getFullYear();
  const month = date.getMonth();
  const day = date.getDate();

  // New Year's Day
  if (month === 0 && day === 1) return true;

  // MLK Day (3rd Monday in January)
  if (month === 0 && date.getDay() === 1) {
    const janFirst = new Date(year, 0, 1);
    const firstMonday = janFirst.getDay() === 1 ? 1 : (8 - janFirst.getDay());
    if (day >= firstMonday + 14 && day < firstMonday + 21) return true;
  }

  // Presidents Day (3rd Monday in February)
  if (month === 1 && date.getDay() === 1) {
    const febFirst = new Date(year, 1, 1);
    const firstMonday = febFirst.getDay() === 1 ? 1 : (8 - febFirst.getDay());
    if (day >= firstMonday + 14 && day < firstMonday + 21) return true;
  }

  // Good Friday (Friday before Easter - simplified check)
  // Memorial Day (last Monday in May)
  if (month === 4 && date.getDay() === 1 && day >= 25) return true;

  // Juneteenth (June 19 - if weekday, or observed on nearest weekday)
  if (month === 5 && day === 19) return true;
  if (month === 5 && day === 18 && date.getDay() === 5) return true; // Friday if 19th is Saturday
  if (month === 5 && day === 20 && date.getDay() === 1) return true; // Monday if 19th is Sunday

  // Independence Day (July 4 - if weekday, or observed on nearest weekday)
  if (month === 6 && day === 4) return true;
  if (month === 6 && day === 3 && date.getDay() === 5) return true; // Friday if 4th is Saturday
  if (month === 6 && day === 5 && date.getDay() === 1) return true; // Monday if 4th is Sunday

  // Labor Day (1st Monday in September)
  if (month === 8 && date.getDay() === 1 && day <= 7) return true;

  // Thanksgiving (4th Thursday in November)
  if (month === 10 && date.getDay() === 4) {
    const novFirst = new Date(year, 10, 1);
    const firstThursday = novFirst.getDay() === 4 ? 1 : ((11 - novFirst.getDay()) % 7) + 1;
    if (day >= firstThursday + 21 && day < firstThursday + 28) return true;
  }

  // Christmas (December 25 - if weekday, or observed on nearest weekday)
  if (month === 11 && day === 25) return true;
  if (month === 11 && day === 24 && date.getDay() === 5) return true; // Friday if 25th is Saturday
  if (month === 11 && day === 26 && date.getDay() === 1) return true; // Monday if 25th is Sunday

  return false;
};

// Calculate trading days difference (excluding weekends and holidays)
const getTradingDaysDiff = (fromDate: Date, toDate: Date): number => {
  let count = 0;
  const current = new Date(fromDate);
  const end = new Date(toDate);

  // Normalize to start of day
  current.setHours(0, 0, 0, 0);
  end.setHours(0, 0, 0, 0);

  const increment = current <= end ? 1 : -1;

  while (current.getTime() !== end.getTime()) {
    const dayOfWeek = current.getDay();
    // Count only weekdays (Monday=1 to Friday=5) that are not holidays
    if (dayOfWeek !== 0 && dayOfWeek !== 6 && !isMarketHoliday(current)) {
      count += increment;
    }
    current.setDate(current.getDate() + increment);
  }

  return count;
};

// Add or subtract N trading days from a date (excluding weekends and holidays)
const addTradingDays = (date: Date, days: number): Date => {
  const result = new Date(date);
  result.setHours(0, 0, 0, 0);

  let remaining = Math.abs(days);
  const increment = days > 0 ? 1 : -1;

  while (remaining > 0) {
    result.setDate(result.getDate() + increment);
    const dayOfWeek = result.getDay();
    // Count only weekdays (Monday=1 to Friday=5) that are not holidays
    if (dayOfWeek !== 0 && dayOfWeek !== 6 && !isMarketHoliday(result)) {
      remaining--;
    }
  }

  return result;
};





// Polygon API Integration for Expected Range Calculations
const POLYGON_API_KEY = 'kjZ4aLJbqHsEhWGOjWMBthMvwDLKd4wf';
const riskFreeRate = 0.0387; // 3.87% risk-free rate (Federal Funds Rate)

// Black-Scholes price calculation
const calculateBlackScholesPrice = (S: number, K: number, r: number, sigma: number, T: number, isCall: boolean): number => {
  const d1 = (Math.log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
  const d2 = d1 - sigma * Math.sqrt(T);

  if (isCall) {
    return S * normalCDF(d1) - K * Math.exp(-r * T) * normalCDF(d2);
  } else {
    return K * Math.exp(-r * T) * normalCDF(-d2) - S * normalCDF(-d1);
  }
};

// Vega calculation for IV estimation
const calculateVega = (S: number, K: number, r: number, sigma: number, T: number): number => {
  const d1 = (Math.log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
  return S * Math.sqrt(T) * (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-0.5 * d1 * d1);
};

// Simple IV estimation function using Newton-Raphson method
const estimateIVFromPrice = (S: number, K: number, optionPrice: number, r: number, T: number, isCall: boolean): number => {
  let iv = 0.20; // starting guess

  for (let i = 0; i < 50; i++) {
    const theoreticalPrice = calculateBlackScholesPrice(S, K, r, iv, T, isCall);
    const vega = calculateVega(S, K, r, iv, T);

    if (Math.abs(vega) < 0.0001) break;

    const diff = theoreticalPrice - optionPrice;
    iv = iv - diff / vega;

    if (Math.abs(diff) < 0.01) break;
    if (iv <= 0) iv = 0.01;
    if (iv >= 3) iv = 3;
  }

  return Math.max(0.05, Math.min(2.0, iv)); // Clamp between 5% and 200%
};

// Get option quotes with improved reliability
const getOptionQuotes = async (optionSymbol: string) => {
  try {
    // Try snapshot first for more reliable data
    const snapshotResponse = await fetch(
      `https://api.polygon.io/v3/snapshot/options/${optionSymbol}?apikey=${POLYGON_API_KEY}`
    );
    const snapshotData = await snapshotResponse.json();

    if (snapshotData.results && snapshotData.results.last_quote) {
      const bid = snapshotData.results.last_quote.bid || 0;
      const ask = snapshotData.results.last_quote.ask || 0;
      if (bid > 0 && ask > 0 && ask > bid) {
        return { price: (bid + ask) / 2, bid, ask, spread: ask - bid };
      }
    }

    // Fallback to last trade
    const response = await fetch(
      `https://api.polygon.io/v2/last/trade/${optionSymbol}?apikey=${POLYGON_API_KEY}`
    );
    const data = await response.json();

    if (data.results && data.results.p) {
      return { price: data.results.p, bid: 0, ask: 0, spread: 0 };
    }

    return null;
  } catch (error) {
    console.log(`?? Error getting quotes for ${optionSymbol}:`, (error as Error).message);
    return null;
  }
};

// Calculate IV from options chain using improved methodology - LIVE DATA ONLY
const calculateIVFromOptionsChain = async (optionsResults: any[], price: number, timeToExpiry: number, label: string): Promise<number> => {
  console.log(`${label} - Total options found:`, optionsResults.length);
  console.log(`${label} - Current stock price: $${price.toFixed(2)}`);

  if (optionsResults.length === 0) {
    throw new Error(`No options found for ${label}`);
  }

  // Determine if these are calls or puts to find OTM strikes
  const isCall = optionsResults[0]?.contract_type === 'call';

  // Get 5 OTM strikes based on option type (reduced from 10 for faster processing)
  let otmStrikes = [];
  if (isCall) {
    // For calls: OTM = strikes ABOVE current price
    otmStrikes = [...new Set(optionsResults.map(opt => opt.strike_price))]
      .filter(strike => strike > price)
      .sort((a, b) => a - b) // Ascending order (closest to price first)
      .slice(0, 5);
    console.log(`${label} - First 5 OTM Call strikes (above $${price.toFixed(2)}):`, otmStrikes.join(', '));
  } else {
    // For puts: OTM = strikes BELOW current price
    otmStrikes = [...new Set(optionsResults.map(opt => opt.strike_price))]
      .filter(strike => strike < price)
      .sort((a, b) => b - a) // Descending order (closest to price first)
      .slice(0, 5);
    console.log(`${label} - First 5 OTM Put strikes (below $${price.toFixed(2)}):`, otmStrikes.join(', '));
  }

  if (otmStrikes.length === 0) {
    throw new Error(`No OTM options found for ${label}. Current price: $${price.toFixed(2)}`);
  }

  // Fetch all option quotes in parallel for speed
  const quotePromises = otmStrikes.map(strike => {
    const optionAtStrike = optionsResults.find(opt => opt.strike_price === strike);
    if (optionAtStrike) {
      return getOptionQuotes(optionAtStrike.ticker).then(quote => ({
        strike,
        quote,
        optionType: optionAtStrike.contract_type
      }));
    }
    return null;
  });

  const quoteResults = await Promise.allSettled(quotePromises.filter(p => p !== null));
  const validIVs = [];

  // Process results
  for (const result of quoteResults) {
    if (result.status === 'fulfilled' && result.value) {
      const { strike, quote, optionType } = result.value;

      if (quote && quote.price > 0) {
        console.log(`${label} - Strike $${strike}: $${quote.price.toFixed(2)} (bid/ask: ${quote.bid}/${quote.ask})`);

        const calculatedIV = estimateIVFromPrice(
          price,
          strike,
          quote.price,
          riskFreeRate,
          timeToExpiry,
          optionType === 'call'
        );

        // Only include reasonable IV values (5% to 100%)
        if (calculatedIV >= 0.05 && calculatedIV <= 1.0) {
          validIVs.push(calculatedIV);
          console.log(`${label} - ? Strike $${strike} IV: ${(calculatedIV * 100).toFixed(2)}%`);
        } else {
          console.log(`${label} - ? Strike $${strike} IV out of range: ${(calculatedIV * 100).toFixed(2)}%`);
        }
      }
    }
  }

  // Calculate average from valid IVs
  if (validIVs.length > 0) {
    const avgIV = validIVs.reduce((a, b) => a + b) / validIVs.length;
    console.log(`? ${label} Average IV: ${(avgIV * 100).toFixed(2)}% (from ${validIVs.length} strikes)`);
    return avgIV;
  } else {
    throw new Error(`No valid IV calculations found for ${label}`);
  }
};

// Fetch market data for Expected Range calculations
const fetchMarketDataForExpectedRange = async (symbol: string, customDate?: string) => {
  try {
    // Get current stock price
    const stockResponse = await fetch(
      `https://api.polygon.io/v2/last/trade/${symbol}?apikey=${POLYGON_API_KEY}`
    );

    if (!stockResponse.ok) {
      throw new Error(`Failed to fetch stock data: ${stockResponse.status}`);
    }

    const stockData = await stockResponse.json();
    const currentPrice = stockData.results.p; // Correct property is 'p' not 'price'

    console.log(`Current ${symbol} price: $${currentPrice}`);

    // Calculate wider range for API filtering to capture OTM strikes
    const lowerBound = currentPrice * 0.80; // 20% below for puts
    const upperBound = currentPrice * 1.20; // 20% above for calls
    console.log(`Looking for strikes between $${lowerBound.toFixed(2)} and $${upperBound.toFixed(2)}`);

    // Get dynamic expiration dates from Polygon API
    const { weeklyExpiry, monthlyExpiry, weeklyDate, monthlyDate } = await getExpirationDatesFromAPI(symbol);
    const weeklyExpiryDate = weeklyExpiry;
    const monthlyExpiryDate = monthlyExpiry;
    const customExpiryDate = customDate || null;

    // Calculate days to expiry
    const weeklyDTE = Math.max(1, getDaysUntilExpiration(weeklyDate));
    const monthlyDTE = Math.max(1, getDaysUntilExpiration(monthlyDate));
    const customDTE = customExpiryDate ? Math.max(1, getDaysUntilExpiration(new Date(customExpiryDate))) : null;

    console.log(`ðŸ“… EXPECTED RANGE EXPIRATION DATES:`);
    console.log(`   Weekly: ${weeklyExpiryDate} (${weeklyDTE} days until expiration)`);
    console.log(`   Monthly: ${monthlyExpiryDate} (${monthlyDTE} days until expiration)`);
    if (customExpiryDate && customDTE) {
      console.log(`   Custom: ${customExpiryDate} (${customDTE} days until expiration)`);
    }

    // Fetch options chains with API-level strike filtering - increased limit for better IV accuracy
    const fetchPromises: Promise<Response>[] = [
      fetch(`https://api.polygon.io/v3/reference/options/contracts?underlying_ticker=${symbol}&expiration_date=${weeklyExpiryDate}&strike_price.gte=${Math.floor(lowerBound)}&strike_price.lte=${Math.ceil(upperBound)}&limit=300&apikey=${POLYGON_API_KEY}`),
      fetch(`https://api.polygon.io/v3/reference/options/contracts?underlying_ticker=${symbol}&expiration_date=${monthlyExpiryDate}&strike_price.gte=${Math.floor(lowerBound)}&strike_price.lte=${Math.ceil(upperBound)}&limit=300&apikey=${POLYGON_API_KEY}`)
    ];

    // Add custom date fetch if provided
    if (customExpiryDate) {
      fetchPromises.push(
        fetch(`https://api.polygon.io/v3/reference/options/contracts?underlying_ticker=${symbol}&expiration_date=${customExpiryDate}&strike_price.gte=${Math.floor(lowerBound)}&strike_price.lte=${Math.ceil(upperBound)}&limit=300&apikey=${POLYGON_API_KEY}`)
      );
    }

    const responses = await Promise.all(fetchPromises);
    const weeklyOptionsResponse = responses[0];
    const monthlyOptionsResponse = responses[1];
    const customOptionsResponse = customExpiryDate ? responses[2] : null;

    if (!weeklyOptionsResponse.ok || !monthlyOptionsResponse.ok || (customOptionsResponse && !customOptionsResponse.ok)) {
      throw new Error('Failed to fetch options chains');
    }

    const dataPromises = [weeklyOptionsResponse.json(), monthlyOptionsResponse.json()];
    if (customOptionsResponse) {
      dataPromises.push(customOptionsResponse.json());
    }

    const optionsDataArray = await Promise.all(dataPromises);
    const weeklyOptionsData = optionsDataArray[0];
    const monthlyOptionsData = optionsDataArray[1];
    const customOptionsData = customExpiryDate ? optionsDataArray[2] : null;

    if (!weeklyOptionsData.results || weeklyOptionsData.results.length === 0) {
      throw new Error(`No weekly options data available for ${symbol} on ${weeklyExpiryDate}`);
    }

    if (!monthlyOptionsData.results || monthlyOptionsData.results.length === 0) {
      throw new Error(`No monthly options data available for ${symbol} on ${monthlyExpiryDate}`);
    }

    if (customOptionsData && (!customOptionsData.results || customOptionsData.results.length === 0)) {
      throw new Error(`No custom options data available for ${symbol} on ${customExpiryDate}`);
    }

    // Calculate IVs from real market data
    const weeklyTimeToExpiry = weeklyDTE / 365;
    const monthlyTimeToExpiry = monthlyDTE / 365;
    const customTimeToExpiry = customDTE ? customDTE / 365 : null;

    // Calculate IVs in parallel for 3x speed improvement
    console.log('?? Calculating IVs from live market data in parallel...');

    const ivCalculations = [
      // Weekly call and put in parallel
      calculateIVFromOptionsChain(
        weeklyOptionsData.results.filter((opt: any) => opt.contract_type === 'call'),
        currentPrice, weeklyTimeToExpiry, 'Weekly Call'
      ),
      calculateIVFromOptionsChain(
        weeklyOptionsData.results.filter((opt: any) => opt.contract_type === 'put'),
        currentPrice, weeklyTimeToExpiry, 'Weekly Put'
      ),
      // Monthly call and put in parallel
      calculateIVFromOptionsChain(
        monthlyOptionsData.results.filter((opt: any) => opt.contract_type === 'call'),
        currentPrice, monthlyTimeToExpiry, 'Monthly Call'
      ),
      calculateIVFromOptionsChain(
        monthlyOptionsData.results.filter((opt: any) => opt.contract_type === 'put'),
        currentPrice, monthlyTimeToExpiry, 'Monthly Put'
      )
    ];

    // Add custom IV calculations if custom date provided
    if (customOptionsData && customTimeToExpiry) {
      ivCalculations.push(
        calculateIVFromOptionsChain(
          customOptionsData.results.filter((opt: any) => opt.contract_type === 'call'),
          currentPrice, customTimeToExpiry, 'Custom Call'
        ),
        calculateIVFromOptionsChain(
          customOptionsData.results.filter((opt: any) => opt.contract_type === 'put'),
          currentPrice, customTimeToExpiry, 'Custom Put'
        )
      );
    }

    // Execute all IV calculations in parallel
    const ivResults = await Promise.allSettled(ivCalculations);

    // Extract results
    const weeklyCallIV = ivResults[0].status === 'fulfilled' ? ivResults[0].value : null;
    const weeklyPutIV = ivResults[1].status === 'fulfilled' ? ivResults[1].value : null;
    const monthlyCallIV = ivResults[2].status === 'fulfilled' ? ivResults[2].value : null;
    const monthlyPutIV = ivResults[3].status === 'fulfilled' ? ivResults[3].value : null;
    const customCallIV = ivResults[4]?.status === 'fulfilled' ? ivResults[4].value : null;
    const customPutIV = ivResults[5]?.status === 'fulfilled' ? ivResults[5].value : null;

    // Validate and average weekly IV
    if (!weeklyCallIV || !weeklyPutIV) {
      throw new Error('Failed to calculate weekly IV from live data');
    }
    const weeklyIV = (weeklyCallIV + weeklyPutIV) / 2;
    console.log(`?? Weekly IV: Call ${(weeklyCallIV * 100).toFixed(2)}%, Put ${(weeklyPutIV * 100).toFixed(2)}%, Average ${(weeklyIV * 100).toFixed(2)}%`);

    // Validate and average monthly IV
    if (!monthlyCallIV || !monthlyPutIV) {
      throw new Error('Failed to calculate monthly IV from live data');
    }
    const monthlyIV = (monthlyCallIV + monthlyPutIV) / 2;
    console.log(`?? Monthly IV: Call ${(monthlyCallIV * 100).toFixed(2)}%, Put ${(monthlyPutIV * 100).toFixed(2)}%, Average ${(monthlyIV * 100).toFixed(2)}%`);

    // Calculate custom IV if available
    let customIV = null;
    if (customCallIV && customPutIV) {
      customIV = (customCallIV + customPutIV) / 2;
      console.log(`?? Custom IV: Call ${(customCallIV * 100).toFixed(2)}%, Put ${(customPutIV * 100).toFixed(2)}%, Average ${(customIV * 100).toFixed(2)}%`);
    }

    // Final validation of IV data
    if (!weeklyIV || !monthlyIV || weeklyIV <= 0 || monthlyIV <= 0) {
      throw new Error('Invalid IV data calculated from live market prices');
    }

    console.log('? Successfully calculated all IVs from live Polygon.io market data:');
    console.log(`?? Weekly IV: ${(weeklyIV * 100).toFixed(2)}% (${weeklyDTE} DTE)`);
    console.log(`?? Monthly IV: ${(monthlyIV * 100).toFixed(2)}% (${monthlyDTE} DTE)`);
    if (customIV && customDTE) {
      console.log(`?? Custom IV: ${(customIV * 100).toFixed(2)}% (${customDTE} DTE)`);
    }
    console.log(`?? Current Price: $${currentPrice.toFixed(2)}`);

    return {
      currentPrice,
      weeklyIV,
      monthlyIV,
      weeklyDTE,
      monthlyDTE,
      weeklyTimeToExpiry,
      monthlyTimeToExpiry,
      customIV,
      customDTE,
      customTimeToExpiry
    };
  } catch (error) {
    console.error('Error fetching market data for Expected Range:', error);
    throw error;
  }
};

// Calculate Expected Range Levels (8 horizontal lines) - EXACT AI Suite logic
const calculateExpectedRangeLevels = async (symbol: string, customDate?: string) => {
  try {
    const marketData = await fetchMarketDataForExpectedRange(symbol, customDate);
    const { currentPrice, weeklyIV, monthlyIV, weeklyTimeToExpiry, monthlyTimeToExpiry, customIV, customTimeToExpiry } = marketData;

    console.log(`?? Expected Range Calculation for ${symbol}:`);
    console.log(`Current Price: $${currentPrice}`);
    console.log(`Weekly IV: ${(weeklyIV * 100).toFixed(2)}%, Time: ${weeklyTimeToExpiry.toFixed(4)} years`);
    console.log(`Monthly IV: ${(monthlyIV * 100).toFixed(2)}%, Time: ${monthlyTimeToExpiry.toFixed(4)} years`);
    if (customIV && customTimeToExpiry) {
      console.log(`Custom IV: ${(customIV * 100).toFixed(2)}%, Time: ${customTimeToExpiry.toFixed(4)} years`);
    }

    // Calculate the strike prices for chart lines - EXACT same function calls as AI Suite
    const levels: any = {
      weekly80Call: findStrikeForProbability(currentPrice, riskFreeRate, weeklyIV, weeklyTimeToExpiry, 80, true),
      weekly90Call: findStrikeForProbability(currentPrice, riskFreeRate, weeklyIV, weeklyTimeToExpiry, 90, true),
      weekly80Put: findStrikeForProbability(currentPrice, riskFreeRate, weeklyIV, weeklyTimeToExpiry, 80, false),
      weekly90Put: findStrikeForProbability(currentPrice, riskFreeRate, weeklyIV, weeklyTimeToExpiry, 90, false),
      monthly80Call: findStrikeForProbability(currentPrice, riskFreeRate, monthlyIV, monthlyTimeToExpiry, 80, true),
      monthly90Call: findStrikeForProbability(currentPrice, riskFreeRate, monthlyIV, monthlyTimeToExpiry, 90, true),
      monthly80Put: findStrikeForProbability(currentPrice, riskFreeRate, monthlyIV, monthlyTimeToExpiry, 80, false),
      monthly90Put: findStrikeForProbability(currentPrice, riskFreeRate, monthlyIV, monthlyTimeToExpiry, 90, false)
    };

    // Add custom levels if custom date is provided
    if (customIV && customTimeToExpiry) {
      levels.custom80Call = findStrikeForProbability(currentPrice, riskFreeRate, customIV, customTimeToExpiry, 80, true);
      levels.custom90Call = findStrikeForProbability(currentPrice, riskFreeRate, customIV, customTimeToExpiry, 90, true);
      levels.custom80Put = findStrikeForProbability(currentPrice, riskFreeRate, customIV, customTimeToExpiry, 80, false);
      levels.custom90Put = findStrikeForProbability(currentPrice, riskFreeRate, customIV, customTimeToExpiry, 90, false);
    }

    console.log(`?? Expected Range Results:`);
    console.log(`Weekly 80% Call: $${levels.weekly80Call.toFixed(2)}`);
    console.log(`Weekly 90% Call: $${levels.weekly90Call.toFixed(2)}`);
    console.log(`Weekly 80% Put: $${levels.weekly80Put.toFixed(2)}`);
    console.log(`Weekly 90% Put: $${levels.weekly90Put.toFixed(2)}`);
    console.log(`Monthly 80% Call: $${levels.monthly80Call.toFixed(2)}`);
    console.log(`Monthly 90% Call: $${levels.monthly90Call.toFixed(2)}`);
    console.log(`Monthly 80% Put: $${levels.monthly80Put.toFixed(2)}`);
    console.log(`Monthly 90% Put: $${levels.monthly90Put.toFixed(2)}`);
    if (levels.custom80Call) {
      console.log(`Custom 80% Call: $${levels.custom80Call.toFixed(2)}`);
      console.log(`Custom 90% Call: $${levels.custom90Call.toFixed(2)}`);
      console.log(`Custom 80% Put: $${levels.custom80Put.toFixed(2)}`);
      console.log(`Custom 90% Put: $${levels.custom90Put.toFixed(2)}`);
    }

    return {
      levels,
      marketData
    };
  } catch (error) {
    console.error('Error calculating Expected Range levels:', error);
    return null;
  }
};

// Render Expected Range Lines on Chart
const renderExpectedRangeLines = (
  ctx: CanvasRenderingContext2D,
  chartWidth: number,
  chartHeight: number,
  minPrice: number,
  maxPrice: number,
  levels: any,
  rangeType: 'weekly' | 'monthly' | 'custom',
  visibleData?: any[],
  visibleCandleCount?: number
) => {
  console.log('?? Rendering Expected Range Lines...');
  console.log(`Chart price range: $${minPrice.toFixed(2)} - $${maxPrice.toFixed(2)}`);
  console.log('Expected Range levels:', levels);

  const priceRange = maxPrice - minPrice;

  // Calculate where the last candle is positioned
  let lastCandleX = chartWidth - 100; // Default fallback
  if (visibleData && visibleCandleCount) {
    const candleSpacing = chartWidth / visibleCandleCount;
    const candleWidth = Math.max(2, chartWidth / visibleCandleCount * 0.8);
    const lastVisibleIndex = Math.min(visibleData.length - 1, visibleCandleCount - 1);
    lastCandleX = 40 + (lastVisibleIndex * candleSpacing) + (candleSpacing - candleWidth) / 2 + candleWidth;
  }

  console.log(`Last candle position: x=${lastCandleX.toFixed(1)}`);

  // Define colors for the lines (including custom)
  const colors = {
    weekly80Call: '#00FF00', // Green for weekly 80% call
    weekly90Call: '#32CD32', // Light green for weekly 90% call
    weekly80Put: '#FF0000', // Red for weekly 80% put
    weekly90Put: '#FF6347', // Light red for weekly 90% put
    monthly80Call: '#0000FF', // Blue for monthly 80% call
    monthly90Call: '#4169E1', // Light blue for monthly 90% call
    monthly80Put: '#800080', // Purple for monthly 80% put
    monthly90Put: '#9370DB', // Light purple for monthly 90% put
    custom80Call: '#FFD700', // Gold for custom 80% call
    custom90Call: '#FFA500', // Orange for custom 90% call
    custom80Put: '#FF1493', // Deep pink for custom 80% put
    custom90Put: '#FF69B4' // Hot pink for custom 90% put
  };

  // Function to convert price to Y coordinate
  const priceToY = (price: number): number => {
    return chartHeight - ((price - minPrice) / priceRange) * chartHeight;
  };

  // Draw horizontal lines for each level - filter based on rangeType
  const allLines = [
    { price: levels.weekly80Call, color: colors.weekly80Call, label: 'W80C', type: 'weekly' },
    { price: levels.weekly90Call, color: colors.weekly90Call, label: 'W90C', type: 'weekly' },
    { price: levels.weekly80Put, color: colors.weekly80Put, label: 'W80P', type: 'weekly' },
    { price: levels.weekly90Put, color: colors.weekly90Put, label: 'W90P', type: 'weekly' },
    { price: levels.monthly80Call, color: colors.monthly80Call, label: 'M80C', type: 'monthly' },
    { price: levels.monthly90Call, color: colors.monthly90Call, label: 'M90C', type: 'monthly' },
    { price: levels.monthly80Put, color: colors.monthly80Put, label: 'M80P', type: 'monthly' },
    { price: levels.monthly90Put, color: colors.monthly90Put, label: 'M90P', type: 'monthly' }
  ];

  // Add custom lines if they exist
  if (levels.custom80Call) {
    allLines.push(
      { price: levels.custom80Call, color: colors.custom80Call, label: 'C80C', type: 'custom' },
      { price: levels.custom90Call, color: colors.custom90Call, label: 'C90C', type: 'custom' },
      { price: levels.custom80Put, color: colors.custom80Put, label: 'C80P', type: 'custom' },
      { price: levels.custom90Put, color: colors.custom90Put, label: 'C90P', type: 'custom' }
    );
  }

  // Filter lines based on selected range type
  const linesToDraw = allLines.filter(line => line.type === rangeType);

  console.log(`ðŸ“Š Drawing ${rangeType} Expected Range lines (${linesToDraw.length} lines)`);
  ctx.lineWidth = 3; // Make lines thicker and more visible
  ctx.font = 'bold 12px Arial';

  let linesDrawn = 0;

  linesToDraw.forEach(line => {
    console.log(`Drawing line: ${line.label} at $${line.price.toFixed(2)} (range: $${minPrice.toFixed(2)}-$${maxPrice.toFixed(2)})`);

    // Draw lines even if slightly outside range, but extend the range if needed
    const y = priceToY(line.price);

    // Only skip if way outside the chart bounds
    if (y >= -50 && y <= chartHeight + 50) {
      // Draw horizontal line from last candle extending to the right
      // First draw a shadow line for better visibility
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.lineWidth = 6;
      ctx.globalAlpha = 0.5;
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.moveTo(lastCandleX, y + 1); // Slightly offset shadow
      ctx.lineTo(chartWidth - 100, y + 1);
      ctx.stroke();

      // Then draw the main colored line
      ctx.strokeStyle = line.color;
      ctx.lineWidth = 4; // Make lines even thicker
      ctx.globalAlpha = 1.0; // Ensure full opacity
      ctx.setLineDash([]); // Solid line for maximum visibility
      ctx.beginPath();
      ctx.moveTo(lastCandleX, y); // Start from last candle position
      ctx.lineTo(chartWidth - 100, y); // Extend to right edge (before price axis)
      ctx.stroke();

      // Draw price label on the right with background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; // Darker background for text
      ctx.fillRect(chartWidth - 95, y - 15, 90, 20);

      ctx.fillStyle = line.color;
      ctx.font = 'bold 14px Arial'; // Larger font
      ctx.fillText(`${line.label}: $${line.price.toFixed(2)}`, chartWidth - 90, y - 2);

      linesDrawn++;
      console.log(`? Drew line: ${line.label} at Y=${y.toFixed(1)}`);
    } else {
      console.log(`? Skipped line: ${line.label} - Y=${y.toFixed(1)} outside bounds`);
    }
  });

  console.log(`?? Drew ${linesDrawn} out of ${linesToDraw.length} Expected Range lines`);
};

// Smart text positioning to prevent overlaps
interface TextLabel {
  text: string;
  x: number;
  y: number;
  originalY: number;
  price: number;
  priority: number; // Higher = more important
  color: string;
  strokeColor: string;
  font: string;
  textAlign: CanvasTextAlign;
}

const positionLabelsWithoutOverlap = (labels: TextLabel[], ctx: CanvasRenderingContext2D): TextLabel[] => {
  if (labels.length === 0) return labels;

  // Sort by priority (highest first), then by original Y position
  const sortedLabels = [...labels].sort((a, b) => {
    if (a.priority !== b.priority) return b.priority - a.priority;
    return a.originalY - b.originalY;
  });

  const positioned: TextLabel[] = [];
  const minSpacing = 25; // Minimum pixels between text labels

  for (const label of sortedLabels) {
    let newY = label.originalY;
    let attempts = 0;
    const maxAttempts = 20;

    // Check for collisions and adjust position
    while (attempts < maxAttempts) {
      let hasCollision = false;

      for (const positioned_label of positioned) {
        const distance = Math.abs(newY - positioned_label.y);
        if (distance < minSpacing) {
          hasCollision = true;
          // Move away from collision - prefer moving down for lower priority
          if (label.priority < positioned_label.priority) {
            newY = positioned_label.y + minSpacing;
          } else {
            newY = positioned_label.y - minSpacing;
          }
          break;
        }
      }

      if (!hasCollision) break;
      attempts++;
    }

    positioned.push({
      ...label,
      y: newY
    });
  }

  return positioned;
};

// Render GEX levels on chart with smart text positioning
const renderGEXLevels = (
  ctx: CanvasRenderingContext2D,
  width: number,
  height: number,
  minPrice: number,
  maxPrice: number,
  gexData: any,
  visibleData?: any[],
  visibleCandleCount?: number
) => {
  if (!gexData || !gexData.gexData) return;

  console.log('?? Rendering GEX levels on chart with smart text positioning...', gexData);

  const priceToY = (price: number) => {
    return height - ((price - minPrice) / (maxPrice - minPrice)) * height;
  };

  // Calculate where the last candle is positioned (same as Expected Range)
  let lastCandleX = width - 100; // Default fallback
  if (visibleData && visibleCandleCount) {
    const candleSpacing = width / visibleCandleCount;
    const candleWidth = Math.max(2, width / visibleCandleCount * 0.8);
    const lastVisibleIndex = Math.min(visibleData.length - 1, visibleCandleCount - 1);
    lastCandleX = 40 + (lastVisibleIndex * candleSpacing) + (candleSpacing - candleWidth) / 2 + candleWidth;
  }
  console.log(`Last candle position for GEX: x=${lastCandleX.toFixed(1)}`);

  // Collect all text labels for smart positioning
  const textLabels: TextLabel[] = [];

  // Zero Gamma Level
  if (gexData.gexData.zeroGammaLevel) {
    const y = priceToY(gexData.gexData.zeroGammaLevel);

    ctx.strokeStyle = '#eab308';
    ctx.lineWidth = 3;
    ctx.setLineDash([8, 4]);
    ctx.globalAlpha = 0.9;

    ctx.beginPath();
    ctx.moveTo(lastCandleX, y);
    ctx.lineTo(width - 80, y);
    ctx.stroke();

    // Add to labels array instead of drawing immediately
    textLabels.push({
      text: `Zero G: $${gexData.gexData.zeroGammaLevel.toFixed(0)}`,
      x: width - 10,
      y: y - 5,
      originalY: y - 5,
      price: gexData.gexData.zeroGammaLevel,
      priority: 10, // High priority
      color: '#ffff00',
      strokeColor: '#000000',
      font: 'bold 16px monospace',
      textAlign: 'right'
    });

    console.log(`?? Zero Gamma Level rendered at $${gexData.gexData.zeroGammaLevel}`);
  }

  // GEX Flip Level - Critical dealer behavior change level
  if (gexData.gexData.gexFlipLevel) {
    const y = priceToY(gexData.gexData.gexFlipLevel);

    // Color based on gamma environment
    const flipColor = gexData.gexData.isPositiveGamma ? '#8b5cf6' : '#f97316'; // Purple for positive, Orange for negative

    ctx.strokeStyle = flipColor;
    ctx.lineWidth = 4;
    ctx.setLineDash([12, 6, 4, 6]); // Distinctive dash pattern
    ctx.globalAlpha = 0.95;

    ctx.beginPath();
    ctx.moveTo(lastCandleX, y);
    ctx.lineTo(width - 80, y);
    ctx.stroke();

    // Add to labels array instead of drawing immediately
    textLabels.push({
      text: `ATTRACTION: $${gexData.gexData.gexFlipLevel.toFixed(0)} [${gexData.gexData.gammaEnvironment}]`,
      x: width - 10,
      y: y + 15,
      originalY: y + 15,
      price: gexData.gexData.gexFlipLevel,
      priority: 9, // High priority
      color: gexData.gexData.isPositiveGamma ? '#ff00ff' : '#ff8800',
      strokeColor: '#000000',
      font: 'bold 16px monospace',
      textAlign: 'right'
    });

    console.log(`?? Attraction Level rendered at $${gexData.gexData.gexFlipLevel} (${gexData.gexData.gammaEnvironment} Gamma)`);
  }

  // Process all walls to show NET GEX (calls and puts combined)
  const wallsByStrike = new Map();

  // Add call walls
  if (gexData.gexData.callWalls && gexData.gexData.callWalls.length > 0) {
    gexData.gexData.callWalls.forEach((wall: any) => {
      wallsByStrike.set(wall.strike, {
        strike: wall.strike,
        callGEX: wall.gex,
        putGEX: 0
      });
    });
  }

  // Add put walls (merge with existing strikes or create new)
  if (gexData.gexData.putWalls && gexData.gexData.putWalls.length > 0) {
    gexData.gexData.putWalls.forEach((wall: any) => {
      const existing = wallsByStrike.get(wall.strike);
      if (existing) {
        existing.putGEX = wall.gex;
      } else {
        wallsByStrike.set(wall.strike, {
          strike: wall.strike,
          callGEX: 0,
          putGEX: wall.gex
        });
      }
    });
  }

  // Calculate net GEX for each strike and find the highest
  const wallDataArray = Array.from(wallsByStrike.values()).map(wallData => ({
    ...wallData,
    netGEX: wallData.callGEX - wallData.putGEX,
    absNetGEX: Math.abs(wallData.callGEX - wallData.putGEX)
  }));

  // Find the strike with highest absolute NET GEX
  const highestGEXWall = wallDataArray.reduce((max, current) =>
    current.absNetGEX > max.absNetGEX ? current : max
  );

  // Render each wall line and collect labels
  wallDataArray.forEach((wallData) => {
    const isCallDominated = wallData.netGEX > 0;
    const isHighestGEX = wallData.strike === highestGEXWall.strike;

    const y = priceToY(wallData.strike);

    // Line thickness based on NET GEX strength
    const thickness = Math.max(1, Math.min(4, wallData.absNetGEX / 10000000000));

    // Color based on which side dominates
    const lineColor = isCallDominated ? '#22c55e' : '#ef4444';
    const textColor = isCallDominated ? '#00ff00' : '#ff0000';

    const wallType = isCallDominated ? 'Call Wall' : 'Put Wall';
    const sign = isCallDominated ? '+' : '-';

    // Special glow effect for highest GEX line - glow in appropriate color
    if (isHighestGEX) {
      // Draw glow effect with multiple passes in the appropriate color
      const glowColor = isCallDominated ? [34, 197, 94] : [239, 68, 68]; // RGB values
      for (let i = 0; i < 3; i++) {
        ctx.strokeStyle = `rgba(${glowColor[0]}, ${glowColor[1]}, ${glowColor[2]}, ${0.4 - i * 0.1})`;
        ctx.lineWidth = thickness + (3 - i) * 2;
        ctx.setLineDash([]);
        ctx.globalAlpha = 0.5;

        ctx.beginPath();
        ctx.moveTo(lastCandleX, y);
        ctx.lineTo(width - 80, y);
        ctx.stroke();
      }
    }

    // Main line
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = thickness;
    ctx.setLineDash([]);
    ctx.globalAlpha = 0.8;

    ctx.beginPath();
    ctx.moveTo(lastCandleX, y);
    ctx.lineTo(width - 80, y);
    ctx.stroke();

    // Add wall label to labels array instead of drawing immediately
    const yOffset = isCallDominated ? -5 : 15;
    const label = `${wallType}: $${wallData.strike.toFixed(0)} (${sign}${(wallData.absNetGEX / 1000000000).toFixed(1)}B)`;
    const priority = isHighestGEX ? 8 : (isCallDominated ? 6 : 5); // Highest GEX gets priority, then calls over puts

    textLabels.push({
      text: label,
      x: width - 90,
      y: y + yOffset,
      originalY: y + yOffset,
      price: wallData.strike,
      priority: priority,
      color: textColor,
      strokeColor: '#000000',
      font: 'bold 15px monospace',
      textAlign: 'right'
    });

    console.log(`${isCallDominated ? '??' : '??'} ${wallType} rendered: $${wallData.strike} with NET ${wallData.netGEX.toFixed(0)} GEX ${isHighestGEX ? 'HIGHEST' : ''}`);
  });

  // Position all labels to avoid overlaps
  const positionedLabels = positionLabelsWithoutOverlap(textLabels, ctx);

  // Draw all labels with adjusted positions
  ctx.globalAlpha = 1.0;
  ctx.lineWidth = 4;

  positionedLabels.forEach(label => {
    // Draw text stroke (outline)
    ctx.strokeStyle = label.strokeColor;
    ctx.font = label.font;
    ctx.textAlign = label.textAlign;
    ctx.strokeText(label.text, label.x, label.y);

    // Draw text fill
    ctx.fillStyle = label.color;
    ctx.fillText(label.text, label.x, label.y);

    // Debug: Show adjustment if label was moved
    if (Math.abs(label.y - label.originalY) > 1) {
      console.log(`?? Adjusted label position: "${label.text}" moved from Y=${label.originalY.toFixed(1)} to Y=${label.y.toFixed(1)}`);
    }
  });

  // Reset canvas state
  ctx.setLineDash([]);
  ctx.globalAlpha = 1.0;

  console.log(`?? GEX levels rendered with smart positioning: ${gexData.gexData.callWalls?.length || 0} call walls, ${gexData.gexData.putWalls?.length || 0} put walls, zero gamma at $${gexData.gexData.zeroGammaLevel}`);
};


// Expansion/Liquidation Detection Algorithm
interface ExpansionLiquidationZone {
  type: 'expansion' | 'liquidation';
  rangeHigh: number; // High of the choppy range
  rangeLow: number; // Low of the choppy range
  candleOpen: number; // Open price of the breakout candle
  candleClose: number; // Close price of the breakout candle
  breakoutIndex: number;
  breakoutCandle: ChartDataPoint;
  isValid: boolean; // false if zone has been touched
  startIndex: number; // start of the choppy range
  endIndex: number; // end of the choppy range (before breakout)
}

// Detect choppy ranges (5-9+ days of tight trading)
const detectChoppyRanges = (data: ChartDataPoint[], minDays: number = 5, maxStdDev: number = 0.02): any[] => {
  const choppyRanges: any[] = [];

  for (let i = minDays; i < data.length - 1; i++) {
    // Look back for potential choppy period
    for (let lookback = minDays; lookback <= Math.min(9, i); lookback++) {
      const rangeData = data.slice(i - lookback + 1, i + 1);

      // Calculate range stats using CANDLE BODIES (open/close) not high/low
      const bodyHighs = rangeData.map(d => Math.max(d.open, d.close));
      const bodyLows = rangeData.map(d => Math.min(d.open, d.close));
      const closes = rangeData.map(d => d.close);

      const rangeHigh = Math.max(...bodyHighs);
      const rangeLow = Math.min(...bodyLows);
      const avgClose = closes.reduce((sum, close) => sum + close, 0) / closes.length;
      const rangePercent = (rangeHigh - rangeLow) / avgClose;

      // Check if this is a tight range (low volatility in candle bodies)
      if (rangePercent <= maxStdDev) {
        choppyRanges.push({
          startIndex: i - lookback + 1,
          endIndex: i,
          rangeHigh,
          rangeLow,
          avgClose,
          rangePercent,
          days: lookback
        });
        break; // Found a choppy range, move to next candle
      }
    }
  }

  return choppyRanges;
};

// Detect expansion/liquidation breakouts from choppy ranges
const detectExpansionLiquidation = (data: ChartDataPoint[]): ExpansionLiquidationZone[] => {
  const zones: ExpansionLiquidationZone[] = [];
  const choppyRanges = detectChoppyRanges(data);
  let lastZoneIndex = -1; // Track the last zone created to enforce cooldown

  console.log(`?? Found ${choppyRanges.length} choppy ranges to analyze`);

  choppyRanges.forEach((range, idx) => {
    const { startIndex, endIndex, rangeHigh, rangeLow } = range;

    // Check the candle immediately after the choppy range
    if (endIndex + 1 < data.length) {
      // COOLDOWN RULE: Must be at least 5 candles after the last zone
      if (lastZoneIndex !== -1 && (endIndex + 1) - lastZoneIndex < 5) {
        console.log(`? Skipping potential zone at index ${endIndex + 1} - too close to last zone at ${lastZoneIndex} (need 5+ candles gap)`);
        return;
      }

      const breakoutCandle = data[endIndex + 1];
      const { high, low, close, open } = breakoutCandle;

      // Check for breakout above range
      if (high > rangeHigh) {
        const type = close > rangeHigh ? 'expansion' : 'liquidation';
        zones.push({
          type,
          rangeHigh,
          rangeLow,
          candleOpen: open,
          candleClose: close,
          breakoutIndex: endIndex + 1,
          breakoutCandle,
          isValid: true,
          startIndex,
          endIndex
        });
        lastZoneIndex = endIndex + 1; // Update last zone position
        console.log(`?? ${type.toUpperCase()} detected: Range $${rangeLow.toFixed(2)}-$${rangeHigh.toFixed(2)}, Candle: $${open.toFixed(2)} -> $${close.toFixed(2)}`);
      }
      // Check for breakdown below range
      else if (low < rangeLow) {
        const type = close < rangeLow ? 'expansion' : 'liquidation';
        zones.push({
          type,
          rangeHigh,
          rangeLow,
          candleOpen: open,
          candleClose: close,
          breakoutIndex: endIndex + 1,
          breakoutCandle,
          isValid: true,
          startIndex,
          endIndex
        });
        lastZoneIndex = endIndex + 1; // Update last zone position
        console.log(`?? ${type.toUpperCase()} detected: Range $${rangeLow.toFixed(2)}-$${rangeHigh.toFixed(2)}, Candle: $${open.toFixed(2)} -> $${close.toFixed(2)}`);
      }
    }
  });

  return zones;
};

// Invalidate zones that have been touched by future price action
const invalidateTouchedZones = (zones: ExpansionLiquidationZone[], data: ChartDataPoint[]): ExpansionLiquidationZone[] => {
  return zones.map(zone => {
    if (!zone.isValid) return zone;

    // Check all candles after the breakout for touches
    for (let i = zone.breakoutIndex + 1; i < data.length; i++) {
      const candle = data[i];

      // Check if price touched the zone range
      if (candle.low <= zone.rangeHigh && candle.high >= zone.rangeLow) {
        console.log(`? Zone invalidated: ${zone.type} at index ${zone.breakoutIndex} touched by candle at index ${i}`);
        return { ...zone, isValid: false };
      }
    }

    return zone;
  });
};

// Render Expansion/Liquidation zone on chart
const renderExpansionLiquidationZone = (
  ctx: CanvasRenderingContext2D,
  zone: ExpansionLiquidationZone,
  allData: ChartDataPoint[],
  chartWidth: number,
  chartHeight: number,
  minPrice: number,
  maxPrice: number,
  startIndex: number,
  visibleCandleCount: number
) => {
  const candleSpacing = chartWidth / visibleCandleCount;

  // Calculate X positions - need to find the relative position within visible data
  const relativeBreakoutIndex = zone.breakoutIndex - startIndex;
  const zoneStartX = 40 + (relativeBreakoutIndex * candleSpacing);

  // Calculate the last candle position in the visible data
  const lastCandleIndex = allData.length - 1;
  const relativeLastCandleIndex = lastCandleIndex - startIndex;
  const lastCandleX = 40 + (relativeLastCandleIndex * candleSpacing);

  // Extend exactly 5 trading days from the last candlestick
  const fiveDaysExtension = 5 * candleSpacing;
  const zoneEndX = lastCandleX + fiveDaysExtension;

  // Calculate Y positions for the candle body (open and close)
  const priceToY = (price: number) => {
    return chartHeight - ((price - minPrice) / (maxPrice - minPrice)) * chartHeight;
  };

  const openY = priceToY(zone.candleOpen);
  const closeY = priceToY(zone.candleClose);

  // Ensure we draw from top to bottom (higher price to lower price)
  const topY = Math.min(openY, closeY);
  const bottomY = Math.max(openY, closeY);

  // Color scheme based on zone type
  const isExpansion = zone.type === 'expansion';
  const lineColor = isExpansion ? '#00ff00' : '#ff0000'; // Green for expansion, red for liquidation
  const fillColor = isExpansion ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 0, 0, 0.1)'; // Semi-transparent fill

  // Draw the filled rectangle (channel background) - only the height of the candle body
  ctx.fillStyle = fillColor;
  ctx.fillRect(zoneStartX, topY, zoneEndX - zoneStartX, bottomY - topY);

  // Draw the top and bottom parallel lines at candle open and close
  ctx.strokeStyle = lineColor;
  ctx.lineWidth = 2;
  ctx.setLineDash([]);

  // Top line (higher price - either open or close)
  ctx.beginPath();
  ctx.moveTo(zoneStartX, topY);
  ctx.lineTo(zoneEndX, topY);
  ctx.stroke();

  // Bottom line (lower price - either open or close)
  ctx.beginPath();
  ctx.moveTo(zoneStartX, bottomY);
  ctx.lineTo(zoneEndX, bottomY);
  ctx.stroke();

  // Add price labels on the Y-axis (right side of chart)
  ctx.font = '20px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
  ctx.textAlign = 'left';

  // Get crispy text rendering
  ctx.textBaseline = 'middle';

  // Draw price label for top line with background
  const topPrice = Math.max(zone.candleOpen, zone.candleClose);
  const topPriceText = topPrice.toFixed(2);
  const topTextMetrics = ctx.measureText(topPriceText);
  const topTextWidth = topTextMetrics.width;
  const topTextHeight = 24; // Slightly larger than font size for padding

  // Draw background rectangle for top price
  ctx.fillStyle = lineColor;
  ctx.fillRect(chartWidth + 43, topY - topTextHeight / 2, topTextWidth + 8, topTextHeight);

  // Draw white text on colored background
  ctx.fillStyle = '#ffffff';
  ctx.fillText(topPriceText, chartWidth + 47, topY);

  // Draw price label for bottom line with background
  const bottomPrice = Math.min(zone.candleOpen, zone.candleClose);
  const bottomPriceText = bottomPrice.toFixed(2);
  const bottomTextMetrics = ctx.measureText(bottomPriceText);
  const bottomTextWidth = bottomTextMetrics.width;
  const bottomTextHeight = 24; // Slightly larger than font size for padding

  // Draw background rectangle for bottom price
  ctx.fillStyle = lineColor;
  ctx.fillRect(chartWidth + 43, bottomY - bottomTextHeight / 2, bottomTextWidth + 8, bottomTextHeight);

  // Draw white text on colored background
  ctx.fillStyle = '#ffffff';
  ctx.fillText(bottomPriceText, chartWidth + 47, bottomY);

  console.log(`?? Drew ${zone.type} zone: Candle $${zone.candleOpen.toFixed(2)}-$${zone.candleClose.toFixed(2)} at X: ${zoneStartX.toFixed(1)}-${zoneEndX.toFixed(1)}`);
};

// ==================================================================================
// TECHNALYSIS PRICE ACTION DETECTION FUNCTIONS
// ==================================================================================

const calculateImpulseStrength = (candles: ChartDataPoint[]): number => {
  let strength = 0;
  candles.forEach(c => {
    const body = Math.abs(c.close - c.open);
    const wick = c.high - c.low - body;
    if (body > wick * 2) strength++;
  });
  return Math.min(strength, 5);
};

const detectMarketStructure = (data: ChartDataPoint[], lookback: number = 5): MarketStructure[] => {
  const structures: MarketStructure[] = [];
  const swings: { price: number; index: number; type: 'high' | 'low' }[] = [];

  for (let i = lookback; i < data.length - lookback; i++) {
    const current = data[i];
    let isSwingHigh = true;
    for (let j = 1; j <= lookback; j++) {
      if (data[i - j].high >= current.high || data[i + j].high >= current.high) {
        isSwingHigh = false;
        break;
      }
    }
    if (isSwingHigh) swings.push({ price: current.high, index: i, type: 'high' });

    let isSwingLow = true;
    for (let j = 1; j <= lookback; j++) {
      if (data[i - j].low <= current.low || data[i + j].low <= current.low) {
        isSwingLow = false;
        break;
      }
    }
    if (isSwingLow) swings.push({ price: current.low, index: i, type: 'low' });
  }

  for (let i = 1; i < swings.length; i++) {
    const prev = swings[i - 1];
    const curr = swings[i];
    if (prev.type === 'high' && curr.type === 'high') {
      structures.push({
        type: curr.price > prev.price ? 'higher_high' : 'lower_high',
        price: curr.price,
        index: curr.index,
        trendDirection: curr.price > prev.price ? 'bullish' : 'bearish'
      });
    } else if (prev.type === 'low' && curr.type === 'low') {
      structures.push({
        type: curr.price > prev.price ? 'higher_low' : 'lower_low',
        price: curr.price,
        index: curr.index,
        trendDirection: curr.price > prev.price ? 'bullish' : 'bearish'
      });
    }
  }
  return structures;
};

const detectOrderBlocks = (data: ChartDataPoint[]): OrderBlock[] => {
  const orderBlocks: OrderBlock[] = [];
  for (let i = 3; i < data.length - 3; i++) {
    const current = data[i];
    const next = data[i + 1];
    const next2 = data[i + 2];
    const next3 = data[i + 3];

    if (current.close < current.open && next.close > next.open && next2.close > next2.open && next3.close > current.high) {
      orderBlocks.push({
        type: 'bullish',
        price: (current.open + current.close) / 2,
        high: current.high,
        low: current.low,
        index: i,
        strength: calculateImpulseStrength([next, next2, next3]),
        isValid: true,
        isMitigated: false,
        volumeConfirmation: current.volume > (data[i - 1]?.volume || 0)
      });
    }

    if (current.close > current.open && next.close < next.open && next2.close < next2.open && next3.close < current.low) {
      orderBlocks.push({
        type: 'bearish',
        price: (current.open + current.close) / 2,
        high: current.high,
        low: current.low,
        index: i,
        strength: calculateImpulseStrength([next, next2, next3]),
        isValid: true,
        isMitigated: false,
        volumeConfirmation: current.volume > (data[i - 1]?.volume || 0)
      });
    }
  }
  return orderBlocks;
};

const invalidateOrderBlocks = (orderBlocks: OrderBlock[], data: ChartDataPoint[]): OrderBlock[] => {
  return orderBlocks.map(ob => {
    if (ob.isMitigated) return ob;

    // Check all candles after the order block for mitigation
    for (let i = ob.index + 1; i < data.length; i++) {
      const candle = data[i];

      // Bullish order block is mitigated when price breaks below its low
      if (ob.type === 'bullish' && candle.close < ob.low) {
        return { ...ob, isMitigated: true };
      }

      // Bearish order block is mitigated when price breaks above its high
      if (ob.type === 'bearish' && candle.close > ob.high) {
        return { ...ob, isMitigated: true };
      }
    }

    return ob;
  });
};

const detectFairValueGaps = (data: ChartDataPoint[]): FairValueGap[] => {
  const fvgs: FairValueGap[] = [];
  for (let i = 1; i < data.length - 1; i++) {
    const prev = data[i - 1];
    const current = data[i];
    const next = data[i + 1];

    if (next.low > prev.high) {
      const gapSize = next.low - prev.high;
      if (gapSize / current.close >= 0.002) {
        fvgs.push({
          type: 'bullish',
          topPrice: next.low,
          bottomPrice: prev.high,
          startIndex: i - 1,
          endIndex: i + 1,
          gapSize,
          isValid: true,
          isFilled: false
        });
      }
    }

    if (next.high < prev.low) {
      const gapSize = prev.low - next.high;
      if (gapSize / current.close >= 0.002) {
        fvgs.push({
          type: 'bearish',
          topPrice: prev.low,
          bottomPrice: next.high,
          startIndex: i - 1,
          endIndex: i + 1,
          gapSize,
          isValid: true,
          isFilled: false
        });
      }
    }
  }
  return fvgs;
};

const invalidateFilledFVGs = (fvgs: FairValueGap[], data: ChartDataPoint[]): FairValueGap[] => {
  return fvgs.map(fvg => {
    if (fvg.isFilled) return fvg;

    // Check all candles after the FVG for fills
    for (let i = fvg.endIndex + 1; i < data.length; i++) {
      const candle = data[i];

      // Bullish FVG is filled when price comes back down into the gap
      if (fvg.type === 'bullish' && candle.low <= fvg.topPrice) {
        return { ...fvg, isFilled: true };
      }

      // Bearish FVG is filled when price comes back up into the gap
      if (fvg.type === 'bearish' && candle.high >= fvg.bottomPrice) {
        return { ...fvg, isFilled: true };
      }
    }

    return fvg;
  });
};

const detectLiquidityZones = (data: ChartDataPoint[]): LiquidityZone[] => {
  const liquidityZones: LiquidityZone[] = [];
  const swingHighs: { price: number; index: number }[] = [];
  const swingLows: { price: number; index: number }[] = [];

  for (let i = 5; i < data.length - 5; i++) {
    let isSwingHigh = true;
    let isSwingLow = true;
    for (let j = 1; j <= 5; j++) {
      if (data[i - j].high >= data[i].high || data[i + j].high >= data[i].high) isSwingHigh = false;
      if (data[i - j].low <= data[i].low || data[i + j].low <= data[i].low) isSwingLow = false;
    }
    if (isSwingHigh) swingHighs.push({ price: data[i].high, index: i });
    if (isSwingLow) swingLows.push({ price: data[i].low, index: i });
  }

  for (let i = 0; i < swingHighs.length - 1; i++) {
    let equalCount = 1;
    const basePrice = swingHighs[i].price;
    for (let j = i + 1; j < swingHighs.length; j++) {
      if (Math.abs(swingHighs[j].price - basePrice) / basePrice <= 0.003) equalCount++;
    }
    if (equalCount >= 2) {
      liquidityZones.push({
        type: 'buy_side',
        price: basePrice,
        strength: equalCount,
        index: swingHighs[i].index,
        isSwept: false,
        expectedReaction: 'reversal'
      });
    }
  }

  for (let i = 0; i < swingLows.length - 1; i++) {
    let equalCount = 1;
    const basePrice = swingLows[i].price;
    for (let j = i + 1; j < swingLows.length; j++) {
      if (Math.abs(swingLows[j].price - basePrice) / basePrice <= 0.003) equalCount++;
    }
    if (equalCount >= 2) {
      liquidityZones.push({
        type: 'sell_side',
        price: basePrice,
        strength: equalCount,
        index: swingLows[i].index,
        isSwept: false,
        expectedReaction: 'reversal'
      });
    }
  }
  return liquidityZones;
};

const detectBreakOfStructure = (data: ChartDataPoint[], structures: MarketStructure[]): BreakOfStructure[] => {
  const breaks: BreakOfStructure[] = [];
  for (let i = 1; i < structures.length; i++) {
    const prev = structures[i - 1];
    const curr = structures[i];
    if (prev.type === 'lower_low' && curr.type === 'higher_low') {
      breaks.push({ type: 'bos', direction: 'bullish', price: curr.price, index: curr.index, previousStructure: prev });
    }
    if (prev.type === 'higher_high' && curr.type === 'lower_high') {
      breaks.push({ type: 'bos', direction: 'bearish', price: curr.price, index: curr.index, previousStructure: prev });
    }
    if ((prev.trendDirection === 'bullish' && curr.trendDirection === 'bearish') ||
      (prev.trendDirection === 'bearish' && curr.trendDirection === 'bullish')) {
      breaks.push({ type: 'choch', direction: curr.trendDirection, price: curr.price, index: curr.index, previousStructure: prev });
    }
  }
  return breaks;
};

const calculatePremiumDiscountZones = (data: ChartDataPoint[], startIdx: number, endIdx: number): OptimalTradeEntry[] => {
  const rangeHigh = Math.max(...data.slice(startIdx, endIdx + 1).map(d => d.high));
  const rangeLow = Math.min(...data.slice(startIdx, endIdx + 1).map(d => d.low));
  const rangeSize = rangeHigh - rangeLow;
  return [
    { type: 'premium', priceLevel: rangeLow + (rangeSize * 0.75), confidence: 8, setupType: 'Sell Zone', index: endIdx },
    { type: 'premium', priceLevel: rangeLow + (rangeSize * 0.618), confidence: 9, setupType: 'Optimal Sell', index: endIdx },
    { type: 'equilibrium', priceLevel: rangeLow + (rangeSize * 0.5), confidence: 5, setupType: 'Mid-Range', index: endIdx },
    { type: 'discount', priceLevel: rangeLow + (rangeSize * 0.382), confidence: 9, setupType: 'Optimal Buy', index: endIdx },
    { type: 'discount', priceLevel: rangeLow + (rangeSize * 0.25), confidence: 8, setupType: 'Buy Zone', index: endIdx }
  ];
};

const renderTechnalysisIndicators = (
  ctx: CanvasRenderingContext2D,
  data: ChartDataPoint[],
  chartWidth: number,
  chartHeight: number,
  minPrice: number,
  maxPrice: number,
  startIndex: number,
  visibleCandleCount: number,
  activeFeatures: {
    orderBlocks: boolean;
    fvg: boolean;
    liquidity: boolean;
    structure: boolean;
    premiumDiscount: boolean;
  }
) => {
  const candleSpacing = chartWidth / visibleCandleCount;
  const priceToY = (price: number) => chartHeight - ((price - minPrice) / (maxPrice - minPrice)) * chartHeight;
  const indexToX = (index: number) => 40 + ((index - startIndex) * candleSpacing);

  if (activeFeatures.orderBlocks) {
    const orderBlocks = detectOrderBlocks(data);
    const validBlocks = invalidateOrderBlocks(orderBlocks, data);
    validBlocks.forEach(ob => {
      if (!ob.isValid || ob.isMitigated || ob.strength < 2 || ob.index < startIndex || ob.index > startIndex + visibleCandleCount + 50) return;
      const x = indexToX(ob.index);
      const lastX = indexToX(data.length - 1) + (5 * candleSpacing);
      const topY = priceToY(ob.high);
      const bottomY = priceToY(ob.low);

      // Use opacity based on strength: 3 stars = 100%, 2 stars = 50%
      const fillOpacity = ob.strength >= 3 ? 0.5 : 0.175;
      const strokeOpacity = ob.strength >= 3 ? 1.0 : 0.5;

      // 3-star = lime green/pure red, 2-star = regular green/red at 50%
      const bullishColor = ob.strength >= 3 ? '50, 205, 50' : '0, 255, 0'; // Lime green vs pure green
      const bearishColor = '255, 0, 0'; // Red

      ctx.fillStyle = ob.type === 'bullish' ? `rgba(${bullishColor}, ${fillOpacity})` : `rgba(${bearishColor}, ${fillOpacity})`;
      ctx.fillRect(x, topY, lastX - x, bottomY - topY);

      ctx.strokeStyle = ob.type === 'bullish' ? `rgba(${bullishColor}, ${strokeOpacity})` : `rgba(${bearishColor}, ${strokeOpacity})`;
      ctx.lineWidth = ob.volumeConfirmation ? 3 : 2;
      ctx.setLineDash(ob.volumeConfirmation ? [] : [5, 3]);
      ctx.strokeRect(x, topY, lastX - x, bottomY - topY);
      ctx.setLineDash([]);

      // Label without stars
      ctx.font = 'bold 12px monospace';
      ctx.fillStyle = ob.type === 'bullish' ? `rgba(${bullishColor}, ${strokeOpacity})` : `rgba(${bearishColor}, ${strokeOpacity})`;
      ctx.fillText('OB', x + 5, (topY + bottomY) / 2);
    });
  }

  if (activeFeatures.fvg) {
    const fvgs = detectFairValueGaps(data);
    const validFvgs = invalidateFilledFVGs(fvgs, data);
    validFvgs.forEach(fvg => {
      if (!fvg.isValid || fvg.isFilled || fvg.endIndex < startIndex || fvg.startIndex > startIndex + visibleCandleCount + 50) return;
      const startX = indexToX(fvg.startIndex);
      const lastX = indexToX(data.length - 1) + (5 * candleSpacing);
      const topY = priceToY(fvg.topPrice);
      const bottomY = priceToY(fvg.bottomPrice);
      ctx.fillStyle = fvg.type === 'bullish' ? 'rgba(255, 215, 0, 0.15)' : 'rgba(255, 0, 255, 0.15)';
      ctx.fillRect(startX, topY, lastX - startX, bottomY - topY);
      ctx.strokeStyle = fvg.type === 'bullish' ? '#ffd700' : '#ff00ff';
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 4]);
      ctx.beginPath();
      ctx.moveTo(startX, topY);
      ctx.lineTo(lastX, topY);
      ctx.moveTo(startX, bottomY);
      ctx.lineTo(lastX, bottomY);
      ctx.stroke();
      ctx.setLineDash([]);
    });
  }

  if (activeFeatures.liquidity) {
    const liqZones = detectLiquidityZones(data);
    liqZones.forEach(liq => {
      if (liq.isSwept || liq.index < startIndex || liq.index > startIndex + visibleCandleCount + 50) return;
      const y = priceToY(liq.price);
      const startX = Math.max(40, indexToX(liq.index - 10));
      const endX = indexToX(data.length - 1) + (5 * candleSpacing);
      ctx.strokeStyle = liq.type === 'buy_side' ? '#00ffff' : '#ff6600';
      ctx.lineWidth = Math.min(liq.strength, 4);
      ctx.setLineDash([10, 5]);
      ctx.beginPath();
      ctx.moveTo(startX, y);
      ctx.lineTo(endX, y);
      ctx.stroke();
      ctx.setLineDash([]);
      for (let i = 0; i < liq.strength; i++) {
        ctx.fillStyle = liq.type === 'buy_side' ? '#00ffff' : '#ff6600';
        ctx.beginPath();
        ctx.arc(startX + (i * 15), y, 4, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.font = 'bold 12px monospace';
      ctx.fillStyle = liq.type === 'buy_side' ? '#00ffff' : '#ff6600';
      ctx.fillText(liq.type === 'buy_side' ? 'ðŸ”¼ BSL' : 'ðŸ”½ SSL', startX + (liq.strength * 15) + 5, y - 5);
    });
  }

  if (activeFeatures.structure) {
    const structures = detectMarketStructure(data);
    const breaks = detectBreakOfStructure(data, structures);
    breaks.forEach(brk => {
      if (brk.index < startIndex || brk.index > startIndex + visibleCandleCount) return;
      const x = indexToX(brk.index);
      const y = priceToY(brk.price);

      // Determine label based on type and direction
      let label = '';
      if (brk.type === 'bos' && brk.direction === 'bullish') label = 'Up';
      else if (brk.type === 'bos' && brk.direction === 'bearish') label = 'Down';
      else if (brk.type === 'choch' && brk.direction === 'bullish') label = 'Building';
      else if (brk.type === 'choch' && brk.direction === 'bearish') label = 'Failing';

      // Set full opacity for text
      ctx.globalAlpha = 1.0;
      ctx.font = 'bold 14px monospace';
      const textMetrics = ctx.measureText(label);
      const textWidth = textMetrics.width;
      const textHeight = 16;

      // Draw semi-transparent background box
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(x - textWidth / 2 - 3, y - 25, textWidth + 6, textHeight + 4);

      // Draw text at full opacity
      ctx.fillStyle = brk.direction === 'bullish' ? '#00ff00' : '#ff0000';
      ctx.fillText(label, x - textWidth / 2, y - 10);
      ctx.beginPath();
      if (brk.direction === 'bullish') {
        ctx.moveTo(x, y);
        ctx.lineTo(x - 5, y + 10);
        ctx.lineTo(x + 5, y + 10);
      } else {
        ctx.moveTo(x, y);
        ctx.lineTo(x - 5, y - 10);
        ctx.lineTo(x + 5, y - 10);
      }
      ctx.closePath();
      ctx.fill();
    });
  }

  if (activeFeatures.premiumDiscount) {
    const pdZones = calculatePremiumDiscountZones(data, Math.max(0, data.length - 50), data.length - 1);
    pdZones.forEach(zone => {
      const y = priceToY(zone.priceLevel);
      const startX = 40;
      const endX = indexToX(data.length - 1) + (5 * candleSpacing);
      let color = '#888888';
      if (zone.type === 'premium') color = '#ff4444';
      if (zone.type === 'discount') color = '#44ff44';
      if (zone.type === 'equilibrium') color = '#ffff00';
      ctx.strokeStyle = color;
      ctx.lineWidth = zone.confidence >= 9 ? 2 : 1;
      ctx.setLineDash(zone.confidence >= 9 ? [] : [5, 5]);
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.moveTo(startX, y);
      ctx.lineTo(endX, y);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.setLineDash([]);
      ctx.font = '11px monospace';
      ctx.fillStyle = color;
      ctx.fillText(zone.setupType, endX + 5, y + 4);
    });
  }
};

interface TradingViewChartProps {
  symbol: string;
  initialTimeframe?: string;
  height?: number;
  onSymbolChange?: (symbol: string) => void;
  onTimeframeChange?: (timeframe: string) => void;
}

// Flow Panel Component - Extracted outside to prevent re-renders on mouse move
const FlowPanel = React.memo(({
  flowData,
  flowSummary,
  flowMarketInfo,
  flowLoading,
  flowSelectedTicker,
  flowStreamingStatus,
  flowStreamingProgress,
  flowStreamError,
  setFlowData,
  setFlowSummary,
  setFlowMarketInfo,
  setFlowLoading,
  setFlowSelectedTicker,
  setFlowStreamingStatus,
  setFlowStreamingProgress,
  setFlowStreamError,
  setActiveSidebarPanel
}: {
  flowData: any[];
  flowSummary: any;
  flowMarketInfo: any;
  flowLoading: boolean;
  flowSelectedTicker: string;
  flowStreamingStatus: string;
  flowStreamingProgress: any;
  flowStreamError: string;
  setFlowData: (data: any[]) => void;
  setFlowSummary: (summary: any) => void;
  setFlowMarketInfo: (info: any) => void;
  setFlowLoading: (loading: boolean) => void;
  setFlowSelectedTicker: (ticker: string) => void;
  setFlowStreamingStatus: (status: string) => void;
  setFlowStreamingProgress: (progress: any) => void;
  setFlowStreamError: (error: string) => void;
  setActiveSidebarPanel: (panel: string | null) => void;
}) => {
  const [retryCount, setRetryCount] = useState<number>(0);
  const [isStreamComplete, setIsStreamComplete] = useState<boolean>(false);
  const isStreamCompleteRef = useRef<boolean>(false);

  const fetchOptionsFlowStreaming = async (currentRetry: number = 0, tickerOverride?: string) => {
    setFlowLoading(true);
    setFlowStreamError('');

    try {
      let tickerParam = tickerOverride || flowSelectedTicker;

      if (!tickerParam || tickerParam.trim() === '') {
        tickerParam = 'ALL';
      }

      if (tickerParam === 'MAG7') {
        tickerParam = 'AAPL,NVDA,MSFT,TSLA,AMZN,META,GOOGL,GOOG';
      } else if (tickerParam === 'ETF') {
        tickerParam = 'SPY,QQQ,DIA,IWM,XLK,SMH,XLE,XLF,XLV,XLI,XLP,XLU,XLY,XLB,XLRE,XLC,GLD,SLV,TLT,HYG,LQD,EEM,EFA,VXX,UVXY';
      } else if (tickerParam === 'ALL') {
        tickerParam = 'ALL_EXCLUDE_ETF_MAG7';
      }

      const eventSource = new EventSource(`/api/stream-options-flow?ticker=${tickerParam}`);

      eventSource.onmessage = (event) => {
        try {
          const streamData = JSON.parse(event.data);

          switch (streamData.type) {
            case 'connected':
              setFlowStreamingStatus('Connected - scanning options flow...');
              setFlowStreamError('');
              break;

            case 'status':
              setFlowStreamingStatus(streamData.message);
              break;

            case 'trades':
              setFlowStreamingStatus(streamData.status);
              if (streamData.progress) {
                setFlowStreamingProgress({
                  current: streamData.progress.current,
                  total: streamData.progress.total
                });
              }
              break;

            case 'complete':
              isStreamCompleteRef.current = true;
              setIsStreamComplete(true);
              eventSource.close();

              const completeTrades = streamData.trades || [];

              setFlowSummary(streamData.summary);
              if (streamData.market_info) {
                setFlowMarketInfo(streamData.market_info);
              }
              setFlowLoading(false);
              setFlowStreamingProgress(null);
              setFlowStreamError('');
              setRetryCount(0);
              setFlowStreamingStatus('');

              setFlowData(completeTrades);

              break;

            case 'error':
              setFlowStreamError(streamData.error || 'Stream error occurred');
              setFlowLoading(false);
              eventSource.close();
              break;

            case 'close':
              isStreamCompleteRef.current = true;
              setIsStreamComplete(true);
              eventSource.close();
              break;

            case 'heartbeat':
              break;
          }
        } catch (parseError) {
          console.error('Error parsing stream data:', parseError);
        }
      };

      eventSource.onerror = (error) => {
        if (isStreamCompleteRef.current) {
          eventSource.close();
          return;
        }

        if (eventSource.readyState === 2) {
          eventSource.close();
          setFlowStreamingStatus('');
          setFlowLoading(false);
          return;
        }

        if (eventSource.readyState === 0) {
          const errorMsg = 'Failed to connect to options flow stream.';
          setFlowStreamError(errorMsg);
          setFlowStreamingStatus('');
        } else {
          setFlowStreamError('Connection interrupted');
          setFlowStreamingStatus('Connection error - retrying...');
        }

        eventSource.close();

        if (currentRetry < 3) {
          const nextRetry = currentRetry + 1;
          const backoffDelay = Math.min(2000 * Math.pow(1.5, currentRetry), 10000);

          setRetryCount(nextRetry);

          setTimeout(() => {
            fetchOptionsFlowStreaming(nextRetry);
          }, backoffDelay);
        } else {
          setFlowStreamError('Unable to establish streaming connection.');
          setFlowStreamingStatus('');
          setFlowLoading(false);
        }
      };

    } catch (error) {
      console.error('Error starting stream:', error);
      setFlowLoading(false);
    }
  };

  const handleRefresh = useCallback((tickerOverride?: string) => {
    setFlowStreamError('');
    setRetryCount(0);
    setIsStreamComplete(false);
    isStreamCompleteRef.current = false;
    fetchOptionsFlowStreaming(0, tickerOverride);
  }, [flowSelectedTicker]);

  const handleClearData = useCallback(() => {
    setFlowData([]);
    setFlowSummary({
      total_trades: 0,
      total_premium: 0,
      unique_symbols: 0,
      trade_types: { BLOCK: 0, SWEEP: 0, MINI: 0, 'MULTI-LEG': 0 },
      call_put_ratio: { calls: 0, puts: 0 },
      processing_time_ms: 0
    });
  }, [setFlowData, setFlowSummary]);

  return (
    <div className="h-full flex flex-col bg-black text-white">
      {/* Bloomberg-style Header */}
      <div className="p-3 border-b border-yellow-500 bg-black relative">
        {/* Close button - mobile and desktop */}
        <button
          onClick={() => setActiveSidebarPanel(null)}
          className="absolute top-3 right-3 text-gray-400 hover:text-white transition-colors z-50"
          aria-label="Close panel"
        >
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
        {/* Tab Navigation */}
        <div className="flex border-2 border-yellow-500/30 rounded-md overflow-hidden shadow-lg">
          <button
            style={{
              flex: 1,
              padding: '12px 24px',
              fontSize: '20px',
              fontWeight: '900',
              fontFamily: 'monospace',
              letterSpacing: '1px',
              textTransform: 'uppercase',
              border: 'none',
              cursor: 'default',
              transition: 'all 0.3s',
              background: 'linear-gradient(135deg, #1a1a1a 0%, #000000 50%, #1a1a1a 100%)',
              color: '#ff8844',
              boxShadow: 'inset 0 2px 4px rgba(255, 255, 255, 0.1), inset 0 -2px 4px rgba(0, 0, 0, 0.5)',
              opacity: 1,
              filter: 'contrast(1.1) brightness(1.1)'
            }}
          >
            Options Flow
          </button>
        </div>
      </div>

      <div className="p-6 flex-1 overflow-auto">
        <OptionsFlowTable
          data={flowData}
          summary={flowSummary}
          marketInfo={flowMarketInfo}
          loading={flowLoading}
          onRefresh={handleRefresh}
          onClearData={handleClearData}
          selectedTicker={flowSelectedTicker}
          onTickerChange={setFlowSelectedTicker}
          streamingStatus={flowStreamingStatus}
          streamingProgress={flowStreamingProgress}
          streamError={flowStreamError}
          useDropdowns={true}
        />
      </div>
    </div>
  );
});

FlowPanel.displayName = 'FlowPanel';

export default function TradingViewChart({
  symbol,
  initialTimeframe = '1d',
  height = 600,
  onSymbolChange,
  onTimeframeChange
}: TradingViewChartProps) {
  const { setRegimes, setRegimeAnalysis: setContextRegimeAnalysis } = useMarketRegime();

  // Canvas refs
  const containerRef = useRef<HTMLDivElement>(null);
  const chartCanvasRef = useRef<HTMLCanvasElement>(null);
  const overlayCanvasRef = useRef<HTMLCanvasElement>(null);

  // Dropdown button refs for positioning
  const technalysisButtonRef = useRef<HTMLButtonElement>(null);
  const expectedRangeButtonRef = useRef<HTMLButtonElement>(null);
  const gexButtonRef = useRef<HTMLButtonElement>(null);
  const rrgButtonRef = useRef<HTMLButtonElement>(null); // Chart state
  const flowMovesButtonRef = useRef<HTMLButtonElement>(null);
  const [config, setConfig] = useState<ChartConfig>({
    symbol,
    timeframe: initialTimeframe,
    chartType: 'candlestick',
    theme: 'dark',
    drawings: [],
    crosshair: true,
    timezone: 'UTC',
    showGrid: false, // Start with grid disabled
    axisStyle: {
      xAxis: {
        textSize: 20,
        textColor: '#ffffff'
      },
      yAxis: {
        textSize: 20,
        textColor: '#ffffff'
      }
    },
    colors: {
      bullish: {
        body: '#00ff00', // Pure green for bullish body
        wick: '#00ff00', // Pure green for bullish wick 
        border: '#00ff00' // Pure green for bullish border
      },
      bearish: {
        body: '#ff0000', // Pure red for bearish body
        wick: '#ff0000', // Pure red for bearish wick
        border: '#ff0000' // Pure red for bearish border
      },
      volume: {
        bullish: '#00bfff', // Bright blue for bullish volume
        bearish: '#ff0000' // Bright red for bearish volume
      }
    }
  });

  // Settings panel state
  const [showSettings, setShowSettings] = useState(false);

  // Chat store for Guide AI panel
  const { isOpen: isGuideAIOpen, setIsOpen: setGuideAIOpen } = useChatStore();

  // Dropdown positioning state
  const [dropdownPositions, setDropdownPositions] = useState({
    indicators: { x: 0, y: 0, width: 0 }
  });

  // Search state
  const [searchQuery, setSearchQuery] = useState('');
  const [showSearchResults, setShowSearchResults] = useState(false);

  // Benchmark mode state
  const [isBenchmarkMode, setIsBenchmarkMode] = useState(false);
  const [benchmarkSymbol1, setBenchmarkSymbol1] = useState('');
  const [benchmarkSymbol2, setBenchmarkSymbol2] = useState('');

  // Tracking tab state
  const [trackingData, setTrackingData] = useState<{
    [symbol: string]: {
      symbol: string;
      price: number;
      change: number;
      sparklineData: Array<{ time: number; price: number }>;
      previousDayClose?: number;
    };
  }>({});
  const [trackingLoading, setTrackingLoading] = useState(false);
  const trackingFetchedRef = useRef(false);
  const trackingScrollRef = useRef<HTMLDivElement>(null);
  const [trackingTimeframe, setTrackingTimeframe] = useState<'1D' | '5D' | '1M' | '3M' | '6M' | '1Y'>('1D');

  // Memoize tracking categories to prevent remounting on every render
  const trackingCategories = useMemo(() => [
    { title: 'Markets', symbols: ['SPY', 'QQQ', 'IWM', 'DIA', 'GLD', 'TLT'], color: '#1a4d8f' },
    { title: 'Large Caps', symbols: ['NVDA', 'TSM', 'AVGO', 'AAPL', 'MSFT', 'AMZN', 'GOOGL', 'META', 'TSLA'], color: '#0f3d66' },
    { title: 'Value', symbols: ['JPM', 'BA', 'FCX', 'XOM', 'NKE', 'FDX', 'CAT', 'BAC', 'MS', 'DAL', 'UNH', 'LMT', 'MCD', 'WMT', 'DHI', 'HD', 'PANW', 'NFLX'], color: '#1a5f4a' },
    { title: 'High Beta', symbols: ['OKLO', 'CRWV', 'IONQ', 'QUBT', 'IREN', 'NBIS', 'HOOD', 'PLTR', 'HIMS', 'UPST', 'AFRM', 'TEM', 'CRCL', 'MSTR', 'COIN', 'XYZ', 'ARM', 'SHOP', 'DASH', 'UBER', 'ABNB', 'AMD', 'ROKU', 'RBLX'], color: '#661a4d' },
    { title: 'China', symbols: ['PDD', 'FXI', 'JD', 'FUTU', 'BILI', 'BABA', 'NTES', 'KWEB', 'BIDU'], color: '#8f1a1a' },
    { title: '11 Sectors', symbols: ['XLK', 'XLY', 'XLC', 'XLE', 'XLI', 'XLB', 'XLF', 'XLU', 'XLP', 'XLRE', 'XLV'], color: '#4d4d1a' },
    { title: 'Industries', symbols: ['OIH', 'XME', 'GDX', 'JETS', 'PBW', 'KRE', 'KIE', 'FDN', 'IGV', 'XRT', 'SMH', 'ITB', 'XHB', 'IBB', 'XBI', 'TAN', 'XOP', 'ARKK'], color: '#1a4d4d' }
  ], []);

  // Options Trades state
  const [optionsPremiumData, setOptionsPremiumData] = useState<Record<string, { price: number; timestamp: number }[]>>({});
  const [stockChartData, setStockChartData] = useState<Record<string, { price: number; timestamp: number }[]>>({});
  const [liveOptionQuotes, setLiveOptionQuotes] = useState<Record<string, { bid: number; ask: number; last: number; delta?: number; gamma?: number; theta?: number; vega?: number; implied_volatility?: number }>>({});
  const [stockATR, setStockATR] = useState<Record<string, number>>({});
  const [optionPeakPrices, setOptionPeakPrices] = useState<Record<string, number>>({});
  const optionsDataFetchedRef = useRef(false);
  const [optionChartsVisible, setOptionChartsVisible] = useState<Record<string, boolean>>({});
  const [optionsWatchlistUpdate, setOptionsWatchlistUpdate] = useState(0);

  // Lock state for drawing tools - when locked, tools stay active after placing a drawing
  const [isDrawingLocked, setIsDrawingLocked] = useState<boolean>(false);

  // Lightweight Charts drawing tools state
  const [isLWChartDrawingActive, setIsLWChartDrawingActive] = useState<boolean>(false);
  const [lwChartDrawings, setLwChartDrawings] = useState<any[]>(() => {
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem('lwChartDrawings');
      return saved ? JSON.parse(saved) : [];
    }
    return [];
  });
  const [currentDrawingTool, setCurrentDrawingTool] = useState<'select' | 'trendline' | 'horizontal' | 'vertical' | 'ray' | 'rectangle' | 'text' | 'parallelChannel' | 'buyZone' | 'sellZone' | 'priceRange' | 'brush'>('select');
  const [isDrawingToolLocked, setIsDrawingToolLocked] = useState(false);

  // Undo/Redo history state
  const [drawingHistory, setDrawingHistory] = useState<any[][]>([[]]);
  const [historyIndex, setHistoryIndex] = useState(0);
  const [isBackgroundVisible, setIsBackgroundVisible] = useState(true);

  // Enhanced Market Regime Analysis state
  const [regimeAnalysis, setRegimeAnalysis] = useState<Record<string, RegimeAnalysis>>({});
  const [regimeHistory, setRegimeHistory] = useState<Record<string, Array<{ timestamp: number; analysis: RegimeAnalysis }>>>({});

  // Save drawings to localStorage whenever they change
  useEffect(() => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('lwChartDrawings', JSON.stringify(lwChartDrawings));
    }
  }, [lwChartDrawings]);

  // Function to update drawings with history tracking
  const updateDrawingsWithHistory = (newDrawings: any[]) => {
    // Remove any future history if we're not at the end
    const newHistory = drawingHistory.slice(0, historyIndex + 1);
    // Add the new state
    newHistory.push(newDrawings);
    // Limit history to last 50 states to prevent memory issues
    if (newHistory.length > 50) {
      newHistory.shift();
    } else {
      setHistoryIndex(historyIndex + 1);
    }
    setDrawingHistory(newHistory);
    setLwChartDrawings(newDrawings);
  };

  const [isTechnalysisDropdownOpen, setIsTechnalysisDropdownOpen] = useState<boolean>(false);

  // Parallel Channel Dragging State
  const [selectedChannel, setSelectedChannel] = useState<string | null>(null);
  const [isEditingChannel, setIsEditingChannel] = useState<boolean>(false);
  const [channelDragStart, setChannelDragStart] = useState<{ x: number, y: number, originalChannel: ParallelChannel } | null>(null);

  // Pinch-to-zoom state for mobile
  const [lastTouchDistance, setLastTouchDistance] = useState<number | null>(null);

  // ========================================
  // MULTICHART STATE & MANAGEMENT
  // ========================================

  interface ChartInstance {
    id: string;
    symbol: string;
    timeframe: string;
    config: ChartConfig;
  }

  type ChartLayout = '1x1' | '1x2' | '2x2';

  const [chartLayout, setChartLayout] = useState<ChartLayout>('1x1');
  const [chartInstances, setChartInstances] = useState<ChartInstance[]>([
    { id: 'chart-1', symbol, timeframe: initialTimeframe, config }
  ]);
  const [activeChartId, setActiveChartId] = useState<string>('chart-1');

  // Per-chart data storage
  const chartCanvasRefs = useRef<Map<string, HTMLCanvasElement>>(new Map());
  const overlayCanvasRefs = useRef<Map<string, HTMLCanvasElement>>(new Map());
  const chartDataMap = useRef<Map<string, ChartDataPoint[]>>(new Map());
  const chartScrollMap = useRef<Map<string, number>>(new Map());
  const chartZoomMap = useRef<Map<string, number>>(new Map());
  const chartPriceRangeMap = useRef<Map<string, { min: number; max: number } | null>>(new Map());
  const chartCrosshairMap = useRef<Map<string, { x: number; y: number }>>(new Map());
  const chartLoadingMap = useRef<Map<string, boolean>>(new Map());
  const chartPriceMap = useRef<Map<string, number>>(new Map());
  const chartVelocityMap = useRef<Map<string, { x: number; y: number }>>(new Map());
  const chartDragStateMap = useRef<Map<string, boolean>>(new Map());

  // Layout change handler
  const changeChartLayout = useCallback((newLayout: ChartLayout) => {
    setChartLayout(newLayout);

    const layouts = { '1x1': 1, '1x2': 2, '2x2': 4 };
    const numCharts = layouts[newLayout];
    const newInstances: ChartInstance[] = [];

    for (let i = 0; i < numCharts; i++) {
      const existingInstance = chartInstances[i];
      if (existingInstance) {
        newInstances.push(existingInstance);
      } else {
        newInstances.push({
          id: `chart-${i + 1}`,
          symbol: symbol,
          timeframe: config.timeframe,
          config: { ...config }
        });
      }
    }

    setChartInstances(newInstances);
    if (!newInstances.find(ci => ci.id === activeChartId)) {
      setActiveChartId(newInstances[0].id);
    }
  }, [chartInstances, symbol, config, activeChartId]);

  // GEX OI Handler - Uses Polygon snapshot data (old way)
  const handleOIGEXClick = async () => {
    if (isGexLoading) return;

    const newActiveState = !isGexActive;

    // If deactivating, just toggle off
    if (!newActiveState) {
      setIsGexActive(false);
      setLiveGexData(null);
      console.log('ðŸ”´ OI GEX deactivated');
      return;
    }

    // Activate OI GEX - clear any live data and use hook data
    setLiveGexData(null); // CRITICAL: Clear live data so gexData from hook is used
    setIsGexActive(true);
    console.log('ðŸŸ¢ OI GEX activated - using Polygon snapshot data from useGEXData hook');
  };

  // GEX Live OI Scan Handler - EXACT copy of DealerAttraction updateLiveOI logic
  const handleLiveGEXClick = async () => {
    if (isGexLoading) return;

    const newActiveState = !isGexActive;

    // If deactivating, just toggle off
    if (!newActiveState) {
      setIsGexActive(false);
      setLiveGexData(null);
      console.log('ðŸ”´ Live GEX deactivated');
      return;
    }

    // Activate and scan for live OI - EXACT DealerAttraction logic
    console.log('ðŸš€ Starting Live GEX scan for', symbol);
    setIsGexLoading(true);
    setGexProgress(0);

    const eventSource = new EventSource(`/api/stream-options-flow?ticker=${symbol}`);
    let allTrades: any[] = [];

    eventSource.onmessage = async (event) => {
      try {
        const data = JSON.parse(event.data);

        if (data.type === 'complete' && data.trades?.length > 0) {
          console.log(`ðŸ“Š Received ${data.trades.length} trades`);
          allTrades = data.trades;
          eventSource.close();
          setGexProgress(20); // 20% - trades received

          // Step 1: Fetch volume and OI data for all trades using Polygon API
          const uniqueExpirations = [...new Set(allTrades.map(t => t.expiry))];
          console.log(`ðŸ“… Fetching data for ${uniqueExpirations.length} expirations`);

          const allContracts = new Map();

          // Fetch data for each expiration
          for (let i = 0; i < uniqueExpirations.length; i++) {
            const expiry = uniqueExpirations[i];
            const expiryParam = expiry.includes('T') ? expiry.split('T')[0] : expiry;

            try {
              const response = await fetch(
                `https://api.polygon.io/v3/snapshot/options/${symbol}?expiration_date=${expiryParam}&limit=250&apiKey=qyKP_vdrxtME8uAj0gufQA8sTOdcoaSl`
              );

              if (response.ok) {
                const chainData = await response.json();
                if (chainData.results) {
                  chainData.results.forEach((contract: any) => {
                    if (contract.details && contract.details.ticker) {
                      allContracts.set(contract.details.ticker, {
                        volume: contract.day?.volume || 0,
                        open_interest: contract.open_interest || 0
                      });
                    }
                  });
                  console.log(`  âœ… Found ${chainData.results.length} contracts for ${expiryParam}`);
                }
              }

              // Update progress: 20% to 60% during contract fetching
              setGexProgress(20 + Math.round((i + 1) / uniqueExpirations.length * 40));
            } catch (error) {
              console.error(`  âŒ Error fetching ${expiryParam}:`, error);
            }
          }

          console.log(`ðŸ“Š Total contracts fetched: ${allContracts.size}`);
          setGexProgress(60); // 60% - contracts fetched

          // Step 2: Enrich trades with volume/OI
          const enrichedTrades = allTrades.map(trade => {
            const contractData = allContracts.get(trade.ticker);
            return {
              ...trade,
              volume: contractData?.volume || 0,
              open_interest: contractData?.open_interest || 0,
              underlying_ticker: trade.underlying_ticker || symbol
            };
          });
          setGexProgress(70); // 70% - trades enriched

          // Step 3: Detect fill styles (EXACT AlgoFlow logic)
          const tradesWithFillStyle = enrichedTrades.map(trade => {
            const volume = trade.volume || 0;
            const tradeSize = trade.trade_size || 0;
            const oi = trade.open_interest || 0;

            // Fill style logic from AlgoFlow
            let fillStyle = 'N/A';

            if (tradeSize > oi * 0.5) {
              fillStyle = 'AA'; // Aggressive opening
            } else if (tradeSize > volume * 0.3) {
              fillStyle = 'A'; // Opening
            } else if (tradeSize > oi * 0.1) {
              fillStyle = 'BB'; // Block opening
            } else {
              fillStyle = 'B'; // Likely closing
            }

            return {
              ...trade,
              fill_style: fillStyle
            };
          });

          console.log(`âœ… Enriched ${tradesWithFillStyle.length} trades with volume/OI and fill_style`);
          setGexProgress(80); // 80% - fill styles calculated

          // Step 4: Calculate Live OI for each unique contract - EXACT DealerAttraction logic
          const liveOIMap = new Map<string, number>();
          const uniqueContracts = new Set<string>();

          tradesWithFillStyle.forEach(trade => {
            const contractKey = `${trade.underlying_ticker}_${trade.strike}_${trade.type}_${trade.expiry}`;
            uniqueContracts.add(contractKey);
          });

          uniqueContracts.forEach(contractKey => {
            const matchingTrade = tradesWithFillStyle.find(t =>
              `${t.underlying_ticker}_${t.strike}_${t.type}_${t.expiry}` === contractKey
            );

            const originalOI = matchingTrade?.open_interest || 0;

            // Calculate Live OI using the trades
            const contractTrades = tradesWithFillStyle.filter(t =>
              `${t.underlying_ticker}_${t.strike}_${t.type}_${t.expiry}` === contractKey
            );

            let liveOI = originalOI;
            const processedTradeIds = new Set<string>();

            // Sort trades chronologically
            const sortedTrades = [...contractTrades].sort((a, b) =>
              new Date(a.trade_timestamp).getTime() - new Date(b.trade_timestamp).getTime()
            );

            sortedTrades.forEach(trade => {
              const tradeId = `${trade.underlying_ticker}_${trade.strike}_${trade.type}_${trade.expiry}_${trade.trade_timestamp}_${trade.trade_size}`;

              if (processedTradeIds.has(tradeId)) return;
              processedTradeIds.add(tradeId);

              const contracts = trade.trade_size || 0;
              const fillStyle = trade.fill_style;

              switch (fillStyle) {
                case 'A':
                case 'AA':
                case 'BB':
                  liveOI += contracts;
                  break;
                case 'B':
                  if (contracts > originalOI) {
                    liveOI += contracts;
                  } else {
                    liveOI -= contracts;
                  }
                  break;
              }
            });

            liveOI = Math.max(0, liveOI);
            liveOIMap.set(contractKey, liveOI);

            console.log(`ðŸ“Š ${contractKey}: OI ${originalOI} â†’ Live OI ${liveOI}`);
          });

          console.log(`âœ… Live OI calculation complete: ${liveOIMap.size} contracts`);
          setGexProgress(90);

          // Step 5: Send to GEX API
          const liveOIArray = Array.from(liveOIMap.entries()).map(([key, oi]) => {
            const parts = key.split('_');
            return {
              ticker: parts[0],
              strike: parseFloat(parts[1]),
              type: parts[2] === 'call' ? 'C' : 'P', // Convert "call"/"put" to "C"/"P" for API
              expiry: parts.slice(3).join('_'),
              liveOI: oi
            };
          });

          console.log(`ðŸ“¤ Sending ${liveOIArray.length} live OI entries to GEX API`);

          const response = await fetch('/api/gex', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              symbol,
              liveOI: liveOIArray
            })
          });

          const gexResult = await response.json();

          if (gexResult.success) {
            console.log('ðŸ”¥ SETTING liveGexData with:', {
              totalCallGEX: gexResult.gexData.totalCallGEX,
              totalPutGEX: gexResult.gexData.totalPutGEX,
              callWalls: gexResult.gexData.callWalls?.length,
              putWalls: gexResult.gexData.putWalls?.length
            });

            setLiveGexData(gexResult);
            setIsGexActive(true);
            setGexProgress(100);
            console.log('âœ… GEX calculation complete with live OI');
            console.log(`ðŸ“Š Total Call GEX: ${gexResult.gexData.totalCallGEX.toFixed(0)}`);
            console.log(`ðŸ“Š Total Put GEX: ${gexResult.gexData.totalPutGEX.toFixed(0)}`);
            console.log(`ðŸ“Š GEX Flip Level: $${gexResult.gexData.gexFlipLevel.toFixed(2)}`);

            // Trigger re-render
            setTimeout(() => renderChart(), 100);

            // Hide loading after brief delay
            setTimeout(() => {
              setIsGexLoading(false);
            }, 500);
          } else {
            throw new Error(gexResult.error || 'GEX calculation failed');
          }
        }
      } catch (error) {
        console.error('âŒ Error in Live GEX scan:', error);
        setIsGexLoading(false);
        setIsGexActive(false);
        setGexProgress(0);
      }
    };

    eventSource.onerror = (error) => {
      console.error('âŒ EventSource error:', error);
      eventSource.close();
      setIsGexLoading(false);
      setGexProgress(0);
    };
  };

  // Live FlowMoves handler - Fetches and displays 4-line flow chart
  const handleLiveFlowMovesClick = async (timeframe: '1D' | '3D' | '1W' = '1D') => {
    console.log(`ðŸš€ Starting Live FlowMoves scan for ${symbol} - Timeframe: ${timeframe}`);

    try {
      const eventSource = new EventSource(`/api/stream-options-flow?ticker=${symbol}&timeframe=${timeframe}`);
      let allTrades: any[] = [];

      eventSource.onmessage = async (event) => {
        try {
          const data = JSON.parse(event.data);

          if (data.type === 'complete' && data.trades?.length > 0) {
            console.log(`ðŸ“Š FlowMoves: Received ${data.trades.length} trades`);
            allTrades = data.trades;
            eventSource.close();

            // US Market Holidays (2025-2026)
            const US_MARKET_HOLIDAYS = [
              '2025-01-01', '2025-01-20', '2025-02-17', '2025-04-18', '2025-05-26',
              '2025-07-04', '2025-09-01', '2025-11-27', '2025-12-25',
              '2026-01-01', '2026-01-19', '2026-02-16', '2026-04-03', '2026-05-25',
              '2026-07-03', '2026-09-07', '2026-11-26', '2026-12-25',
            ];

            // Get trading days based on timeframe
            const getTradingDays = (tf: '1D' | '3D' | '1W'): string[] => {
              const days: string[] = [];
              const now = new Date();
              const etNow = new Date(now.toLocaleString("en-US", { timeZone: "America/New_York" }));
              const daysNeeded = tf === '1D' ? 1 : tf === '3D' ? 3 : 5;
              let currentDate = new Date(etNow);
              currentDate.setDate(currentDate.getDate() - 1);

              while (days.length < daysNeeded) {
                const dayOfWeek = currentDate.getDay();
                const year = currentDate.getFullYear();
                const month = String(currentDate.getMonth() + 1).padStart(2, '0');
                const day = String(currentDate.getDate()).padStart(2, '0');
                const dateString = `${year}-${month}-${day}`;

                if (dayOfWeek !== 0 && dayOfWeek !== 6 && !US_MARKET_HOLIDAYS.includes(dateString)) {
                  days.push(dateString);
                }
                currentDate.setDate(currentDate.getDate() - 1);
              }
              return days.reverse();
            };

            const tradingDays = getTradingDays(timeframe);
            console.log(`ðŸ“… Trading days for ${timeframe}:`, tradingDays);

            // Initialize intervals based on timeframe
            const intervalData = new Map<string, { callsPlus: number; callsMinus: number; putsPlus: number; putsMinus: number }>();

            if (timeframe === '1D') {
              // Single day: 5-minute intervals
              const marketOpenMinutes = 9 * 60 + 30; // 9:30 AM
              const marketCloseMinutes = 16 * 60;    // 4:00 PM
              for (let totalMinutes = marketOpenMinutes; totalMinutes < marketCloseMinutes; totalMinutes += 5) {
                const hour = Math.floor(totalMinutes / 60);
                const minute = totalMinutes % 60;
                const timeKey = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                intervalData.set(timeKey, { callsPlus: 0, callsMinus: 0, putsPlus: 0, putsMinus: 0 });
              }
              intervalData.set('16:00', { callsPlus: 0, callsMinus: 0, putsPlus: 0, putsMinus: 0 });
            } else {
              // Multi-day: 5-minute intervals during market hours for each day
              const marketOpenMinutes = 9 * 60 + 30; // 9:30 AM
              const marketCloseMinutes = 16 * 60;    // 4:00 PM
              tradingDays.forEach(date => {
                for (let totalMinutes = marketOpenMinutes; totalMinutes <= marketCloseMinutes; totalMinutes += 5) {
                  const hour = Math.floor(totalMinutes / 60);
                  const minute = totalMinutes % 60;
                  const timeKey = `${date}_${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                  intervalData.set(timeKey, { callsPlus: 0, callsMinus: 0, putsPlus: 0, putsMinus: 0 });
                }
              });
            }

            console.log(`ðŸ“Š Created ${intervalData.size} intervals for ${timeframe}`);

            // Group trades by intervals
            allTrades.forEach(trade => {
              const tradeDate = new Date(trade.trade_timestamp);
              const etTime = new Date(tradeDate.toLocaleString("en-US", { timeZone: "America/New_York" }));
              const hour = etTime.getHours();
              const minute = etTime.getMinutes();
              const year = etTime.getFullYear();
              const month = String(etTime.getMonth() + 1).padStart(2, '0');
              const day = String(etTime.getDate()).padStart(2, '0');
              const dateKey = `${year}-${month}-${day}`;

              // Only include trades during market hours
              if (hour < 9 || hour > 16 || (hour === 9 && minute < 30)) return;

              let timeKey: string;
              if (timeframe === '1D') {
                // Single day: Round to 5-minute interval
                const totalMinutes = hour * 60 + minute;
                const minutesSinceOpen = totalMinutes - (9 * 60 + 30);
                const slotMinutes = Math.floor(minutesSinceOpen / 5) * 5;
                const slotHour = Math.floor((slotMinutes + 570) / 60);
                const slotMin = (slotMinutes + 570) % 60;
                timeKey = `${slotHour.toString().padStart(2, '0')}:${slotMin.toString().padStart(2, '0')}`;
              } else {
                // Multi-day: Round to 5-minute interval during market hours
                const totalMinutes = hour * 60 + minute;
                const minutesSinceOpen = totalMinutes - (9 * 60 + 30);
                const slotMinutes = Math.floor(minutesSinceOpen / 5) * 5;
                const slotHour = Math.floor((slotMinutes + 570) / 60);
                const slotMin = (slotMinutes + 570) % 60;
                timeKey = `${dateKey}_${slotHour.toString().padStart(2, '0')}:${slotMin.toString().padStart(2, '0')}`;
              }

              const interval = intervalData.get(timeKey);
              if (interval) {
                // Determine bullish/bearish based on fill_style
                const isBullish = trade.fill_style === 'A' || trade.fill_style === 'AA';

                if (trade.type === 'call') {
                  if (isBullish) {
                    interval.callsPlus += trade.total_premium;
                  } else {
                    interval.callsMinus += trade.total_premium;
                  }
                } else {
                  if (isBullish) {
                    interval.putsPlus += trade.total_premium;
                  } else {
                    interval.putsMinus += trade.total_premium;
                  }
                }
              }
            });

            // Convert to cumulative chart data
            const sortedIntervals = Array.from(intervalData.entries()).sort((a, b) => {
              // Sort chronologically
              if (timeframe === '1D') {
                return a[0].localeCompare(b[0]);
              } else {
                // For multi-day, sort by date then time
                const [dateA, timeA] = a[0].split('_');
                const [dateB, timeB] = b[0].split('_');
                return dateA === dateB ? timeA.localeCompare(timeB) : dateA.localeCompare(dateB);
              }
            });

            const chartData: Array<{
              time: number;
              timeLabel: string;
              callsPlus: number;
              callsMinus: number;
              putsPlus: number;
              putsMinus: number;
              bullishTotal: number;
              bearishTotal: number;
              netFlow: number;
            }> = [];

            let cumulative = { callsPlus: 0, callsMinus: 0, putsPlus: 0, putsMinus: 0 };

            sortedIntervals.forEach(([key, data]) => {
              cumulative.callsPlus += data.callsPlus;
              cumulative.callsMinus += data.callsMinus;
              cumulative.putsPlus += data.putsPlus;
              cumulative.putsMinus += data.putsMinus;

              // Parse timestamp from key - MUST BE IN ET TIMEZONE
              let timestamp: number;
              let displayLabel: string;

              if (timeframe === '1D') {
                const [hourStr, minStr] = key.split(':');
                const hour = parseInt(hourStr);
                const minute = parseInt(minStr);

                // Get yesterday's date in ET timezone
                const now = new Date();
                const etNow = new Date(now.toLocaleString("en-US", { timeZone: "America/New_York" }));
                const year = etNow.getFullYear();
                const month = String(etNow.getMonth() + 1).padStart(2, '0');
                const day = String(etNow.getDate() - 1).padStart(2, '0');

                // Create ET timestamp using ISO string with ET offset
                const etDateStr = `${year}-${month}-${day}T${hourStr.padStart(2, '0')}:${minStr.padStart(2, '0')}:00-05:00`;
                timestamp = new Date(etDateStr).getTime();

                const hour12 = hour % 12 === 0 ? 12 : hour % 12;
                const ampm = hour < 12 ? 'AM' : 'PM';
                displayLabel = `${hour12}:${minStr} ${ampm}`;
              } else {
                // Multi-day: Create timestamp for ET time
                const [date, time] = key.split('_');
                const [year, month, day] = date.split('-');
                const [hourStr, minStr] = time.split(':');

                const yearNum = parseInt(year);
                const monthNum = parseInt(month) - 1;
                const dayNum = parseInt(day);
                const hourNum = parseInt(hourStr);
                const minuteNum = parseInt(minStr);

                // ET is UTC-5 (EST), so 9:30 AM ET = 14:30 UTC
                // Create UTC timestamp by adding 5 hours to ET time
                timestamp = Date.UTC(yearNum, monthNum, dayNum, hourNum + 5, minuteNum, 0, 0);

                displayLabel = `${month}/${day} ${time}`;
              }

              const bullishTotal = cumulative.callsPlus + cumulative.putsPlus;
              const bearishTotal = -(cumulative.callsMinus + cumulative.putsMinus);
              const netFlow = (cumulative.callsPlus - cumulative.callsMinus) + (cumulative.putsPlus - cumulative.putsMinus);

              chartData.push({
                time: timestamp,
                timeLabel: displayLabel,
                callsPlus: cumulative.callsPlus,
                callsMinus: cumulative.callsMinus,
                putsPlus: cumulative.putsPlus,
                putsMinus: cumulative.putsMinus,
                bullishTotal,
                bearishTotal,
                netFlow
              });
            });

            console.log('âœ… FlowMoves data processed:', chartData.length, 'intervals');
            console.log('ðŸ” DEBUG: Sample chartData timestamps:');
            if (chartData.length > 0) {
              chartData.slice(0, 5).forEach(point => {
                const date = new Date(point.time);
                console.log(`  ${point.timeLabel} => timestamp: ${point.time} => ${date.toISOString()} => ET: ${date.toLocaleString('en-US', { timeZone: 'America/New_York' })}`);
              });
            }

            // ADD FLAT LINE DATA POINTS FOR AFTERHOURS (4:00 PM - Next Day 9:30 AM)
            if (timeframe !== '1D' && chartData.length > 0) {
              const finalChartData: typeof chartData = [];

              // Process each day's data and add afterhours flat lines
              for (let dayIndex = 0; dayIndex < tradingDays.length; dayIndex++) {
                const currentDate = tradingDays[dayIndex];
                const [year, month, day] = currentDate.split('-');

                // Find all market hours data points for this day (9:30 AM - 4:00 PM ET)
                // Create UTC timestamps: 9:30 AM ET = 14:30 UTC, 4:00 PM ET = 21:00 UTC
                const startOfDay = Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), 9 + 5, 30, 0, 0);
                const endOfDay = Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), 16 + 5, 0, 0, 0);

                const dayData = chartData.filter(point => point.time >= startOfDay && point.time <= endOfDay);

                // Add all market hours data for this day
                finalChartData.push(...dayData);

                // Get the 4:00 PM closing values
                const closingData = dayData.length > 0 ? dayData[dayData.length - 1] : null;

                // If there's a next trading day, add flat line from 4:00 PM to next 9:30 AM
                if (closingData && dayIndex < tradingDays.length - 1) {
                  const nextDate = tradingDays[dayIndex + 1];
                  const [nextYear, nextMonth, nextDay] = nextDate.split('-');

                  // Add flat line points from 4:05 PM to 11:55 PM (current day)
                  for (let hour = 16; hour < 24; hour++) {
                    const startMin = hour === 16 ? 5 : 0;
                    for (let min = startMin; min < 60; min += 5) {
                      // Create UTC timestamp (ET + 5 hours)
                      const timestamp = Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), hour + 5, min, 0, 0);
                      const hour12 = hour % 12 === 0 ? 12 : hour % 12;
                      const ampm = hour < 12 ? 'AM' : 'PM';
                      finalChartData.push({
                        time: timestamp,
                        timeLabel: `${month}/${day} ${hour12}:${min.toString().padStart(2, '0')} ${ampm}`,
                        callsPlus: closingData.callsPlus,
                        callsMinus: closingData.callsMinus,
                        putsPlus: closingData.putsPlus,
                        putsMinus: closingData.putsMinus,
                        bullishTotal: closingData.bullishTotal,
                        bearishTotal: closingData.bearishTotal,
                        netFlow: closingData.netFlow
                      });
                    }
                  }

                  // Add flat line points from 12:00 AM to 9:25 AM (next day)
                  for (let hour = 0; hour < 10; hour++) {
                    const endMin = hour === 9 ? 25 : 60;
                    for (let min = 0; min < endMin; min += 5) {
                      // Create UTC timestamp (ET + 5 hours)
                      const timestamp = Date.UTC(parseInt(nextYear), parseInt(nextMonth) - 1, parseInt(nextDay), hour + 5, min, 0, 0);
                      const hour12 = hour % 12 === 0 ? 12 : hour % 12;
                      const ampm = hour < 12 ? 'AM' : 'PM';
                      finalChartData.push({
                        time: timestamp,
                        timeLabel: `${nextMonth}/${nextDay} ${hour12}:${min.toString().padStart(2, '0')} ${ampm}`,
                        callsPlus: closingData.callsPlus,
                        callsMinus: closingData.callsMinus,
                        putsPlus: closingData.putsPlus,
                        putsMinus: closingData.putsMinus,
                        bullishTotal: closingData.bullishTotal,
                        bearishTotal: closingData.bearishTotal,
                        netFlow: closingData.netFlow
                      });
                    }
                  }
                }
              }

              // Sort by timestamp
              finalChartData.sort((a, b) => a.time - b.time);

              console.log('âœ… Added afterhours flat line points:', finalChartData.length, 'total points');
              console.log('ðŸ“Š First 10 points:', finalChartData.slice(0, 10).map(p => ({ time: new Date(p.time).toLocaleString(), label: p.timeLabel, netFlow: p.netFlow })));
              if (finalChartData.length > 0) {
                console.log('ðŸ“Š First flow point:', new Date(finalChartData[0].time).toISOString(), finalChartData[0].timeLabel);
                console.log('ðŸ“Š Last flow point:', new Date(finalChartData[finalChartData.length - 1].time).toISOString(), finalChartData[finalChartData.length - 1].timeLabel);
              }
              setFlowChartData(finalChartData);
            } else {
              console.log('ðŸ“Š Sample data points:', chartData.slice(0, 3));
              if (chartData.length > 0) {
                console.log('ðŸ“Š First flow point:', new Date(chartData[0].time).toISOString(), chartData[0].timeLabel);
                console.log('ðŸ“Š Last flow point:', new Date(chartData[chartData.length - 1].time).toISOString(), chartData[chartData.length - 1].timeLabel);
              }
              setFlowChartData(chartData);
            }
            setIsFlowChartActive(true);
          }
        } catch (error) {
          console.error('âŒ Error processing FlowMoves data:', error);
        }
      };

      eventSource.onerror = (error) => {
        console.error('âŒ FlowMoves EventSource error:', error);
        eventSource.close();
      };
    } catch (error) {
      console.error('âŒ Error starting FlowMoves scan:', error);
    }
  };

  // RRG Candle handler - Calculate RRG quadrant for each candle
  const handleRRGCandleClick = async (period: number = 31, mode: 'price' | 'iv' | 'ivspy' = 'price') => {
    const currentSymbol = symbol; // Capture current symbol to avoid stale closure
    console.log(`ðŸŽ¨ Starting RRG Candle coloring with ${period}-day lookback, ${mode} mode for ${currentSymbol}`);

    try {
      const colorMap = new Map<number, string>();

      if (mode === 'iv' || mode === 'ivspy') {
        // IV-BASED RRG LOGIC (two variants: self-comparison or SPY comparison)
        // To color full period, we need to fetch period + lookback days
        // Then start coloring from day [lookback] onwards

        // Determine lookback period based on selection
        let actualLookback: number;
        if (period === 30) actualLookback = 14;       // 1mo uses 14 days lookback
        else if (period === 120) actualLookback = 36; // 4mo uses 36 days lookback
        else if (period === 365) actualLookback = 90; // 1yr uses 90 days lookback
        else actualLookback = Math.floor(period / 3); // fallback

        // Fetch period + lookback to have enough data
        const daysToFetch = period + actualLookback;

        const response = await fetch(`/api/calculate-historical-iv?ticker=${currentSymbol}&days=${daysToFetch}`);

        if (!response.ok) {
          throw new Error(`Failed to fetch IV data: ${response.status}`);
        }

        const ivData = await response.json();

        if (!ivData.success || !ivData.data || !ivData.data.history) {
          console.warn('âš ï¸ No IV history data available for RRG Candle');
          return;
        }

        const history = ivData.data.history;

        let benchmarkHistory = null;

        // Only fetch SPY benchmark if using IV/SPY mode
        if (mode === 'ivspy') {
          const benchmarkResponse = await fetch(`/api/calculate-historical-iv?ticker=SPY&days=${daysToFetch}`);
          const benchmarkData = await benchmarkResponse.json();

          if (!benchmarkData.success || !benchmarkData.data.history) {
            console.warn('âš ï¸ No benchmark data available');
            return;
          }

          benchmarkHistory = benchmarkData.data.history;
        }

        let firstColoredTimestamp: number | null = null;

        // Calculate RS-Ratio and RS-Momentum for each data point
        // Start from actualLookback (already calculated above) to have lookback data
        for (let i = actualLookback; i < history.length; i++) {
          const currentIV = (history[i].callIV + history[i].putIV) / 2;
          const pastIV = (history[i - actualLookback].callIV + history[i - actualLookback].putIV) / 2;

          let rsRatio: number;
          let rsMomentum: number;

          if (mode === 'iv') {
            // IV MODE: Compare current IV to past IV (self-comparison, no SPY)
            // RS-Ratio = (current IV / past IV) Ã— 100
            rsRatio = (currentIV / pastIV) * 100;

            // RS-Momentum: Compare current RS-Ratio to midpoint RS-Ratio
            const midPoint = Math.floor(actualLookback / 2);
            const midIV = (history[i - midPoint].callIV + history[i - midPoint].putIV) / 2;
            const midRsRatio = (midIV / pastIV) * 100;
            rsMomentum = rsRatio - midRsRatio;

          } else {
            // IV/SPY MODE: Compare to SPY benchmark
            const benchmarkIV = (benchmarkHistory![i]?.callIV + benchmarkHistory![i]?.putIV) / 2 || 1;
            const benchmarkPastIV = (benchmarkHistory![i - actualLookback]?.callIV + benchmarkHistory![i - actualLookback]?.putIV) / 2 || 1;

            // RS-Ratio: (Current IV / Benchmark IV)
            rsRatio = (currentIV / benchmarkIV) * 100;

            // RS-Momentum: (RS now - RS past)
            const rsPast = (pastIV / benchmarkPastIV) * 100;
            rsMomentum = rsRatio - rsPast;
          }

          // Determine RRG quadrant with VIVID colors
          let color: string;
          if (rsRatio >= 100 && rsMomentum >= 0) {
            color = '#00ff00'; // Bright Green - Leading (outperforming & accelerating)
          } else if (rsRatio < 100 && rsMomentum >= 0) {
            color = '#0088ff'; // Bright Blue - Improving (underperforming but accelerating)
          } else if (rsRatio < 100 && rsMomentum < 0) {
            color = '#ff0000'; // Bright Red - Lagging (underperforming & decelerating)
          } else {
            color = '#ffff00'; // Bright Yellow - Weakening (outperforming but decelerating)
          }

          // Match candles by date (YYYY-MM-DD) instead of exact timestamp
          const dateStr = history[i].date; // "2025-01-30"
          const matchingCandles = data.filter(candle => {
            const candleDate = new Date(candle.timestamp).toISOString().split('T')[0];
            return candleDate === dateStr;
          });

          // Apply color to all candles on this date
          matchingCandles.forEach(candle => {
            colorMap.set(candle.timestamp, color);
            // Track first colored timestamp
            if (firstColoredTimestamp === null || candle.timestamp < firstColoredTimestamp) {
              firstColoredTimestamp = candle.timestamp;
            }
          });
        }

        console.log(`âœ… IV Mode: Total colors=${colorMap.size}, Sample timestamps -`, Array.from(colorMap.keys()).slice(0, 3));

        // Store the first colored timestamp for drawing the indicator line
        setRrgIvStartTimestamp(firstColoredTimestamp);
      } else {
        // PRICE-BASED RRG LOGIC (NORMAL RRG)
        // Use the existing chart data instead of fetching new data
        const symbolPrices = data;

        console.log(`ðŸ” PRICE MODE DEBUG: symbolPrices length=${symbolPrices?.length || 0}, period=${period}, symbol=${currentSymbol}, timeframe=${config.timeframe}`);

        if (!symbolPrices || symbolPrices.length < period) {
          console.warn(`âš ï¸ Not enough chart data for RRG calculation: have ${symbolPrices?.length || 0} candles, need ${period}`);
          return;
        }

        // Determine benchmark: SPY uses QQQ, everything else uses SPY
        const benchmarkSymbol = currentSymbol.toUpperCase() === 'SPY' ? 'QQQ' : 'SPY';

        // Get the date range from the symbol data
        const firstTimestamp = symbolPrices[0].timestamp;
        const lastTimestamp = symbolPrices[symbolPrices.length - 1].timestamp;
        const daysDiff = Math.ceil((lastTimestamp - firstTimestamp) / (1000 * 60 * 60 * 24));

        // Fetch benchmark data with same timeframe and extended date range
        const daysToFetch = Math.max(daysDiff + 30, period * 3, 100);
        const benchmarkResponse = await fetch(`/api/stock-data?symbol=${benchmarkSymbol}&lookbackDays=${daysToFetch}&timeframe=${config.timeframe}`);

        if (!benchmarkResponse.ok) {
          return;
        }

        const benchmarkData = await benchmarkResponse.json();

        // Handle different API response formats
        const benchmarkPrices = benchmarkData.results || benchmarkData.data;

        if (!benchmarkPrices || benchmarkPrices.length === 0) {
          return;
        }

        // Create a timestamp-indexed benchmark map for quick lookup
        const benchmarkMap = new Map<number, number>();
        benchmarkPrices.forEach((bar: any) => {
          const timestamp = bar.t || bar.timestamp;
          const closePrice = bar.c || bar.close;
          if (timestamp && closePrice) {
            benchmarkMap.set(timestamp, closePrice);
          }
        });

        // Calculate RS-Ratio and RS-Momentum for each candle
        for (let i = period; i < symbolPrices.length; i++) {
          const currentPrice = symbolPrices[i].close;
          const pastPrice = symbolPrices[i - period].close;
          const timestamp = symbolPrices[i].timestamp;

          // Find matching benchmark prices
          const benchmarkCurrent = benchmarkMap.get(timestamp);
          const benchmarkPast = benchmarkMap.get(symbolPrices[i - period].timestamp);

          if (!benchmarkCurrent || !benchmarkPast) {
            continue;
          }

          // Price performance
          const symbolPerf = (currentPrice / pastPrice - 1) * 100;
          const benchmarkPerf = (benchmarkCurrent / benchmarkPast - 1) * 100;

          // RS-Ratio: Symbol performance relative to benchmark
          const rsRatio = 100 + (symbolPerf - benchmarkPerf);

          // RS-Momentum: Rate of change of RS-Ratio
          const midPoint = Math.floor(period / 2);
          const midPrice = symbolPrices[i - midPoint].close;
          const midBenchmark = benchmarkMap.get(symbolPrices[i - midPoint].timestamp);

          if (!midBenchmark) {
            continue;
          }

          const midSymbolPerf = (midPrice / pastPrice - 1) * 100;
          const midBenchmarkPerf = (midBenchmark / benchmarkPast - 1) * 100;
          const midRsRatio = 100 + (midSymbolPerf - midBenchmarkPerf);

          const rsMomentum = rsRatio - midRsRatio;

          // Determine RRG quadrant with VIVID colors
          let color: string;
          if (rsRatio >= 100 && rsMomentum >= 0) {
            color = '#00ff00'; // Bright Green - Leading (outperforming & accelerating)
          } else if (rsRatio < 100 && rsMomentum >= 0) {
            color = '#0088ff'; // Bright Blue - Improving (underperforming but accelerating)
          } else if (rsRatio < 100 && rsMomentum < 0) {
            color = '#ff0000'; // Bright Red - Lagging (underperforming & decelerating)
          } else {
            color = '#ffff00'; // Bright Yellow - Weakening (outperforming but decelerating)
          }

          colorMap.set(timestamp, color);
        }
      }

      setRrgCandleColors(colorMap);
      setRrgLookbackPeriod(period as 10 | 31 | 87);
      setRrgMode(mode);
      setIsRRGCandleActive(true);

      // Clear IV start timestamp if not in IV mode
      if (mode !== 'iv' && mode !== 'ivspy') {
        setRrgIvStartTimestamp(null);
      }

    } catch (error) {
      console.error('âŒ Error calculating RRG Candle colors:', error);
    }
  };

  const [rayProperties, setRayProperties] = useState({
    color: '#FFD700',
    lineWidth: 2,
    lineStyle: 'solid' as const,
    extendLeft: true,
    extendRight: true,
    label: ''
  });

  // Parallel Channel Properties
  const [channelProperties, setChannelProperties] = useState({
    lineColor: '#00BFFF',
    lineWidth: 2,
    lineStyle: 'solid' as const,
    fillColor: '#00BFFF33', // Semi-transparent fill
    showFill: true,
    label: ''
  });

  // Tool management function to prevent multiple tools being active
  // Professional crosshair information state
  const [crosshairInfo, setCrosshairInfo] = useState<{
    price: string;
    date: string;
    time: string;
    visible: boolean;
    ohlc?: {
      open: number;
      high: number;
      low: number;
      close: number;
      change?: number;
      changePercent?: number;
      volume?: number;
    };
  }>({
    price: '',
    date: '',
    time: '',
    visible: false,
    ohlc: undefined
  });

  // Sidebar panel state
  const [activeSidebarPanel, setActiveSidebarPanel] = useState<string | null>(null);
  const [watchlistTab, setWatchlistTab] = useState('Watchlist');
  const [regimesTab, setRegimesTab] = useState('life');
  const [screenersTab, setScreenersTab] = useState('HV');
  const [rrgTab, setRrgTab] = useState('Price');
  const [calendarTab, setCalendarTab] = useState('Chart');
  const [optionsTradesTimeframes, setOptionsTradesTimeframes] = useState<Record<string, '1D' | '5D' | '1M'>>({});

  // Fetch specific option data when its timeframe changes
  const fetchOptionData = useCallback(async (option: any, timeframe: '1D' | '5D' | '1M') => {
    try {
      const expiry = option.expiration.split('-').join('').slice(2);
      const strikeFormatted = (option.strike * 1000).toString().padStart(8, '0');
      const optionType = option.type === 'call' ? 'C' : 'P';
      const optionTicker = `O:${option.symbol}${expiry}${optionType}${strikeFormatted}`;

      const today = new Date();
      const POLYGON_API_KEY = 'kjZ4aLJbqHsEhWGOjWMBthMvwDLKd4wf';

      let fromDate: Date;
      let toDate: Date = new Date(today);
      toDate.setDate(toDate.getDate() - 1); // Use yesterday as end date to ensure data availability
      let multiplier: number;
      let timespan: string;

      if (timeframe === '1D') {
        fromDate = new Date(toDate);
        fromDate.setDate(fromDate.getDate() - 1); // Get data from 2 days ago to yesterday
        multiplier = 5;
        timespan = 'minute';
      } else if (timeframe === '5D') {
        fromDate = new Date(toDate);
        fromDate.setDate(fromDate.getDate() - 7); // Get 7 days of data
        multiplier = 30;
        timespan = 'minute';
      } else {
        fromDate = new Date(toDate);
        fromDate.setDate(fromDate.getDate() - 30); // Get 30 days of data
        multiplier = 1;
        timespan = 'day';
      }

      const fromStr = `${fromDate.getFullYear()}-${String(fromDate.getMonth() + 1).padStart(2, '0')}-${String(fromDate.getDate()).padStart(2, '0')}`;
      const toStr = `${toDate.getFullYear()}-${String(toDate.getMonth() + 1).padStart(2, '0')}-${String(toDate.getDate()).padStart(2, '0')}`;

      // Fetch option premium data
      const optionUrl = `https://api.polygon.io/v2/aggs/ticker/${optionTicker}/range/${multiplier}/${timespan}/${fromStr}/${toStr}?adjusted=true&sort=asc&limit=50000&apiKey=${POLYGON_API_KEY}`;
      const optionResponse = await fetch(optionUrl);
      const optionData = await optionResponse.json();

      if (optionData.status === 'OK' && optionData.results && optionData.results.length > 0) {
        const chartData = optionData.results.map((bar: any) => ({
          price: bar.c,
          timestamp: bar.t
        }));
        setOptionsPremiumData(prev => ({ ...prev, [option.id]: chartData }));
      } else {
        console.warn(`No premium data for ${optionTicker}:`, optionData.status, optionData);
      }

      // Fetch underlying stock data
      const stockUrl = `https://api.polygon.io/v2/aggs/ticker/${option.symbol}/range/${multiplier}/${timespan}/${fromStr}/${toStr}?adjusted=true&sort=asc&limit=50000&apiKey=${POLYGON_API_KEY}`;
      const stockResponse = await fetch(stockUrl);
      const stockData = await stockResponse.json();

      if (stockData.status === 'OK' && stockData.results && stockData.results.length > 0) {
        const stockChartData = stockData.results.map((bar: any) => ({
          price: bar.c,
          timestamp: bar.t
        }));
        setStockChartData(prev => ({ ...prev, [option.id]: stockChartData }));
      } else {
        console.warn(`No stock data for ${option.symbol}:`, stockData.status, stockData);
      }
    } catch (error) {
      console.error('Error fetching option data:', error);
    }
  }, []);

  // Fetch current option quotes (bid/ask/last)
  const fetchLiveOptionQuotes = useCallback(async (options: any[]) => {
    try {
      const POLYGON_API_KEY = 'kjZ4aLJbqHsEhWGOjWMBthMvwDLKd4wf';

      for (const option of options) {
        const expiry = option.expiration.split('-').join('').slice(2);
        const strikeFormatted = (option.strike * 1000).toString().padStart(8, '0');
        const optionType = option.type === 'call' ? 'C' : 'P';
        const optionTicker = `O:${option.symbol}${expiry}${optionType}${strikeFormatted}`;

        // Fetch last quote with Greeks
        const quoteUrl = `https://api.polygon.io/v3/quotes/${optionTicker}?limit=1&order=desc&sort=timestamp&apiKey=${POLYGON_API_KEY}`;
        const quoteResponse = await fetch(quoteUrl);
        const quoteData = await quoteResponse.json();

        if (quoteData.status === 'OK' && quoteData.results && quoteData.results.length > 0) {
          const quote = quoteData.results[0];

          // Fetch snapshot for Greeks and IV
          const snapshotUrl = `https://api.polygon.io/v3/snapshot/options/${option.symbol}/${optionTicker}?apiKey=${POLYGON_API_KEY}`;
          const snapshotResponse = await fetch(snapshotUrl);
          const snapshotData = await snapshotResponse.json();

          const greeks = snapshotData?.results?.greeks || {};
          const details = snapshotData?.results?.details || {};

          setLiveOptionQuotes(prev => ({
            ...prev,
            [option.id]: {
              bid: quote.bid_price || 0,
              ask: quote.ask_price || 0,
              last: quote.last_price || ((quote.bid_price + quote.ask_price) / 2),
              delta: greeks.delta,
              gamma: greeks.gamma,
              theta: greeks.theta,
              vega: greeks.vega,
              implied_volatility: details.implied_volatility || snapshotData?.results?.implied_volatility
            }
          }));
        }
      }
    } catch (error) {
      console.error('Error fetching live option quotes:', error);
    }
  }, []);

  // Fetch ATR (Average True Range) for stock volatility calculation
  const fetchStockATR = useCallback(async (symbols: string[]) => {
    try {
      const POLYGON_API_KEY = 'kjZ4aLJbqHsEhWGOjWMBthMvwDLKd4wf';
      const uniqueSymbols = [...new Set(symbols)];

      for (const symbol of uniqueSymbols) {
        const today = new Date();
        const fromDate = new Date(today);
        fromDate.setDate(fromDate.getDate() - 20); // Get 20 days to ensure we have 14 trading days

        const fromStr = `${fromDate.getFullYear()}-${String(fromDate.getMonth() + 1).padStart(2, '0')}-${String(fromDate.getDate()).padStart(2, '0')}`;
        const toStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

        const url = `https://api.polygon.io/v2/aggs/ticker/${symbol}/range/1/day/${fromStr}/${toStr}?adjusted=true&sort=asc&limit=20&apiKey=${POLYGON_API_KEY}`;
        const response = await fetch(url);
        const data = await response.json();

        if (data.status === 'OK' && data.results && data.results.length >= 14) {
          // Calculate ATR: average of (high - low) over last 14 days
          const last14Days = data.results.slice(-14);
          const trueRanges = last14Days.map((bar: any) => bar.h - bar.l);
          const atr = trueRanges.reduce((sum: number, tr: number) => sum + tr, 0) / trueRanges.length;

          setStockATR(prev => ({ ...prev, [symbol]: atr }));
        }
      }
    } catch (error) {
      console.error('Error fetching stock ATR:', error);
    }
  }, []);

  // Fetch Options Trades data when tab is active or timeframe changes
  useEffect(() => {
    if (watchlistTab !== 'Options Trades') return;

    const saved = localStorage.getItem('optionsWatchlist');
    const optionsWatchlist: any[] = saved ? JSON.parse(saved) : [];

    if (optionsWatchlist.length === 0) return;

    // Initialize timeframes for all options if not set
    const newTimeframes = { ...optionsTradesTimeframes };
    let hasChanges = false;
    optionsWatchlist.forEach(option => {
      if (!newTimeframes[option.id]) {
        newTimeframes[option.id] = '1D';
        hasChanges = true;
      }
    });
    if (hasChanges) {
      setOptionsTradesTimeframes(newTimeframes);
    }

    // Fetch data for all options with their timeframes
    optionsWatchlist.forEach(option => {
      const timeframe = optionsTradesTimeframes[option.id] || '1D';
      fetchOptionData(option, timeframe);
    });

    // Fetch ATR for all unique symbols
    const uniqueSymbols = [...new Set(optionsWatchlist.map(opt => opt.symbol))];
    fetchStockATR(uniqueSymbols);

    // Fetch live quotes initially and then every 15 seconds
    fetchLiveOptionQuotes(optionsWatchlist);
    const quoteInterval = setInterval(() => {
      const saved = localStorage.getItem('optionsWatchlist');
      const currentWatchlist: any[] = saved ? JSON.parse(saved) : [];
      if (currentWatchlist.length > 0) {
        fetchLiveOptionQuotes(currentWatchlist);
      }
    }, 15000);

    return () => clearInterval(quoteInterval);
  }, [watchlistTab, optionsTradesTimeframes, fetchOptionData, fetchLiveOptionQuotes, fetchStockATR]);

  // Update peak prices when live quotes update (outside of render)
  useEffect(() => {
    if (watchlistTab !== 'Options Trades') return;

    const saved = localStorage.getItem('optionsWatchlist');
    const optionsWatchlist: any[] = saved ? JSON.parse(saved) : [];

    if (optionsWatchlist.length === 0) return;

    const peakPricesKey = 'optionPeakPrices';
    const savedPeaks = localStorage.getItem(peakPricesKey);
    const peakPrices = savedPeaks ? JSON.parse(savedPeaks) : {};
    let hasUpdates = false;

    optionsWatchlist.forEach(option => {
      const liveQuote = liveOptionQuotes[option.id];
      if (!liveQuote) return;

      const currentBid = liveQuote.bid ?? option.bid;
      const currentAsk = liveQuote.ask ?? option.ask;
      const currentPrice = (currentBid + currentAsk) / 2;
      const entryPrice = option.entryPrice || currentPrice;

      const currentPeak = peakPrices[option.id] || entryPrice;
      const newPeak = Math.max(currentPeak, currentPrice);

      if (newPeak > currentPeak) {
        peakPrices[option.id] = newPeak;
        hasUpdates = true;
      }
    });

    if (hasUpdates) {
      localStorage.setItem(peakPricesKey, JSON.stringify(peakPrices));
      setOptionPeakPrices(peakPrices);
    }
  }, [liveOptionQuotes, watchlistTab]);

  // Seasonality panel state
  const [seasonalSymbol, setSeasonalSymbol] = useState('SPY');
  const [seasonalYears, setSeasonalYears] = useState(20);
  const [seasonalElectionMode, setSeasonalElectionMode] = useState('Normal Mode');
  const [seasonalMonthlyData, setSeasonalMonthlyData] = useState<Array<{ month: string; outperformance: number }> | null>(null);
  const [seasonalBest30Day, setSeasonalBest30Day] = useState<any>(null);
  const [seasonalWorst30Day, setSeasonalWorst30Day] = useState<any>(null);
  const [seasonalSweetSpotActive, setSeasonalSweetSpotActive] = useState(false);
  const [seasonalPainPointActive, setSeasonalPainPointActive] = useState(false);
  const [seasonalData, setSeasonalData] = useState<any>(null);
  const [seasonalLoading, setSeasonalLoading] = useState(false);
  const [seasonalScanStarted, setSeasonalScanStarted] = useState(false);
  const [seasonalScreenerMarket, setSeasonalScreenerMarket] = useState('S&P 500');
  const [seasonalScreenerYears, setSeasonalScreenerYears] = useState('15Y');
  const [seasonalScreenerFilters, setSeasonalScreenerFilters] = useState({ highWinRate: false, startingSoon: false, fiftyTwoWeek: false });
  const [monthlyData, setMonthlyData] = useState<any[]>([]);
  const [best30Day, setBest30Day] = useState<any>(null);
  const [worst30Day, setWorst30Day] = useState<any>(null);

  const closeFlowPanel = useCallback(() => {
    setActiveSidebarPanel(null);
  }, []);

  // Flow Panel State (lifted to parent to prevent reset on re-renders)
  const [flowData, setFlowData] = useState<any[]>([]);
  const [flowSummary, setFlowSummary] = useState<any>({
    total_trades: 0,
    total_premium: 0,
    unique_symbols: 0,
    trade_types: { BLOCK: 0, SWEEP: 0, MINI: 0 },
    call_put_ratio: { calls: 0, puts: 0 },
    processing_time_ms: 0
  });
  const [flowMarketInfo, setFlowMarketInfo] = useState<any>({
    status: 'LIVE',
    is_live: true,
    data_date: new Date().toISOString().split('T')[0],
    market_open: true
  });
  const [flowLoading, setFlowLoading] = useState(false);
  const [flowSelectedTicker, setFlowSelectedTicker] = useState('');
  const [flowStreamingStatus, setFlowStreamingStatus] = useState<string>('');
  const [flowStreamingProgress, setFlowStreamingProgress] = useState<{ current: number, total: number } | null>(null);
  const [flowStreamError, setFlowStreamError] = useState<string>('');

  // Performance Dashboard state
  const [performanceDashboardDropdowns, setPerformanceDashboardDropdowns] = useState({
    sectors: false,
    industries: false,
    special: false
  });
  const [performanceDashboardCategories, setPerformanceDashboardCategories] = useState({
    sectors: { growth: true, value: true, defensives: true },
    industries: { growth: true, value: true, defensives: true },
    special: { growth: true, value: true, defensives: true }
  });

  // Performance Dashboard Chart State
  const pdCanvasRef = useRef<HTMLCanvasElement>(null);
  const pdContainerRef = useRef<HTMLDivElement>(null);
  const pdAnimationFrameRef = useRef<number | null>(null);
  const pdTimeframeRef = useRef<'1D' | '1W' | '1M' | '3M' | '6M' | '1Y' | '2Y' | '5Y' | '10Y' | '20Y' | 'YTD'>('1W');
  const pdLastDrawParamsRef = useRef<any>(null);
  const pdCrosshairRef = useRef<{ x: number; y: number } | null>(null);

  // Performance Dashboard Symbol Definitions - 11 Sectors Only
  const PD_SECTORS_ETFS = [
    { symbol: 'XLK', name: 'Technology', color: '#00d4ff' },
    { symbol: 'XLF', name: 'Financials', color: '#ff6b35' },
    { symbol: 'XLV', name: 'Healthcare', color: '#4ecdc4' },
    { symbol: 'XLI', name: 'Industrials', color: '#ffd93d' },
    { symbol: 'XLY', name: 'Discretionary', color: '#ff006e' },
    { symbol: 'XLP', name: 'Staples', color: '#8338ec' },
    { symbol: 'XLE', name: 'Energy', color: '#06ffa5' },
    { symbol: 'XLU', name: 'Utilities', color: '#fb5607' },
    { symbol: 'XLB', name: 'Materials', color: '#ffbe0b' },
    { symbol: 'XLRE', name: 'Real Estate', color: '#3a86ff' },
    { symbol: 'XLC', name: 'Communication', color: '#ff00cc' }
  ];

  const [pdSelectedSymbols, setPdSelectedSymbols] = useState<string[]>(() =>
    PD_SECTORS_ETFS.map(etf => etf.symbol) // Default to all 11 sectors
  );
  const [pdActiveCategories, setPdActiveCategories] = useState<{ sectors: boolean; industries: boolean; special: boolean }>({ sectors: false, industries: false, special: false });
  const [pdTimeframe, setPdTimeframe] = useState<'1D' | '1W' | '1M' | '3M' | '6M' | '1Y' | '2Y' | '5Y' | '10Y' | '20Y' | 'YTD'>('1D');
  const [pdPerformanceData, setPdPerformanceData] = useState<Array<{
    symbol: string;
    name: string;
    color: string;
    data: Array<{ timestamp: number; value: number; isMarketHours?: boolean }>;
    currentPerformance: number;
  }>>([]);
  const [pdLoading, setPdLoading] = useState(false);
  const [pdDimensions, setPdDimensions] = useState({ width: 0, height: 0 });
  const [pdHoveredSymbol, setPdHoveredSymbol] = useState<string | null>(null);
  const [pdVisibleRange, setPdVisibleRange] = useState({ start: 0, end: 1 });
  const [pdIsDragging, setPdIsDragging] = useState(false);
  const [pdDragStart, setPdDragStart] = useState({ x: 0, rangeStart: 0 });
  const [pdIsBenchmarked, setPdIsBenchmarked] = useState(false);

  const PD_INDUSTRIES_ETFS = [
    { symbol: 'IGV', name: 'Software', color: '#00d4ff' },
    { symbol: 'SMH', name: 'Semiconductors', color: '#ff6b35' },
    { symbol: 'XRT', name: 'Retail', color: '#4ecdc4' },
    { symbol: 'KIE', name: 'Insurance', color: '#ffd93d' },
    { symbol: 'KRE', name: 'Regional Banks', color: '#ff006e' },
    { symbol: 'GDX', name: 'Gold Miners', color: '#8338ec' },
    { symbol: 'ITA', name: 'Aerospace', color: '#06ffa5' },
    { symbol: 'TAN', name: 'Solar Energy', color: '#fb5607' },
    { symbol: 'XBI', name: 'Biotech', color: '#ffbe0b' },
    { symbol: 'ITB', name: 'Homebuilders', color: '#3a86ff' },
    { symbol: 'XHB', name: 'Homebuilders ETF', color: '#ff00ff' },
    { symbol: 'XOP', name: 'Oil & Gas', color: '#00ffff' },
    { symbol: 'OIH', name: 'Oil Services', color: '#ffff00' },
    { symbol: 'XME', name: 'Metals & Mining', color: '#ff8800' },
    { symbol: 'ARKK', name: 'Innovation', color: '#88ff00' },
    { symbol: 'IPO', name: 'IPOs', color: '#ff0088' },
    { symbol: 'VNQ', name: 'REITs', color: '#0088ff' },
    { symbol: 'JETS', name: 'Airlines', color: '#ff8844' },
    { symbol: 'KWEB', name: 'China Internet', color: '#44ff88' }
  ];

  const PD_SPECIAL_ETFS = [
    { symbol: 'IWF', name: 'Growth', color: '#00d4ff' },
    { symbol: 'IWD', name: 'Value', color: '#ff6b35' },
    { symbol: 'IJR', name: 'Small Cap', color: '#4ecdc4' },
    { symbol: 'USMV', name: 'Min Volatility', color: '#ffd93d' },
    { symbol: 'VYM', name: 'High Dividend', color: '#ff006e' },
    { symbol: 'PKW', name: 'Buyback', color: '#8338ec' },
    { symbol: 'CSD', name: 'Social', color: '#06ffa5' },
    { symbol: 'GURU', name: 'Popular Stocks', color: '#fb5607' },
    { symbol: 'QUAL', name: 'Quality', color: '#ffbe0b' },
    { symbol: 'PSP', name: 'Performance', color: '#3a86ff' },
    { symbol: 'IVE', name: 'Value S&P500', color: '#ff00ff' },
    { symbol: 'IVW', name: 'Growth S&P500', color: '#00ffff' },
    { symbol: 'IJJ', name: 'Mid Cap Value', color: '#ffff00' },
    { symbol: 'IJH', name: 'Mid Cap', color: '#ff8800' },
    { symbol: 'IWN', name: 'Small Cap Value', color: '#88ff00' },
    { symbol: 'IWO', name: 'Small Cap Growth', color: '#ff0088' }
  ];

  const POLYGON_API_KEY = 'kjZ4aLJbqHsEhWGOjWMBthMvwDLKd4wf';

  // Performance Dashboard Data Fetching Functions
  const getPdDateRange = (tf: typeof pdTimeframe): { from: string; to: string } => {
    const now = new Date();
    const to = now.toISOString().split('T')[0];
    let from = new Date();

    switch (tf) {
      case '1D':
        from.setDate(now.getDate());
        from.setHours(0, 0, 0, 0);
        break;
      case '1W':
        from.setDate(now.getDate() - 7);
        break;
      case '1M':
        from.setMonth(now.getMonth() - 1);
        break;
      case '3M':
        from.setMonth(now.getMonth() - 3);
        break;
      case '6M':
        from.setMonth(now.getMonth() - 6);
        break;
      case '1Y':
        from.setFullYear(now.getFullYear() - 1);
        break;
      case '2Y':
        from.setFullYear(now.getFullYear() - 2);
        break;
      case '5Y':
        from.setFullYear(now.getFullYear() - 5);
        break;
      case '10Y':
        from.setFullYear(now.getFullYear() - 10);
        break;
      case '20Y':
        from.setFullYear(now.getFullYear() - 20);
        break;
      case 'YTD':
        from = new Date(now.getFullYear(), 0, 1);
        break;
    }

    return { from: from.toISOString().split('T')[0], to };
  };

  const isPdMarketHours = (timestamp: number): boolean => {
    const date = new Date(timestamp);
    const datePST = new Date(date.toLocaleString('en-US', { timeZone: 'America/Los_Angeles' }));
    const hoursPST = datePST.getHours();
    const minutesPST = datePST.getMinutes();
    const totalMinutesPST = hoursPST * 60 + minutesPST;
    return totalMinutesPST >= 390 && totalMinutesPST <= 780; // 6:30 AM - 1:00 PM PST
  };

  // Add ref to track current fetch operation
  const pdFetchControllerRef = useRef<AbortController | null>(null);
  const pdLastFetchedSymbolsRef = useRef<string>('');

  const fetchPdPerformanceData = useCallback(async () => {
    if (pdSelectedSymbols.length === 0) return;

    console.log('ðŸ“Š Starting Performance Dashboard data fetch...', {
      symbolCount: pdSelectedSymbols.length,
      timeframe: pdTimeframe
    });

    // Cancel any existing fetch
    if (pdFetchControllerRef.current) {
      pdFetchControllerRef.current.abort();
    }

    // Create new controller for this fetch
    pdFetchControllerRef.current = new AbortController();
    const mainSignal = pdFetchControllerRef.current.signal;

    setPdLoading(true);
    const { from, to } = getPdDateRange(pdTimeframe);

    const allEtfs = [...PD_SECTORS_ETFS, ...PD_INDUSTRIES_ETFS, ...PD_SPECIAL_ETFS];
    const symbolsToFetch = allEtfs.filter(etf => pdSelectedSymbols.includes(etf.symbol));

    console.log('ðŸ“ˆ Symbols to fetch:', symbolsToFetch.map(e => e.symbol));

    try {
      // Map timeframe to bulk API format
      const timeframeMap: Record<string, string> = {
        '1D': '5m',  // Use 5-minute data for 1-day performance
        '1W': '1h',  // Use 1-hour data for 1-week performance
        '1M': '1d',  // Use daily data for 1-month performance
        '3M': '1d',  // Use daily data for 3-month performance
        '6M': '1d',  // Use daily data for 6-month performance
        '1Y': '1d'   // Use daily data for 1-year performance
      };

      const bulkTimeframe = timeframeMap[pdTimeframe] || '1d';

      console.log('ðŸ”„ Using bulk API timeframe:', bulkTimeframe);


      // Split symbols into chunks of 10 (bulk API limit)
      const symbolChunks = [];
      const symbols = symbolsToFetch.map(etf => etf.symbol);

      for (let i = 0; i < symbols.length; i += 10) {
        symbolChunks.push(symbols.slice(i, i + 10));
      }

      console.log('ðŸ“¦ Processing in', symbolChunks.length, 'chunk(s)');

      // Process chunks in parallel
      const chunkPromises = symbolChunks.map(async (chunk, idx) => {
        console.log(`ðŸ“¡ Fetching chunk ${idx + 1}:`, chunk);
        const response = await fetch('/api/bulk-chart-data', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            symbols: chunk,
            timeframe: bulkTimeframe,
            optimized: true
          }),
          signal: mainSignal
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error(`âŒ Chunk ${idx + 1} failed:`, response.status, errorText);
          throw new Error(`Bulk API failed: HTTP ${response.status} - ${errorText}`);
        }

        const result = await response.json();
        console.log(`âœ… Chunk ${idx + 1} success:`, Object.keys(result.data || {}).length, 'symbols');
        return result;
      });

      const chunkResults = await Promise.all(chunkPromises);

      console.log('âœ… All chunks completed');

      // Merge all chunk results into one data object
      const bulkResult = {
        success: true,
        data: {},
        errors: {}
      };

      chunkResults.forEach(result => {
        if (result.success && result.data) {
          Object.assign(bulkResult.data, result.data);
        }
        if (result.errors) {
          Object.assign(bulkResult.errors, result.errors);
        }
      });

      console.log('ðŸ“Š Merged data:', {
        totalSymbols: Object.keys(bulkResult.data).length,
        errors: Object.keys(bulkResult.errors).length
      });

      if (!bulkResult.success) {
        throw new Error('Bulk API request failed');
      }



      // Process bulk results and normalize data
      const results = symbolsToFetch.map(etf => {
        const symbolData = (bulkResult.data as any)[etf.symbol]; // Data is keyed by symbol

        if (!symbolData || symbolData.length === 0) {
          console.warn('âš ï¸ No data for', etf.symbol);
          return null;
        }

        let chartData = symbolData;

        // Filter for market hours if 1D timeframe
        if (pdTimeframe === '1D') {
          chartData = chartData.filter((point: any) => isPdMarketHours(point.timestamp));
        }

        if (chartData.length === 0) {
          console.warn('âš ï¸ No market hours data for', etf.symbol);
          return null;
        }

        // Calculate normalized performance data
        const firstPrice = chartData[0].close;
        const normalizedData = chartData.map((point: any) => ({
          timestamp: point.timestamp,
          value: ((point.close - firstPrice) / firstPrice) * 100,
          isMarketHours: pdTimeframe === '1W' ? isPdMarketHours(point.timestamp) : true
        }));

        const currentPerformance = normalizedData[normalizedData.length - 1]?.value || 0;

        return {
          symbol: etf.symbol,
          name: etf.name,
          color: etf.color,
          data: normalizedData,
          currentPerformance
        };
      }).filter((r): r is any => r !== null);

      console.log('âœ… Performance Dashboard data ready:', results.length, 'symbols processed');

      setPdPerformanceData(results);
      setPdVisibleRange({ start: 0, end: 1 });
    } catch (error) {
      if (!mainSignal.aborted) {
        console.error('âŒ Performance Dashboard fetch failed:', error);
        console.error('Error details:', {
          timeframe: pdTimeframe,
          symbolCount: pdSelectedSymbols.length,
          symbols: pdSelectedSymbols,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    } finally {
      if (!mainSignal.aborted) {
        setPdLoading(false);
      }
      pdFetchControllerRef.current = null;
    }
  }, [pdTimeframe, pdSelectedSymbols]);

  // Update canvas dimensions when container mounts and on resize
  useEffect(() => {
    const updateDimensions = () => {
      if (pdContainerRef.current) {
        const rect = pdContainerRef.current.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
          setPdDimensions(prev =>
            prev.width !== rect.width || prev.height !== rect.height
              ? { width: rect.width, height: rect.height }
              : prev
          );
        }
      }
    };

    updateDimensions();
    const timer = setTimeout(updateDimensions, 150);
    window.addEventListener('resize', updateDimensions);

    return () => {
      clearTimeout(timer);
      window.removeEventListener('resize', updateDimensions);
    };
  }, []);

  // Measure dimensions once when data first loads
  useEffect(() => {
    if (pdPerformanceData.length > 0 && pdDimensions.width === 0 && pdContainerRef.current) {
      const rect = pdContainerRef.current.getBoundingClientRect();
      if (rect.width > 0 && rect.height > 0) {
        setPdDimensions({ width: rect.width, height: rect.height });
      }
    }
  }, [pdPerformanceData.length, pdDimensions.width]);

  const drawPdChart = useCallback(() => {
    const canvas = pdCanvasRef.current;
    const ctx = canvas?.getContext('2d');

    if (!canvas || !ctx || pdDimensions.width === 0 || pdPerformanceData.length === 0) {
      return;
    }

    const dpr = window.devicePixelRatio;
    canvas.width = pdDimensions.width * dpr;
    canvas.height = pdDimensions.height * dpr;
    canvas.style.width = pdDimensions.width + 'px';
    canvas.style.height = pdDimensions.height + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, pdDimensions.width, pdDimensions.height);

    const m = { top: 40, right: 100, bottom: 80, left: 60 };
    const w = pdDimensions.width - m.left - m.right;
    const h = pdDimensions.height - m.top - m.bottom;

    const total = pdPerformanceData[0].data.length;
    const start = Math.floor(pdVisibleRange.start * total);
    const end = Math.ceil(pdVisibleRange.end * total);
    const visible = end - start;

    let min = Infinity, max = -Infinity;
    for (const etf of pdPerformanceData) {
      for (let i = start; i < end; i++) {
        const val = etf.data[i]?.value;
        if (val !== undefined) {
          if (val < min) min = val;
          if (val > max) max = val;
        }
      }
    }
    if (min === Infinity) min = 0;
    if (max === -Infinity) max = 0;

    const range = max - min || 1;
    const pad = range * 0.1;
    const yMin = min - pad;
    const yMax = max + pad;
    const yRange = yMax - yMin;

    const x = (i: number) => m.left + ((i - start) / visible) * w;
    const y = (v: number) => m.top + h - ((v - yMin) / yRange) * h;

    ctx.strokeStyle = '#333333';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
      const yPos = m.top + (h * i / 10);
      ctx.beginPath();
      ctx.moveTo(m.left, yPos);
      ctx.lineTo(m.left + w, yPos);
      ctx.stroke();
    }

    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 15px monospace';
    ctx.textAlign = 'right';
    for (let i = 0; i <= 10; i++) {
      const yPos = m.top + (h * i / 10);
      const val = yMax - (yRange * i / 10);
      ctx.fillText(`${val.toFixed(2)}%`, m.left - 10, yPos + 4);
    }

    if (min < 0 && max > 0) {
      const zeroY = y(0);
      ctx.strokeStyle = '#444444';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(m.left, zeroY);
      ctx.lineTo(m.left + w, zeroY);
      ctx.stroke();
    }

    ctx.save();
    ctx.beginPath();
    ctx.rect(m.left, m.top, w, h);
    ctx.clip();

    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    for (const etf of pdPerformanceData) {
      const hovered = pdHoveredSymbol === etf.symbol;
      ctx.strokeStyle = etf.color;
      ctx.lineWidth = hovered ? 2 : 1.5;
      ctx.globalAlpha = hovered || !pdHoveredSymbol ? 1 : 0.3;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';

      ctx.beginPath();
      let first = true;
      for (let i = start; i < end; i++) {
        const point = etf.data[i];
        if (point) {
          const xPos = x(i);
          const yPos = y(point.value);
          if (first) {
            ctx.moveTo(xPos, yPos);
            first = false;
          } else {
            ctx.lineTo(xPos, yPos);
          }
        }
      }
      ctx.stroke();
    }

    ctx.globalAlpha = 1;
    ctx.restore();

    const sorted = [...pdPerformanceData].sort((a, b) => b.currentPerformance - a.currentPerformance);
    const legX = m.left + w + 30;
    let legY = m.top + 20;

    for (let i = 0; i < sorted.length; i++) {
      const etf = sorted[i];
      const yPos = legY + (i * 55);
      const hovered = pdHoveredSymbol === etf.symbol;

      if (hovered) {
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(legX - 5, yPos - 14, 190, 26);
      }

      ctx.fillStyle = etf.color;
      ctx.font = hovered ? 'bold 21px monospace' : '19px monospace';
      ctx.textAlign = 'left';
      ctx.fillText(etf.symbol, legX, yPos);

      const perfColor = etf.currentPerformance >= 0 ? '#00ff00' : '#ff0000';
      ctx.fillStyle = perfColor;
      ctx.font = hovered ? 'bold 19px monospace' : '17px monospace';
      const perfText = `${etf.currentPerformance >= 0 ? '+' : ''}${etf.currentPerformance.toFixed(2)}%`;
      ctx.fillText(perfText, legX, yPos + 16);
    }

    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 18px monospace';
    ctx.textAlign = 'center';

    const labelCount = Math.min(12, Math.max(6, visible < 50 ? 6 : 10));
    for (let i = 0; i <= labelCount; i++) {
      const idx = start + Math.floor(visible * i / labelCount);
      const point = pdPerformanceData[0]?.data[idx];
      if (point) {
        const xPos = x(idx);
        if (xPos >= m.left && xPos <= m.left + w) {
          const date = new Date(point.timestamp);
          let label: string;
          if (pdTimeframe === '1D') {
            label = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', timeZone: 'America/Los_Angeles' });
          } else if (pdTimeframe === '1W') {
            label = date.toLocaleDateString([], { month: 'numeric', day: 'numeric', timeZone: 'America/Los_Angeles' });
          } else {
            label = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
          }
          ctx.fillText(label, xPos, pdDimensions.height - m.bottom + 30);
        }
      }
    }

    const cross = pdCrosshairRef.current;
    if (cross && cross.x >= m.left && cross.x <= m.left + w && cross.y >= m.top && cross.y <= m.top + h) {
      ctx.strokeStyle = '#888888';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);

      ctx.beginPath();
      ctx.moveTo(cross.x, m.top);
      ctx.lineTo(cross.x, m.top + h);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(m.left, cross.y);
      ctx.lineTo(m.left + w, cross.y);
      ctx.stroke();

      ctx.setLineDash([]);

      const yVal = yMax - ((cross.y - m.top) / h) * yRange;
      ctx.fillStyle = '#ff6600';
      const yText = `${yVal.toFixed(2)}%`;
      ctx.font = 'bold 12px monospace';
      const yWidth = ctx.measureText(yText).width;
      ctx.fillRect(m.left - yWidth - 20, cross.y - 10, yWidth + 10, 20);
      ctx.fillStyle = '#000000';
      ctx.textAlign = 'right';
      ctx.fillText(yText, m.left - 15, cross.y + 5);

      const xPercent = (cross.x - m.left) / w;
      const idx = Math.floor(start + xPercent * visible);
      const point = pdPerformanceData[0]?.data[idx];
      if (point) {
        const date = new Date(point.timestamp);
        const xText = pdTimeframe === '1D'
          ? date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' })
          : date.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' });
        ctx.fillStyle = '#ff6600';
        ctx.textAlign = 'center';
        const xWidth = ctx.measureText(xText).width;
        ctx.fillRect(cross.x - xWidth / 2 - 5, pdDimensions.height - m.bottom + 15, xWidth + 10, 20);
        ctx.fillStyle = '#000000';
        ctx.fillText(xText, cross.x, pdDimensions.height - m.bottom + 30);
      }
    }
  }, [pdPerformanceData, pdDimensions, pdHoveredSymbol, pdVisibleRange]);

  // Draw chart when data or state changes
  useEffect(() => {
    if (pdPerformanceData.length > 0 && pdDimensions.width > 0) {
      drawPdChart();
    }
  }, [pdPerformanceData, pdDimensions, pdVisibleRange, pdHoveredSymbol]);

  // Auto-refresh disabled to prevent flickering
  // useEffect(() => {
  //   if (pdSelectedSymbols.length === 0 || pdPerformanceData.length === 0) return;
  //   
  //   const interval = setInterval(() => {
  //     fetchPdPerformanceData();
  //   }, 300000); // 5 minutes
  //   
  //   return () => clearInterval(interval);
  // }, [pdSelectedSymbols.length, pdPerformanceData.length]);

  // Wheel zoom for Performance Dashboard
  useEffect(() => {
    const canvas = pdCanvasRef.current;
    if (!canvas) return;

    const handleWheelNative = (event: WheelEvent) => {
      event.preventDefault();

      const rect = canvas.getBoundingClientRect();
      const margin = { top: 40, right: 100, bottom: 80, left: 60 };
      const chartWidth = pdDimensions.width - margin.left - margin.right;
      const mouseX = event.clientX - rect.left;

      if (mouseX < margin.left || mouseX > margin.left + chartWidth) return;

      const mouseDataPos = pdVisibleRange.start + ((mouseX - margin.left) / chartWidth) * (pdVisibleRange.end - pdVisibleRange.start);

      const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
      const currentRange = pdVisibleRange.end - pdVisibleRange.start;
      let newRange = currentRange * zoomFactor;

      newRange = Math.max(0.02, Math.min(1, newRange));

      const mousePercent = (mouseX - margin.left) / chartWidth;
      let newStart = mouseDataPos - newRange * mousePercent;
      let newEnd = newStart + newRange;

      if (newStart < 0) {
        newStart = 0;
        newEnd = newRange;
      }
      if (newEnd > 1) {
        newEnd = 1;
        newStart = 1 - newRange;
      }

      setPdVisibleRange({ start: newStart, end: newEnd });
    };

    canvas.addEventListener('wheel', handleWheelNative, { passive: false });
    return () => canvas.removeEventListener('wheel', handleWheelNative);
  }, [pdDimensions]);

  // Mouse event handlers for Performance Dashboard
  const handlePdMouseMove = (event: React.MouseEvent<HTMLCanvasElement>) => {
    if (!pdCanvasRef.current) return;

    const rect = pdCanvasRef.current.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    const margin = { top: 40, right: 100, bottom: 80, left: 60 };
    const chartWidth = pdDimensions.width - margin.left - margin.right;
    const chartHeight = pdDimensions.height - margin.top - margin.bottom;

    if (mouseX >= margin.left && mouseX <= margin.left + chartWidth &&
      mouseY >= margin.top && mouseY <= margin.top + chartHeight) {
      pdCrosshairRef.current = { x: mouseX, y: mouseY };
    } else {
      pdCrosshairRef.current = null;
    }

    if (pdIsDragging) {
      const deltaX = mouseX - pdDragStart.x;
      const rangeSize = pdVisibleRange.end - pdVisibleRange.start;
      const rangeDelta = -(deltaX / chartWidth) * rangeSize;

      let newStart = pdDragStart.rangeStart + rangeDelta;
      let newEnd = newStart + rangeSize;

      if (newStart < 0) {
        newStart = 0;
        newEnd = rangeSize;
      }
      if (newEnd > 1) {
        newEnd = 1;
        newStart = 1 - rangeSize;
      }

      setPdVisibleRange({ start: newStart, end: newEnd });
      return;
    }

    const legendX = pdDimensions.width - margin.right + 30;
    const legendY = margin.top + 20;
    const itemSpacing = 55;

    let found = false;

    sortedPdData.forEach((etf, index) => {
      const y = legendY + (index * itemSpacing);
      if (mouseX >= legendX - 5 && mouseX <= legendX + 185 &&
        mouseY >= y - 18 && mouseY <= y + 35) {
        if (pdHoveredSymbol !== etf.symbol) {
          setPdHoveredSymbol(etf.symbol);
        }
        found = true;
      }
    });

    if (!found && pdHoveredSymbol !== null) {
      setPdHoveredSymbol(null);
    }
  };

  const handlePdMouseDown = (event: React.MouseEvent<HTMLCanvasElement>) => {
    const rect = pdCanvasRef.current?.getBoundingClientRect();
    if (!rect) return;
    setPdIsDragging(true);
    setPdDragStart({
      x: event.clientX - rect.left,
      rangeStart: pdVisibleRange.start
    });
  };

  const handlePdMouseUp = () => {
    setPdIsDragging(false);
  };

  // Memoize sorted performance data for legend to prevent recreation on every mouse move
  const sortedPdData = useMemo(() => {
    return [...pdPerformanceData].sort((a, b) => b.currentPerformance - a.currentPerformance);
  }, [pdPerformanceData]);

  // Chat messages state for each channel
  const [chatMessages, setChatMessages] = useState<{ [channel: string]: Array<{ id: string, user: string, message: string, timestamp: Date, userType: string }> }>({
    // Start Here channels
    announcements: [
      { id: '1', user: 'SYSTEM ADMIN', message: '?? Welcome to EFI Trading! New Volume Bars Feature Released - customize colors in chart settings.', timestamp: new Date(Date.now() - 5 * 60 * 60 * 1000), userType: 'admin' },
      { id: '2', user: 'MARKET ALERT', message: '?? Extended trading session tonight due to FOMC announcement. Adjust strategies accordingly.', timestamp: new Date(Date.now() - 24 * 60 * 60 * 1000), userType: 'system' }
    ],
    testimonials: [
      { id: '1', user: 'TraderMike', message: '? Made $2,400 profit this week following the GEX levels! Thank you team!', timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000), userType: 'user' }
    ],
    'rules-disclaimers': [
      { id: '1', user: 'COMPLIANCE', message: '?? Please read all trading disclaimers before participating. Risk management is key!', timestamp: new Date(Date.now() - 48 * 60 * 60 * 1000), userType: 'admin' }
    ],
    'contact-us': [],
    'start-here-channel': [
      { id: '1', user: 'WELCOME BOT', message: '?? New members start here! Check out our education materials first.', timestamp: new Date(Date.now() - 12 * 60 * 60 * 1000), userType: 'system' }
    ],
    // Education channels
    'live-recordings': [],
    lesson: [],
    application: [],
    'result-upload': [],
    'traders-code': [
      { id: '1', user: 'ZakTrades', message: '?? Remember: Risk management > profit chasing. Stick to your plan!', timestamp: new Date(Date.now() - 6 * 60 * 60 * 1000), userType: 'admin' }
    ],
    'zaks-market-moves': [
      { id: '1', user: 'ZakTrades', message: '?? Watching SPY 650 resistance level closely. Volume confirmation needed for breakout.', timestamp: new Date(Date.now() - 1 * 60 * 60 * 1000), userType: 'admin' }
    ],
    // Market Insights channels
    cyclical: [],
    monthly: [],
    'chart-track-trade': [],
    'gex-ideas': [
      { id: '1', user: 'GEX_ANALYST', message: '?? Heavy call wall at SPY 655. Expecting resistance here.', timestamp: new Date(Date.now() - 30 * 60 * 1000), userType: 'admin' }
    ],
    'insiders-congress': [],
    'notable-flow': [
      { id: '1', user: 'FLOW_SCANNER', message: '? Large SPY call sweep detected: 10,000 contracts at 650 strike!', timestamp: new Date(Date.now() - 15 * 60 * 1000), userType: 'system' }
    ],
    // Trade Center channels
    'dividend-portfolio': [],
    '100k-portfolio': [],
    '25k-portfolio': [],
    '5k-portfolio': [],
    'weekly-snapshot': [],
    'swing-trades': [
      { id: '1', user: 'SwingMaster', message: '? NVDA looking good for a bounce from 200 support level.', timestamp: new Date(Date.now() - 45 * 60 * 1000), userType: 'user' }
    ],
    'stock-chat': [],
    'flow-analyst': [],
    // Traders Den channels
    'feedback-hub': [],
    'all-flow': [],
    calendar: [],
    motiversity: [
      { id: '1', user: 'MotivationBot', message: '? "Success is not final, failure is not fatal: it is the courage to continue that counts." - Winston Churchill', timestamp: new Date(Date.now() - 3 * 60 * 60 * 1000), userType: 'system' }
    ],
    mentorship: [],
    'chill-chat': [
      { id: '1', user: 'CommunityMember', message: '?? Anyone else excited for the weekend? Time to analyze this week\'s trades!', timestamp: new Date(Date.now() - 20 * 60 * 1000), userType: 'user' }
    ]
  });

  const [currentMessage, setCurrentMessage] = useState('');
  const [screenshots, setScreenshots] = useState<Array<{ id: string, url: string, timestamp: Date, notes: string }>>([]);
  const [notes, setNotes] = useState<Array<{ id: string, title: string, content: string, timestamp: Date, color: string }>>([]);
  const [reminders, setReminders] = useState<Array<{ id: string, title: string, datetime: Date, completed: boolean }>>([]);

  // Chat functionality states
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  const [uploadedFiles, setUploadedFiles] = useState<Array<{ id: string, name: string, type: string, url: string, size: number }>>([]);

  // Market Regime Analysis state with caching and progress tracking
  const [marketRegimeData, setMarketRegimeData] = useState<MarketRegimeData | null>(null);
  const [isLoadingRegimes, setIsLoadingRegimes] = useState(false);
  const [regimeDataCache, setRegimeDataCache] = useState<{ [key: string]: TimeframeAnalysis }>({});
  const [lastRegimeUpdate, setLastRegimeUpdate] = useState<number>(0);
  const [regimeUpdateProgress, setRegimeUpdateProgress] = useState<number>(0);
  const [regimeLoadingStage, setRegimeLoadingStage] = useState<string>('');
  const [selectedIndustry, setSelectedIndustry] = useState<IndustryPerformance | null>(null);
  const [allRegimesLoaded, setAllRegimesLoaded] = useState(false);
  const [highlightFilter, setHighlightFilter] = useState<'all' | 'gold' | 'purple' | 'highlights'>('all');
  const [sortByPercentage, setSortByPercentage] = useState(true); // true = highest first, false = lowest first

  // Build a Trade panel state
  const [buildTradeTickerInput, setBuildTradeTickerInput] = useState('');
  const [buildTradeTimeframe, setBuildTradeTimeframe] = useState<'1D' | '3D'>('1D');
  const [buildTradeScanning, setBuildTradeScanning] = useState(false);
  const [buildTradeScanProgress, setBuildTradeScanProgress] = useState<{ current: number; total: number } | null>(null);
  const [buildTradeSweetSpot, setBuildTradeSweetSpot] = useState<{ period: string; startDay: number; endDay: number; totalReturn: number } | null>(null);
  const [buildTradePainPoint, setBuildTradePainPoint] = useState<{ period: string; startDay: number; endDay: number; totalReturn: number } | null>(null);
  const [buildTradeHVSignals, setBuildTradeHVSignals] = useState<{ hv10Day: boolean; hv20Day: boolean; hv52Week: boolean }>({ hv10Day: false, hv20Day: false, hv52Week: false });
  const [buildTradeRRGSignal, setBuildTradeRRGSignal] = useState<{ quadrant: string; dominantQuadrant: string; consistency: number; rsRatio: number; rsMomentum: number; timeframes: Record<string, string> }>({ quadrant: '', dominantQuadrant: '', consistency: 0, rsRatio: 0, rsMomentum: 0, timeframes: { '4w': '', '8w': '', '14w': '', '26w': '' } });
  const [buildTradeMarketRegime, setBuildTradeMarketRegime] = useState<Array<{ highlightType: 'gold' | 'purple'; timeframe: string; score: number; trend: string; industry: string; relativePerformance: number; tradeDetails: any | null }>>([]);
  const [buildTradeExpectedRange, setBuildTradeExpectedRange] = useState<{ weekly80Call: number; weekly90Call: number; weekly80Put: number; weekly90Put: number; monthly80Call: number; monthly90Call: number; monthly80Put: number; monthly90Put: number; currentPrice: number; weeklyIV: number; monthlyIV: number } | null>(null);
  const [buildTradeEvents, setBuildTradeEvents] = useState<Array<{ eventName: string; eventDate: Date; data: Array<{ tradingDay: number; avgReturn: number }>; occurrences: number }>>([]);
  const [buildTradePatterns, setBuildTradePatterns] = useState<Array<{ patternName: string; data: Array<{ tradingDay: number; avgReturn: number }>; occurrences: number; occurrenceDetails: Array<{ date: Date; priceAtEvent: number; changePercent?: number }> }>>([]);
  const [buildTradeIntensity, setBuildTradeIntensity] = useState<{ score: number; signal: string; color: string } | null>(null);
  const [buildTradeStability, setBuildTradeStability] = useState<{ si: number; stability: string; behavior: string; color: string } | null>(null);

  // Calculate Historical Volatility (EXACT same as HVScreener)
  const calculateHV = (prices: number[], period: number): number => {
    if (prices.length < period + 1) return 0;

    const returns: number[] = [];
    for (let i = 1; i < prices.length; i++) {
      if (prices[i - 1] !== 0) {
        returns.push(Math.log(prices[i] / prices[i - 1]));
      }
    }

    if (returns.length === 0) return 0;

    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
    const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
    const stdDev = Math.sqrt(variance);

    // Annualize the volatility
    return stdDev * Math.sqrt(252) * 100;
  };

  // Check RS criteria (EXACT same logic as RSScreener with 1 year)
  // Check Market Regime status (EXACT same logic as Market Regimes panel)
  const checkMarketRegimeCriteria = async (symbol: string): Promise<Array<{ highlightType: 'gold' | 'purple'; timeframe: string; score: number; trend: string; industry: string; relativePerformance: number; tradeDetails: any | null }>> => {
    const results: Array<{ highlightType: 'gold' | 'purple'; timeframe: string; score: number; trend: string; industry: string; relativePerformance: number; tradeDetails: any | null }> = [];

    try {
      // Use EXACT same logic as Market Regimes panel - check highlightedTradesCache for all timeframes
      const timeframes = ['life', 'developing', 'momentum', 'legacy'];

      for (const tf of timeframes) {
        // Check if symbol exists in highlighted trades for this timeframe
        const tfTrades = highlightedTradesCache[tf];
        if (tfTrades && tfTrades[symbol]) {
          const trade = tfTrades[symbol];
          results.push({
            highlightType: trade.highlightType, // This is already 'gold' or 'purple' from Market Regimes calculation
            timeframe: tf,
            score: trade.score || 0,
            trend: trade.trend || '',
            industry: trade.industry || '',
            relativePerformance: trade.relativePerformance || 0,
            tradeDetails: trade
          });
        }
      }

      return results;
    } catch (error) {
      console.error('Error checking Market Regime criteria:', error);
      return results;
    }
  };

  // Check for relevant events within 1 month timeframe (EXACT same logic as Events button)
  const checkEventsForTicker = async (symbol: string): Promise<Array<{ eventName: string; eventDate: Date; data: Array<{ tradingDay: number; avgReturn: number }>; occurrences: number }>> => {
    const API_KEY = 'kjZ4aLJbqHsEhWGOjWMBthMvwDLKd4wf';
    const currentYear = new Date().getFullYear();
    const today = new Date();
    const oneMonthBefore = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);
    const oneMonthAfter = new Date(today.getTime() + 30 * 24 * 60 * 60 * 1000);

    const events = [
      { key: 'thanksgiving', name: 'Thanksgiving' },
      { key: 'christmas', name: 'Christmas' },
      { key: 'newyear', name: 'New Year' },
      { key: 'presidentsday', name: 'Presidents Day' },
      { key: 'mlkday', name: 'MLK Day' },
      { key: 'memorialday', name: 'Memorial Day' },
      { key: 'july4th', name: 'July 4th' },
      { key: 'laborday', name: 'Labor Day' }
    ];

    const getEventDates = (event: string): Date[] => {
      const dates: Date[] = [];
      for (let year = currentYear - 5; year <= currentYear + 1; year++) {
        switch (event) {
          case 'thanksgiving':
            const nov1 = new Date(year, 10, 1);
            const firstThursday = (4 - nov1.getDay() + 7) % 7 + 1;
            dates.push(new Date(year, 10, firstThursday + 21));
            break;
          case 'christmas':
            dates.push(new Date(year, 11, 25));
            break;
          case 'newyear':
            dates.push(new Date(year, 0, 1));
            break;
          case 'presidentsday':
            const feb1 = new Date(year, 1, 1);
            const firstMonday = (1 - feb1.getDay() + 7) % 7 + 1;
            dates.push(new Date(year, 1, firstMonday + 14));
            break;
          case 'mlkday':
            const jan1 = new Date(year, 0, 1);
            const firstMondayJan = (1 - jan1.getDay() + 7) % 7 + 1;
            dates.push(new Date(year, 0, firstMondayJan + 14));
            break;
          case 'memorialday':
            const may31 = new Date(year, 4, 31);
            const lastMonday = 31 - ((may31.getDay() + 6) % 7);
            dates.push(new Date(year, 4, lastMonday));
            break;
          case 'july4th':
            dates.push(new Date(year, 6, 4));
            break;
          case 'laborday':
            const sep1 = new Date(year, 8, 1);
            const firstMondaySep = (1 - sep1.getDay() + 7) % 7 + 1;
            dates.push(new Date(year, 8, firstMondaySep));
            break;
        }
      }
      return dates;
    };

    const isWeekend = (date: Date) => date.getDay() === 0 || date.getDay() === 6;
    const isHoliday = (date: Date) => {
      const month = date.getMonth(), day = date.getDate(), dayOfWeek = date.getDay();
      if (month === 0 && day === 1) return true;
      if (month === 6 && day === 4) return true;
      if (month === 11 && day === 25) return true;
      if (month === 0 && dayOfWeek === 1 && day >= 15 && day <= 21) return true;
      if (month === 1 && dayOfWeek === 1 && day >= 15 && day <= 21) return true;
      if (month === 4 && dayOfWeek === 1 && day >= 25) return true;
      if (month === 8 && dayOfWeek === 1 && day <= 7) return true;
      if (month === 10 && dayOfWeek === 4 && day >= 22 && day <= 28) return true;
      return false;
    };

    const getTradingDays = (startDate: Date, count: number, forward: boolean): Date[] => {
      const days: Date[] = [];
      const current = new Date(startDate);
      let found = 0;
      while (found < count) {
        current.setDate(current.getDate() + (forward ? 1 : -1));
        if (!isWeekend(current) && !isHoliday(current)) {
          days.push(new Date(current));
          found++;
        }
      }
      return forward ? days : days.reverse();
    };

    const relevantEvents: Array<{ eventName: string; eventDate: Date; data: Array<{ tradingDay: number; avgReturn: number }>; occurrences: number }> = [];

    for (const event of events) {
      const eventDates = getEventDates(event.key);
      const closestEvent = eventDates.find(d => d >= oneMonthBefore && d <= oneMonthAfter);

      if (!closestEvent) continue;

      try {
        const allReturns: number[][] = Array(13).fill(0).map(() => []);

        for (const eventDate of eventDates) {
          const before = getTradingDays(eventDate, 5, false);
          const after = getTradingDays(eventDate, 7, true);
          const allDays = [...before, eventDate, ...after];

          const from = allDays[0].toISOString().split('T')[0];
          const to = allDays[allDays.length - 1].toISOString().split('T')[0];

          const response = await fetch(
            `https://api.polygon.io/v2/aggs/ticker/${symbol}/range/1/day/${from}/${to}?adjusted=true&sort=asc&apiKey=${API_KEY}`
          );

          if (!response.ok) continue;
          const data = await response.json();
          if (!data.results || data.results.length === 0) continue;

          const prices = data.results.map((r: any) => r.c);
          const eventIndex = 5;
          const eventPrice = prices[eventIndex];

          for (let i = 0; i < prices.length && i < 13; i++) {
            const returnPct = ((prices[i] - eventPrice) / eventPrice) * 100;
            allReturns[i].push(returnPct);
          }
        }

        const avgReturns = allReturns.map(returns =>
          returns.length > 0 ? returns.reduce((a, b) => a + b, 0) / returns.length : 0
        );

        const perfData = avgReturns.map((avgReturn, index) => ({
          tradingDay: index - 5,
          avgReturn
        }));

        relevantEvents.push({
          eventName: event.name,
          eventDate: closestEvent,
          data: perfData,
          occurrences: allReturns[0].length
        });
      } catch (error) {
        console.error(`Error calculating event ${event.name}:`, error);
      }
    }

    return relevantEvents;
  };

  // Check for pattern matches (EXACT same logic as Pattern Analysis)
  const checkPatternsForTicker = async (symbol: string): Promise<Array<{ patternName: string; data: Array<{ tradingDay: number; avgReturn: number }>; occurrences: number; occurrenceDetails: Array<{ date: Date; priceAtEvent: number; changePercent?: number }> }>> => {
    const patterns = [
      { id: '52week-high-cooldown', label: '52W High (90d Cooldown)', forwardDays: 20 },
      { id: '52week-high-annual', label: '52W High (Annual)', forwardDays: 20 },
      { id: '52week-low-cooldown', label: '52W Low (90d Cooldown)', forwardDays: 20 },
      { id: '52week-low-annual', label: '52W Low (Annual)', forwardDays: 20 },
      { id: 'move-8-11-up-cooldown', label: '8-11% UP (90d Cooldown)', forwardDays: 29 },
      { id: 'move-8-11-up-annual', label: '8-11% UP (Annual)', forwardDays: 29 },
      { id: 'move-8-11-down-cooldown', label: '8-11% DOWN (90d Cooldown)', forwardDays: 29 },
      { id: 'move-8-11-down-annual', label: '8-11% DOWN (Annual)', forwardDays: 29 },
      { id: 'move-18-22-up-cooldown', label: '18-22% UP (90d Cooldown)', forwardDays: 29 },
      { id: 'move-18-22-up-annual', label: '18-22% UP (Annual)', forwardDays: 29 },
      { id: 'move-18-22-down-cooldown', label: '18-22% DOWN (90d Cooldown)', forwardDays: 29 },
      { id: 'move-18-22-down-annual', label: '18-22% DOWN (Annual)', forwardDays: 29 }
    ];

    const matchedPatterns: Array<{ patternName: string; data: Array<{ tradingDay: number; avgReturn: number }>; occurrences: number; occurrenceDetails: Array<{ date: Date; priceAtEvent: number; changePercent?: number }> }> = [];

    try {
      const yearsBack = 19;
      const endDate = new Date();
      const startDate = new Date();
      startDate.setFullYear(startDate.getFullYear() - yearsBack);

      const startStr = startDate.toISOString().split('T')[0];
      const endStr = endDate.toISOString().split('T')[0];

      const apiKey = 'kjZ4aLJbqHsEhWGOjWMBthMvwDLKd4wf';
      const url = `https://api.polygon.io/v2/aggs/ticker/${symbol}/range/1/day/${startStr}/${endStr}?adjusted=true&sort=asc&apiKey=${apiKey}`;

      const response = await fetch(url);
      const data = await response.json();

      if (!data.results || data.results.length < 252) {
        return matchedPatterns;
      }

      const prices: Array<{ date: Date; close: number; high: number; low: number }> = data.results.map((r: any) => ({
        date: new Date(r.t),
        close: r.c,
        high: r.h,
        low: r.l
      }));

      const recentPrice = prices[prices.length - 1];
      const recentDate = recentPrice.date;
      const twentyDaysAgo = new Date(recentDate.getTime() - 20 * 24 * 60 * 60 * 1000);

      for (const pattern of patterns) {
        const occurrences: Date[] = [];
        const occurrenceDetails: Array<{ date: Date; priceAtEvent: number; changePercent?: number }> = [];

        if (pattern.id === '52week-high-cooldown' || pattern.id === '52week-high-annual') {
          for (let i = 252; i < prices.length; i++) {
            const last252 = prices.slice(i - 252, i);
            const high52Week = Math.max(...last252.map(p => p.high));

            if (prices[i].close > high52Week) {
              const occDate = prices[i].date;

              if (pattern.id === '52week-high-cooldown') {
                const lastOcc = occurrences[occurrences.length - 1];
                if (!lastOcc || (occDate.getTime() - lastOcc.getTime()) / (1000 * 60 * 60 * 24) >= 90) {
                  occurrences.push(occDate);
                  occurrenceDetails.push({
                    date: occDate,
                    priceAtEvent: prices[i].close,
                    changePercent: ((prices[i].close - high52Week) / high52Week) * 100
                  });
                }
              } else {
                // Annual: first occurrence per year
                const year = occDate.getFullYear();
                if (!occurrences.find(d => d.getFullYear() === year)) {
                  occurrences.push(occDate);
                  occurrenceDetails.push({
                    date: occDate,
                    priceAtEvent: prices[i].close,
                    changePercent: ((prices[i].close - high52Week) / high52Week) * 100
                  });
                }
              }
            }
          }
        } else if (pattern.id === '52week-low-cooldown' || pattern.id === '52week-low-annual') {
          for (let i = 252; i < prices.length; i++) {
            const last252 = prices.slice(i - 252, i);
            const low52Week = Math.min(...last252.map(p => p.low));

            if (prices[i].close < low52Week) {
              const occDate = prices[i].date;

              if (pattern.id === '52week-low-cooldown') {
                const lastOcc = occurrences[occurrences.length - 1];
                if (!lastOcc || (occDate.getTime() - lastOcc.getTime()) / (1000 * 60 * 60 * 24) >= 90) {
                  occurrences.push(occDate);
                  occurrenceDetails.push({
                    date: occDate,
                    priceAtEvent: prices[i].close,
                    changePercent: ((prices[i].close - low52Week) / low52Week) * 100
                  });
                }
              } else {
                const year = occDate.getFullYear();
                if (!occurrences.find(d => d.getFullYear() === year)) {
                  occurrences.push(occDate);
                  occurrenceDetails.push({
                    date: occDate,
                    priceAtEvent: prices[i].close,
                    changePercent: ((prices[i].close - low52Week) / low52Week) * 100
                  });
                }
              }
            }
          }
        } else if (pattern.id.startsWith('move-')) {
          const [_, minPct, maxPct, direction, method] = pattern.id.split('-');
          const minMove = parseFloat(minPct);
          const maxMove = parseFloat(maxPct);

          for (let i = 1; i < prices.length; i++) {
            const pctChange = ((prices[i].close - prices[i - 1].close) / prices[i - 1].close) * 100;
            const absChange = Math.abs(pctChange);

            if (absChange >= minMove && absChange <= maxMove) {
              if ((direction === 'up' && pctChange > 0) || (direction === 'down' && pctChange < 0)) {
                const occDate = prices[i].date;

                if (method === 'cooldown') {
                  const lastOcc = occurrences[occurrences.length - 1];
                  if (!lastOcc || (occDate.getTime() - lastOcc.getTime()) / (1000 * 60 * 60 * 24) >= 90) {
                    occurrences.push(occDate);
                    occurrenceDetails.push({
                      date: occDate,
                      priceAtEvent: prices[i].close,
                      changePercent: pctChange
                    });
                  }
                } else if (method === 'annual') {
                  const year = occDate.getFullYear();
                  if (!occurrences.find(d => d.getFullYear() === year)) {
                    occurrences.push(occDate);
                    occurrenceDetails.push({
                      date: occDate,
                      priceAtEvent: prices[i].close,
                      changePercent: pctChange
                    });
                  }
                }
              }
            }
          }
        }

        // Check if most recent occurrence is within 20 days
        const recentOccurrence = occurrences.length > 0 ? occurrences[occurrences.length - 1] : null;
        if (!recentOccurrence || recentOccurrence < twentyDaysAgo) continue;

        if (occurrences.length > 0) {
          const allReturns: number[][] = Array.from({ length: pattern.forwardDays + 1 }, () => []);

          for (const occDate of occurrences) {
            const occIndex = prices.findIndex(p => p.date.getTime() === occDate.getTime());
            if (occIndex === -1 || occIndex + pattern.forwardDays >= prices.length) continue;

            const basePrice = prices[occIndex].close;

            for (let day = 0; day <= pattern.forwardDays; day++) {
              if (occIndex + day < prices.length) {
                const returnPct = ((prices[occIndex + day].close - basePrice) / basePrice) * 100;
                allReturns[day].push(returnPct);
              }
            }
          }

          const avgReturns = allReturns.map(returns =>
            returns.length > 0 ? returns.reduce((a, b) => a + b, 0) / returns.length : 0
          );

          const perfData = avgReturns.map((avgReturn, index) => ({
            tradingDay: index + 1,
            avgReturn
          }));

          matchedPatterns.push({
            patternName: pattern.label,
            data: perfData,
            occurrences: occurrences.length,
            occurrenceDetails: occurrenceDetails
          });
        }
      }

      return matchedPatterns;
    } catch (error) {
      console.error('Error checking patterns:', error);
      return matchedPatterns;
    }
  };

  // Check RRG criteria (EXACT same logic as RRG Screener with SPY benchmark)
  const checkRRGCriteria = async (symbol: string): Promise<{ quadrant: string; dominantQuadrant: string; consistency: number; rsRatio: number; rsMomentum: number; timeframes: Record<string, string> }> => {
    const result = { quadrant: '', dominantQuadrant: '', consistency: 0, rsRatio: 0, rsMomentum: 0, timeframes: { '4w': '', '8w': '', '14w': '', '26w': '' } };

    try {
      const response = await fetch('/api/rrg-scan', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          symbols: [symbol],
          benchmark: 'SPY',
          batchIndex: 0,
          totalBatches: 1
        })
      });

      if (!response.ok) {
        console.error('RRG API error:', response.statusText);
        return result;
      }

      const data = await response.json();
      if (data.success && data.results && data.results.length > 0) {
        const rrgData = data.results[0];
        result.quadrant = rrgData.quadrant;
        result.dominantQuadrant = rrgData.dominantQuadrant;
        result.consistency = rrgData.consistency;
        result.rsRatio = rrgData.rsRatio;
        result.rsMomentum = rrgData.rsMomentum;
        result.timeframes = rrgData.timeframes;
      }

      return result;
    } catch (error) {
      console.error('Error checking RRG criteria:', error);
      return result;
    }
  };

  // Check HV criteria (EXACT same logic as HVScreener)
  const checkHVCriteria = async (symbol: string): Promise<{ hv10Day: boolean; hv20Day: boolean; hv52Week: boolean }> => {
    const result = { hv10Day: false, hv20Day: false, hv52Week: false };

    try {
      // Get historical data for all three periods
      const endDate = new Date().toISOString().split('T')[0];

      // 10-day HV: 90-day lookback
      const start10Day = new Date(Date.now() - (90 + 10 + 30) * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      // 20-day HV: 365-day lookback
      const start20Day = new Date(Date.now() - (365 + 20 + 30) * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      // 52-week HV: 1825-day (5-year) lookback
      const start52Week = new Date(Date.now() - (1825 + 252 + 30) * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

      // Fetch all data in parallel
      const [data10, data20, data52] = await Promise.all([
        polygonService.getHistoricalData(symbol, start10Day, endDate, 'day', 1),
        polygonService.getHistoricalData(symbol, start20Day, endDate, 'day', 1),
        polygonService.getHistoricalData(symbol, start52Week, endDate, 'day', 1)
      ]);

      // Check 10-day HV
      if (data10?.results && data10.results.length >= 20) {
        const prices = data10.results.map(r => r.c);
        const hvValues: number[] = [];

        for (let i = 10; i < prices.length; i++) {
          const periodPrices = prices.slice(i - 10, i + 1);
          const hv = calculateHV(periodPrices, 10);
          if (hv > 0) hvValues.push(hv);
        }

        if (hvValues.length > 0) {
          const currentHV = hvValues[hvValues.length - 1];
          const hvLow = Math.min(...hvValues);
          const percentFromLow = hvLow > 0 ? ((currentHV - hvLow) / hvLow) * 100 : 0;
          result.hv10Day = percentFromLow <= 20;
        }
      }

      // Check 20-day HV
      if (data20?.results && data20.results.length >= 40) {
        const prices = data20.results.map(r => r.c);
        const hvValues: number[] = [];

        for (let i = 20; i < prices.length; i++) {
          const periodPrices = prices.slice(i - 20, i + 1);
          const hv = calculateHV(periodPrices, 20);
          if (hv > 0) hvValues.push(hv);
        }

        if (hvValues.length > 0) {
          const currentHV = hvValues[hvValues.length - 1];
          const hvLow = Math.min(...hvValues);
          const percentFromLow = hvLow > 0 ? ((currentHV - hvLow) / hvLow) * 100 : 0;
          result.hv20Day = percentFromLow <= 20;
        }
      }

      // Check 52-week HV
      if (data52?.results && data52.results.length >= 504) {
        const prices = data52.results.map(r => r.c);
        const hvValues: number[] = [];

        for (let i = 252; i < prices.length; i++) {
          const periodPrices = prices.slice(i - 252, i + 1);
          const hv = calculateHV(periodPrices, 252);
          if (hv > 0) hvValues.push(hv);
        }

        if (hvValues.length > 0) {
          const currentHV = hvValues[hvValues.length - 1];
          const hvLow = Math.min(...hvValues);
          const percentFromLow = hvLow > 0 ? ((currentHV - hvLow) / hvLow) * 100 : 0;
          result.hv52Week = percentFromLow <= 20;
        }
      }

      return result;
    } catch (error) {
      console.error('Error checking HV criteria:', error);
      return result;
    }
  };

  // Build a Trade: Scan flow and grade with EFI Highlights logic
  const handleBuildTradeScan = async () => {
    if (!buildTradeTickerInput.trim()) return;

    const ticker = buildTradeTickerInput.trim().toUpperCase();

    setBuildTradeScanning(true);
    setBuildTradeScanProgress(null);
    setBuildTradeHVSignals({ hv10Day: false, hv20Day: false, hv52Week: false });
    setBuildTradeRRGSignal({ quadrant: '', dominantQuadrant: '', consistency: 0, rsRatio: 0, rsMomentum: 0, timeframes: { '4w': '', '8w': '', '14w': '', '26w': '' } });
    setBuildTradeMarketRegime([]);
    setBuildTradeExpectedRange(null);
    setBuildTradeEvents([]);
    setBuildTradePatterns([]);
    setBuildTradeIntensity(null);
    setBuildTradeStability(null);

    try {
      // Fetch seasonality data for sweet spot and pain point analysis
      try {
        console.log(`ðŸ” Fetching seasonality data for ${ticker}...`);

        // Try up to 20 years of data (max available)
        const yearsToTry = [20, 15, 10, 5];
        let seasonalData = null;

        for (const years of yearsToTry) {
          try {
            const endDate = new Date();
            const startDate = new Date();
            startDate.setFullYear(endDate.getFullYear() - years);

            const startDateStr = startDate.toISOString().split('T')[0];
            const endDateStr = endDate.toISOString().split('T')[0];

            const response = await fetch(`/api/seasonal-data?symbol=${ticker}&startDate=${startDateStr}&endDate=${endDateStr}`);

            if (response.ok) {
              const data = await response.json();
              if (data.dailyData && data.dailyData.length > 0) {
                seasonalData = data;
                console.log(`âœ… Got ${years} years of seasonality data for ${ticker}`);
                break;
              }
            }
          } catch (err) {
            console.log(`Failed to get ${years} years, trying less...`);
          }
        }

        if (seasonalData && seasonalData.dailyData) {
          // Analyze using EXACT same logic as SeasonalityChart
          const { bestSweetSpot, worstPainPoint } = analyzeLongTermPatterns(seasonalData.dailyData);

          setBuildTradeSweetSpot({
            period: bestSweetSpot.period,
            startDay: bestSweetSpot.startDay,
            endDay: bestSweetSpot.endDay,
            totalReturn: bestSweetSpot.totalReturn
          });

          setBuildTradePainPoint({
            period: worstPainPoint.period,
            startDay: worstPainPoint.startDay,
            endDay: worstPainPoint.endDay,
            totalReturn: worstPainPoint.totalReturn
          });

          console.log('ðŸ“Š Sweet Spot:', bestSweetSpot.period, `+${bestSweetSpot.totalReturn.toFixed(2)}%`);
          console.log('ðŸ“Š Pain Point:', worstPainPoint.period, `${worstPainPoint.totalReturn.toFixed(2)}%`);
        } else {
          console.log('âš ï¸ No seasonality data available');
          setBuildTradeSweetSpot(null);
          setBuildTradePainPoint(null);
        }
      } catch (err) {
        console.error('Failed to fetch seasonality:', err);
        setBuildTradeSweetSpot(null);
        setBuildTradePainPoint(null);
      }

      // Check HV criteria using EXACT same logic as HVScreener
      try {
        console.log(`ðŸ” Checking HV criteria for ${ticker}...`);
        const hvResults = await checkHVCriteria(ticker);
        setBuildTradeHVSignals(hvResults);

        const metCriteria = [];
        if (hvResults.hv10Day) metCriteria.push('10-day');
        if (hvResults.hv20Day) metCriteria.push('20-day');
        if (hvResults.hv52Week) metCriteria.push('52-week');

        if (metCriteria.length > 0) {
          console.log(`âœ… ${ticker} meets HV criteria: ${metCriteria.join(', ')}`);
        } else {
          console.log(`âš ï¸ ${ticker} does not meet any HV criteria`);
        }
      } catch (err) {
        console.error('Failed to check HV criteria:', err);
        setBuildTradeHVSignals({ hv10Day: false, hv20Day: false, hv52Week: false });
      }

      // Check RRG criteria using EXACT same logic as RRG Screener (SPY benchmark)
      try {
        console.log(`ðŸ” Checking RRG position for ${ticker}...`);
        const rrgResults = await checkRRGCriteria(ticker);
        setBuildTradeRRGSignal(rrgResults);

        if (rrgResults.dominantQuadrant) {
          console.log(`âœ… ${ticker} RRG: ${rrgResults.dominantQuadrant} (${rrgResults.consistency}/4 timeframes)`);
        } else {
          console.log(`âš ï¸ ${ticker} RRG data unavailable`);
        }
      } catch (err) {
        console.error('Failed to check RRG criteria:', err);
        setBuildTradeRRGSignal({ quadrant: '', dominantQuadrant: '', consistency: 0, rsRatio: 0, rsMomentum: 0, timeframes: { '4w': '', '8w': '', '14w': '', '26w': '' } });
      }

      // Check Market Regime status using EXACT same logic as Market Regimes panel
      try {
        console.log(`ðŸ” Checking Market Regime status for ${ticker}...`);
        const regimeResults = await checkMarketRegimeCriteria(ticker);
        setBuildTradeMarketRegime(regimeResults);

        if (regimeResults.length > 0) {
          console.log(`âœ… ${ticker} found in ${regimeResults.length} Market Regime timeframe(s): ${regimeResults.map(r => `${r.highlightType?.toUpperCase()} in ${r.timeframe}`).join(', ')}`);
        } else {
          console.log(`âš ï¸ ${ticker} not found in Market Regimes`);
        }
      } catch (err) {
        console.error('Failed to check Market Regime status:', err);
        setBuildTradeMarketRegime([]);
      }

      // Calculate Expected Range using EXACT same logic as Expected Range button
      try {
        console.log(`ðŸ“Š Calculating Expected Range for ${ticker}...`);
        const rangeData = await calculateExpectedRangeLevels(ticker);
        if (rangeData) {
          const { levels, marketData } = rangeData;
          setBuildTradeExpectedRange({
            weekly80Call: levels.weekly80Call,
            weekly90Call: levels.weekly90Call,
            weekly80Put: levels.weekly80Put,
            weekly90Put: levels.weekly90Put,
            monthly80Call: levels.monthly80Call,
            monthly90Call: levels.monthly90Call,
            monthly80Put: levels.monthly80Put,
            monthly90Put: levels.monthly90Put,
            currentPrice: marketData.currentPrice,
            weeklyIV: marketData.weeklyIV,
            monthlyIV: marketData.monthlyIV
          });
          console.log(`âœ… Expected Range calculated for ${ticker}`);
        } else {
          console.log(`âš ï¸ Failed to calculate Expected Range for ${ticker}`);
        }
      } catch (err) {
        console.error('Failed to calculate Expected Range:', err);
        setBuildTradeExpectedRange(null);
      }

      // Check for relevant Events within 1 month (EXACT same logic as Events button)
      try {
        console.log(`ðŸŽ¯ Checking for relevant events for ${ticker}...`);
        const eventsData = await checkEventsForTicker(ticker);
        setBuildTradeEvents(eventsData);
        if (eventsData.length > 0) {
          console.log(`âœ… Found ${eventsData.length} relevant event(s) for ${ticker}`);
        } else {
          console.log(`âš ï¸ No relevant events found for ${ticker}`);
        }
      } catch (err) {
        console.error('Failed to check events:', err);
        setBuildTradeEvents([]);
      }

      // Check for Pattern Analysis matches (EXACT same logic as Pattern Analysis)
      try {
        console.log(`ðŸ“ˆ Checking for pattern matches for ${ticker}...`);
        const patternsData = await checkPatternsForTicker(ticker);
        setBuildTradePatterns(patternsData);
        if (patternsData.length > 0) {
          console.log(`âœ… Found ${patternsData.length} pattern match(es) for ${ticker}`);
        } else {
          console.log(`âš ï¸ No recent pattern matches found for ${ticker}`);
        }
      } catch (err) {
        console.error('Failed to check patterns:', err);
        setBuildTradePatterns([]);
      }

      // Fetch GEX data for Intensity and Stability gauges (EXACT same as DealerAttraction)
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 seconds like DealerAttraction

        const response = await fetch(`/api/options-chain?ticker=${ticker}`, {
          signal: controller.signal,
          headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          setBuildTradeIntensity(null);
          setBuildTradeStability(null);
        } else {
          const result = await response.json();

          if (!result.success || !result.data) {
            setBuildTradeIntensity(null);
            setBuildTradeStability(null);
          } else {
            const currentPrice = result.currentPrice;
            const optionsData = result.data;

            if (!currentPrice || currentPrice <= 0) {
              setBuildTradeIntensity(null);
              setBuildTradeStability(null);
            } else {
              // === STABILITY INDEX (45-day window) ===
              const today = new Date();
              const maxDate45 = new Date(today.getTime() + (45 * 24 * 60 * 60 * 1000));
              const siExps = Object.keys(optionsData).filter(exp => {
                const expDate = new Date(exp + 'T00:00:00Z');
                return expDate >= today && expDate <= maxDate45;
              }).sort();

              // === INTENSITY GAUGE (45-day window, same as DealerAttraction mmExpirations) ===
              const mmExps = Object.keys(optionsData).filter(exp => {
                const expDate = new Date(exp + 'T00:00:00Z');
                return expDate >= today && expDate <= maxDate45;
              }).sort();

              if (siExps.length === 0 || mmExps.length === 0) {
                setBuildTradeIntensity(null);
                setBuildTradeStability(null);
              } else {
                // === STABILITY INDEX CALCULATION (45-day expirations) ===
                const gexByStrike: { [strike: number]: { call: number, put: number, callOI: number, putOI: number } } = {};
                const vexByStrike: { [strike: number]: { call: number, put: number } } = {};

                siExps.forEach(exp => {
                  const expData = optionsData[exp];

                  if (!expData?.calls || !expData?.puts) return;

                  const { calls, puts } = expData;
                  console.log(`  Calls strikes: ${Object.keys(calls).length}, Puts strikes: ${Object.keys(puts).length}`);

                  // Process calls - NO STRIKE FILTERING for SI
                  Object.entries(calls).forEach(([strike, data]: [string, any]) => {
                    const strikeNum = parseFloat(strike);
                    const oi = data.open_interest || 0;

                    if (oi > 0) {
                      if (!gexByStrike[strikeNum]) {
                        gexByStrike[strikeNum] = { call: 0, put: 0, callOI: 0, putOI: 0 };
                      }
                      if (!vexByStrike[strikeNum]) {
                        vexByStrike[strikeNum] = { call: 0, put: 0 };
                      }

                      gexByStrike[strikeNum].callOI += oi;

                      const gamma = data.greeks?.gamma || 0;
                      if (gamma) {
                        const gex = gamma * oi * (currentPrice * currentPrice) * 100;
                        gexByStrike[strikeNum].call += gex;
                      }

                      const vega = data.greeks?.vega || 0;
                      if (vega) {
                        const vex = vega * oi * 100;
                        vexByStrike[strikeNum].call += vex;
                      }
                    }
                  });

                  // Process puts - NO STRIKE FILTERING for SI
                  Object.entries(puts).forEach(([strike, data]: [string, any]) => {
                    const strikeNum = parseFloat(strike);
                    const oi = data.open_interest || 0;

                    if (oi > 0) {
                      if (!gexByStrike[strikeNum]) {
                        gexByStrike[strikeNum] = { call: 0, put: 0, callOI: 0, putOI: 0 };
                      }
                      if (!vexByStrike[strikeNum]) {
                        vexByStrike[strikeNum] = { call: 0, put: 0 };
                      }

                      gexByStrike[strikeNum].putOI += oi;

                      const gamma = data.greeks?.gamma || 0;
                      if (gamma) {
                        const gex = -gamma * oi * (currentPrice * currentPrice) * 100;
                        gexByStrike[strikeNum].put += gex;
                      }

                      const vega = data.greeks?.vega || 0;
                      if (vega) {
                        const vex = -vega * oi * 100;
                        vexByStrike[strikeNum].put += vex;
                      }
                    }
                  });
                });

                console.log(`ðŸ“Š Strikes processed: ${Object.keys(gexByStrike).length}`);

                // Calculate totals - EXACT same as DealerAttraction
                let totalGEX = 0;
                let totalVEX = 0;
                let totalDEX = 0;

                Object.entries(gexByStrike).forEach(([strike, data]) => {
                  const strikePrice = parseFloat(strike);

                  // Add GEX
                  totalGEX += data.call + data.put;

                  // Add VEX
                  if (vexByStrike[strikePrice]) {
                    totalVEX += vexByStrike[strikePrice].call + vexByStrike[strikePrice].put;
                  }

                  // Calculate DEX using moneyness approximation (EXACT same as DealerAttraction)
                  const callOI = data.callOI || 0;
                  const putOI = data.putOI || 0;

                  const moneyness = strikePrice / currentPrice;
                  let callDelta = 0;
                  let putDelta = 0;

                  if (moneyness > 1.05) {
                    callDelta = Math.max(0, Math.min(1, (moneyness - 1) * 2));
                  } else if (moneyness < 0.95) {
                    callDelta = Math.max(0, Math.min(1, 0.8 + (1 - moneyness) * 0.4));
                  } else {
                    callDelta = 0.5;
                  }

                  putDelta = callDelta - 1;

                  const callDEX = callDelta * callOI * 100 * currentPrice;
                  const putDEX = putDelta * putOI * 100 * currentPrice;

                  totalDEX += callDEX + putDEX;
                });

                console.log(`ðŸ’¹ Totals - GEX: ${totalGEX.toFixed(2)}, VEX: ${totalVEX.toFixed(2)}, DEX: ${totalDEX.toFixed(2)}`);

                // Calculate Stability Index (EXACT formula from DealerAttraction)
                const denominator = Math.abs(totalVEX) + Math.abs(totalDEX);
                let si = 0;
                let stability = 'NO DATA';
                let behavior = 'Insufficient options data';
                let stabilityColor = 'text-gray-400';

                if (denominator > 0) {
                  si = totalGEX / denominator;

                  // Classify stability (EXACT same thresholds as DealerAttraction)
                  if (si >= 2.0) {
                    stability = 'EXTREMELY STABLE';
                    behavior = 'GEX domination: Massive mean reversion pressure';
                    stabilityColor = 'text-blue-600';
                  } else if (si >= 0.5) {
                    stability = 'HIGHLY STABLE';
                    behavior = 'Strong GEX buffer: Gamma walls limiting price swings';
                    stabilityColor = 'text-blue-500';
                  } else if (si >= 0) {
                    stability = 'MILDLY SUPPORTIVE';
                    behavior = 'Balanced exposure: GEX provides modest support';
                    stabilityColor = 'text-green-500';
                  } else if (si >= -0.5) {
                    stability = 'VOLATILITY BUILDING';
                    behavior = 'VEX/DEX rising: Gamma protection eroding';
                    stabilityColor = 'text-yellow-500';
                  } else if (si >= -2.0) {
                    stability = 'REFLEXIVE MARKET';
                    behavior = 'Negative feedback loop: Moves beget more moves';
                    stabilityColor = 'text-orange-500';
                  } else {
                    stability = 'EXTREMELY REFLEXIVE';
                    behavior = 'VEX/DEX domination: Explosive potential both ways';
                    stabilityColor = 'text-red-600';
                  }
                }

                setBuildTradeStability({ si, stability, behavior, color: stabilityColor });

                // === INTENSITY GAUGE CALCULATION (3-month expirations, Â±20% strikes) ===
                let totalNetDelta = 0;
                let totalNetGamma = 0;
                let totalNetTheta = 0;
                let totalNetVega = 0;

                // Strike range filter for Intensity (Â±20%)
                const strikeRange = currentPrice * 0.20;
                const minStrike = currentPrice - strikeRange;
                const maxStrike = currentPrice + strikeRange;

                // Recalculate with DTE weighting like DealerAttraction
                mmExps.forEach(exp => {
                  const expData = optionsData[exp];
                  if (!expData?.calls || !expData?.puts) return;

                  // Calculate days to expiry
                  const expDate = new Date(exp + 'T00:00:00Z');
                  const today = new Date();
                  const daysToExp = Math.ceil((expDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
                  const dteWeight = daysToExp >= 0 ? (8 - Math.min(7, daysToExp)) / 7 : 1;

                  const { calls, puts } = expData;

                  // Process calls
                  Object.entries(calls).forEach(([strike, data]: [string, any]) => {
                    const strikePrice = parseFloat(strike);

                    // Filter strikes to Â±20% range (same as DealerAttraction)
                    if (strikePrice < minStrike || strikePrice > maxStrike) return;

                    const oi = data.open_interest || 0;

                    if (oi > 0) {
                      // Delta approximation based on moneyness
                      const moneyness = strikePrice / currentPrice;
                      let callDelta = 0;
                      if (moneyness > 1.1) { callDelta = 0.1; }
                      else if (moneyness > 1.05) { callDelta = 0.3; }
                      else if (moneyness > 1.0) { callDelta = 0.4; }
                      else if (moneyness > 0.95) { callDelta = 0.6; }
                      else if (moneyness > 0.9) { callDelta = 0.7; }
                      else { callDelta = 0.9; }

                      totalNetDelta += (callDelta * oi * 100) * dteWeight;

                      const gamma = data.greeks?.gamma || 0;
                      totalNetGamma += (gamma * oi) * dteWeight;

                      const theta = data.greeks?.theta || 0;
                      totalNetTheta += (theta * oi) * dteWeight;

                      const vega = data.greeks?.vega || 0;
                      totalNetVega += (vega * oi) * dteWeight;
                    }
                  });

                  // Process puts
                  Object.entries(puts).forEach(([strike, data]: [string, any]) => {
                    const strikePrice = parseFloat(strike);

                    // Filter strikes to Â±20% range (same as DealerAttraction)
                    if (strikePrice < minStrike || strikePrice > maxStrike) return;

                    const oi = data.open_interest || 0;

                    if (oi > 0) {
                      // Delta approximation based on moneyness
                      const moneyness = strikePrice / currentPrice;
                      let putDelta = 0;
                      if (moneyness > 1.1) { putDelta = -0.9; }
                      else if (moneyness > 1.05) { putDelta = -0.7; }
                      else if (moneyness > 1.0) { putDelta = -0.6; }
                      else if (moneyness > 0.95) { putDelta = -0.4; }
                      else if (moneyness > 0.9) { putDelta = -0.3; }
                      else { putDelta = -0.1; }

                      totalNetDelta += (putDelta * oi * 100) * dteWeight;

                      const gamma = data.greeks?.gamma || 0;
                      totalNetGamma += (gamma * oi) * dteWeight;

                      const theta = data.greeks?.theta || 0;
                      totalNetTheta += (theta * oi) * dteWeight;

                      const vega = data.greeks?.vega || 0;
                      totalNetVega += (vega * oi) * dteWeight;
                    }
                  });
                });

                // Normalize using EXACT same divisors as DealerAttraction
                const deltaScore = Math.max(-100, Math.min(100, totalNetDelta / 100000));
                const gammaScore = Math.max(-100, Math.min(100, totalNetGamma / 1000));
                const thetaScore = Math.max(-100, Math.min(100, totalNetTheta / 1000));
                const vegaScore = Math.max(-100, Math.min(100, totalNetVega / 1000));

                // Apply weights (EXACT same as DealerAttraction)
                const DELTA_WEIGHT = 0.30;
                const GAMMA_WEIGHT = 0.35;
                const THETA_WEIGHT = 0.20;
                const VEGA_WEIGHT = 0.15;

                const compositeScore = (
                  deltaScore * DELTA_WEIGHT +
                  gammaScore * GAMMA_WEIGHT +
                  thetaScore * THETA_WEIGHT +
                  vegaScore * VEGA_WEIGHT
                );

                // Classify signal (EXACT same thresholds as DealerAttraction)
                let signal = 'WAIT';
                let intensityColor = 'text-yellow-500';

                if (compositeScore > 3) {
                  signal = 'BUY SETUP';
                  intensityColor = 'text-green-600';
                } else if (compositeScore > 1) {
                  signal = 'LEAN BUY';
                  intensityColor = 'text-green-500';
                } else if (compositeScore >= -1) {
                  signal = 'WAIT';
                  intensityColor = 'text-yellow-500';
                } else if (compositeScore >= -3) {
                  signal = 'LEAN SELL';
                  intensityColor = 'text-orange-500';
                } else {
                  signal = 'SELL SETUP';
                  intensityColor = 'text-red-600';
                }

                setBuildTradeIntensity({ score: compositeScore, signal, color: intensityColor });

                console.log(`âœ… GAUGES COMPLETE!`);
                console.log(`   Intensity: ${signal} (Score: ${compositeScore.toFixed(2)})`);
                console.log(`   Stability: ${stability} (SI: ${si.toFixed(2)})`);
                console.log(`   State set - buildTradeIntensity:`, { score: compositeScore, signal, color: intensityColor });
                console.log(`   State set - buildTradeStability:`, { si, stability, behavior, color: stabilityColor });
              }
            }
          }
        }
      } catch (err) {
        console.error('âŒ Failed to calculate gauges:', err);
        console.error('Error stack:', err);
        setBuildTradeIntensity(null);
        setBuildTradeStability(null);
      }

      // Scan complete
      setBuildTradeScanning(false);
      setBuildTradeScanProgress(null);

    } catch (error) {
      setBuildTradeScanning(false);
    }
  };

  // EXACT Sweet Spot and Pain Point analysis from SeasonalityChart
  const analyzeLongTermPatterns = (dailyData: any[]) => {
    let bestSweetSpot = { startDay: 1, endDay: 50, avgReturn: -999, period: '', totalReturn: 0 };
    let worstPainPoint = { startDay: 1, endDay: 50, avgReturn: 999, period: '', totalReturn: 0 };

    // Test different window sizes from 50 to 90 days
    for (let windowSize = 50; windowSize <= 90; windowSize++) {
      // Slide through the year
      for (let startDay = 1; startDay <= 365 - windowSize; startDay++) {
        const endDay = startDay + windowSize - 1;
        const windowData = dailyData.filter((d: any) => d.dayOfYear >= startDay && d.dayOfYear <= endDay);

        if (windowData.length >= Math.floor(windowSize * 0.8)) { // Ensure we have at least 80% of data points
          // Calculate cumulative return for the period
          const sortedWindowData = windowData.sort((a: any, b: any) => a.dayOfYear - b.dayOfYear);
          let cumulativeReturn = 0;
          let avgReturn = 0;

          sortedWindowData.forEach((d: any) => {
            cumulativeReturn += d.avgReturn;
            avgReturn += d.avgReturn;
          });

          avgReturn = avgReturn / sortedWindowData.length;

          // Check for best sweet spot
          if (cumulativeReturn > bestSweetSpot.totalReturn) {
            const startDataPoint = dailyData.find((d: any) => d.dayOfYear === startDay);
            const endDataPoint = dailyData.find((d: any) => d.dayOfYear === endDay);

            if (startDataPoint && endDataPoint) {
              bestSweetSpot = {
                startDay,
                endDay,
                avgReturn,
                totalReturn: cumulativeReturn,
                period: `${startDataPoint.monthName} ${startDataPoint.day} - ${endDataPoint.monthName} ${endDataPoint.day} (${windowSize} days)`
              };
            }
          }

          // Check for worst pain point
          if (cumulativeReturn < worstPainPoint.totalReturn) {
            const startDataPoint = dailyData.find((d: any) => d.dayOfYear === startDay);
            const endDataPoint = dailyData.find((d: any) => d.dayOfYear === endDay);

            if (startDataPoint && endDataPoint) {
              worstPainPoint = {
                startDay,
                endDay,
                avgReturn,
                totalReturn: cumulativeReturn,
                period: `${startDataPoint.monthName} ${startDataPoint.day} - ${endDataPoint.monthName} ${endDataPoint.day} (${windowSize} days)`
              };
            }
          }
        }
      }
    }

    return { bestSweetSpot, worstPainPoint };
  };

  // EFI Highlights criteria checker - EXACT from OptionsFlowTable
  const meetsEfiCriteria = (trade: any): boolean => {
    if (trade.days_to_expiry < 0 || trade.days_to_expiry > 35) return false;
    if (trade.total_premium < 100000 || trade.total_premium > 450000) return false;
    if (trade.trade_size < 650 || trade.trade_size > 1999) return false;
    if (!trade.moneyness || trade.moneyness !== 'OTM') return false;
    return true;
  };

  // Calculate positioning grade - USES SAME LOGIC AS OptionsFlowTable
  const calculatePositioningGrade = (
    trade: any,
    allTrades: any[],
    currentStockPrices: Record<string, number>,
    historicalStdDevs: Map<string, number>,
    currentOptionPrices: Record<string, number>
  ): {
    grade: string;
    score: number;
    color: string;
  } => {
    // Get option ticker for current price lookup
    const expiry = trade.expiry.replace(/-/g, '').slice(2);
    const strikeFormatted = String(Math.round(trade.strike * 1000)).padStart(8, '0');
    const optionType = trade.type.toLowerCase() === 'call' ? 'C' : 'P';
    const optionTicker = `O:${trade.underlying_ticker}${expiry}${optionType}${strikeFormatted}`;
    const currentPrice = currentOptionPrices[optionTicker];
    const entryPrice = trade.premium_per_contract;

    let confidenceScore = 0;
    const scores = {
      expiration: 0,
      contractPrice: 0,
      combo: 0,
      priceAction: 0,
      stockReaction: 0
    };

    // 1. Expiration Score (25 points max)
    const daysToExpiry = trade.days_to_expiry;
    if (daysToExpiry <= 7) scores.expiration = 25;
    else if (daysToExpiry <= 14) scores.expiration = 20;
    else if (daysToExpiry <= 21) scores.expiration = 15;
    else if (daysToExpiry <= 28) scores.expiration = 10;
    else if (daysToExpiry <= 42) scores.expiration = 5;
    confidenceScore += scores.expiration;

    // 2. Contract Price Score (25 points max) - based on position P&L
    if (!currentPrice || currentPrice <= 0) {
      throw new Error(`Missing current option price for ${trade.underlying_ticker} ${trade.type} $${trade.strike}`);
    }

    const percentChange = ((currentPrice - entryPrice) / entryPrice) * 100;

    if (percentChange <= -40) scores.contractPrice = 25;
    else if (percentChange <= -20) scores.contractPrice = 20;
    else if (percentChange >= -10 && percentChange <= 10) scores.contractPrice = 15;
    else if (percentChange >= 20) scores.contractPrice = 5;
    else scores.contractPrice = 10;

    confidenceScore += scores.contractPrice;

    // 3. Combo Trade Score (10 points max)
    const isCall = trade.type === 'call';
    const fillStyle = trade.fill_style || '';
    const hasComboTrade = allTrades.some(t => {
      if (t.underlying_ticker !== trade.underlying_ticker) return false;
      if (t.expiry !== trade.expiry) return false;
      if (Math.abs(t.strike - trade.strike) > trade.strike * 0.05) return false;

      const oppositeFill = t.fill_style || '';
      const oppositeType = t.type.toLowerCase();

      // Bullish combo: Calls with A/AA + Puts with B/BB
      if (isCall && (fillStyle === 'A' || fillStyle === 'AA')) {
        return oppositeType === 'put' && (oppositeFill === 'B' || oppositeFill === 'BB');
      }
      // Bearish combo: Calls with B/BB + Puts with A/AA
      if (isCall && (fillStyle === 'B' || fillStyle === 'BB')) {
        return oppositeType === 'put' && (oppositeFill === 'A' || oppositeFill === 'AA');
      }
      // For puts, reverse logic
      if (!isCall && (fillStyle === 'B' || fillStyle === 'BB')) {
        return oppositeType === 'call' && (oppositeFill === 'A' || oppositeFill === 'AA');
      }
      if (!isCall && (fillStyle === 'A' || fillStyle === 'AA')) {
        return oppositeType === 'call' && (oppositeFill === 'B' || oppositeFill === 'BB');
      }
      return false;
    });
    if (hasComboTrade) scores.combo = 10;
    confidenceScore += scores.combo;

    // Shared variables for sections 4 and 5
    const entryStockPrice = trade.spot_price;
    const currentStockPrice = currentStockPrices[trade.underlying_ticker];
    const tradeTime = new Date(trade.trade_timestamp);
    const currentTime = new Date();

    // 4. Price Action Score (25 points max) - Stock within standard deviation
    const stdDev = historicalStdDevs.get(trade.underlying_ticker);

    if (!currentStockPrice || !entryStockPrice || !stdDev) {
      throw new Error(`Missing price action data for ${trade.underlying_ticker}`);
    }

    const hoursElapsed = (currentTime.getTime() - tradeTime.getTime()) / (1000 * 60 * 60);
    const tradingDaysElapsed = Math.floor(hoursElapsed / 6.5); // 6.5-hour trading day

    // Calculate current stock move in percentage
    const stockPercentChange = ((currentStockPrice - entryStockPrice) / entryStockPrice) * 100;
    const absMove = Math.abs(stockPercentChange);

    // Check if stock is within 1 standard deviation
    const withinStdDev = absMove <= stdDev;

    // Award points based on how many days stock stayed within std dev
    if (withinStdDev && tradingDaysElapsed >= 3) scores.priceAction = 25;
    else if (withinStdDev && tradingDaysElapsed >= 2) scores.priceAction = 20;
    else if (withinStdDev && tradingDaysElapsed >= 1) scores.priceAction = 15;
    else scores.priceAction = 10;

    confidenceScore += scores.priceAction;

    // 5. Stock Reaction Score (15 points max)
    // Measure stock movement 1 hour and 3 hours after trade placement
    if (currentStockPrice && entryStockPrice) {
      const stockPercentChange = ((currentStockPrice - entryStockPrice) / entryStockPrice) * 100;

      // Determine trade direction (bullish or bearish)
      const isBullish = (isCall && (fillStyle === 'A' || fillStyle === 'AA')) ||
        (!isCall && (fillStyle === 'B' || fillStyle === 'BB'));
      const isBearish = (isCall && (fillStyle === 'B' || fillStyle === 'BB')) ||
        (!isCall && (fillStyle === 'A' || fillStyle === 'AA'));

      // Check if stock reversed against trade direction
      const reversed = (isBullish && stockPercentChange <= -1.0) ||
        (isBearish && stockPercentChange >= 1.0);
      const followed = (isBullish && stockPercentChange >= 1.0) ||
        (isBearish && stockPercentChange <= -1.0);
      const chopped = Math.abs(stockPercentChange) < 1.0;

      // Calculate time elapsed since trade
      const hoursElapsed = (currentTime.getTime() - tradeTime.getTime()) / (1000 * 60 * 60);

      // Award points based on time checkpoints
      if (hoursElapsed >= 1) {
        // 1-hour checkpoint (50% of points)
        if (reversed) scores.stockReaction += 7.5;
        else if (chopped) scores.stockReaction += 5;
        else if (followed) scores.stockReaction += 2.5;

        if (hoursElapsed >= 3) {
          // 3-hour checkpoint (remaining 50%)
          if (reversed) scores.stockReaction += 7.5;
          else if (chopped) scores.stockReaction += 5;
          else if (followed) scores.stockReaction += 2.5;
        }
      }
    }
    confidenceScore += scores.stockReaction;

    // Color code confidence score
    let scoreColor = '#ff0000'; // F = Red
    if (confidenceScore >= 85) scoreColor = '#00ff00'; // A = Bright Green
    else if (confidenceScore >= 70) scoreColor = '#84cc16'; // B = Lime Green
    else if (confidenceScore >= 50) scoreColor = '#fbbf24'; // C = Yellow
    else if (confidenceScore >= 33) scoreColor = '#3b82f6'; // D = Blue

    // Grade letter
    let grade = 'F';
    if (confidenceScore >= 85) grade = 'A+';
    else if (confidenceScore >= 80) grade = 'A';
    else if (confidenceScore >= 75) grade = 'A-';
    else if (confidenceScore >= 70) grade = 'B+';
    else if (confidenceScore >= 65) grade = 'B';
    else if (confidenceScore >= 60) grade = 'B-';
    else if (confidenceScore >= 55) grade = 'C+';
    else if (confidenceScore >= 50) grade = 'C';
    else if (confidenceScore >= 48) grade = 'C-';
    else if (confidenceScore >= 43) grade = 'D+';
    else if (confidenceScore >= 38) grade = 'D';
    else if (confidenceScore >= 33) grade = 'D-';

    return { grade, score: confidenceScore, color: scoreColor };
  };

  // Switch regime tabs instantly from cache
  useEffect(() => {
    // Build MarketRegimeData from ALL cached TimeframeAnalysis
    const fullData: any = {
      life: regimeDataCache['life'] || null,
      developing: regimeDataCache['developing'] || null,
      momentum: regimeDataCache['momentum'] || null,
      legacy: regimeDataCache['legacy'] || null
    };

    // Only update if we have at least one timeframe loaded
    if (fullData.life || fullData.developing || fullData.momentum || fullData.legacy) {
      setMarketRegimeData(fullData as MarketRegimeData);
    }
  }, [regimeDataCache]);

  // Prefetch ALL regime tabs in parallel when panel opens
  useEffect(() => {
    if (activeSidebarPanel === 'regimes' && !allRegimesLoaded && Object.keys(regimeDataCache).length === 0) {
      const fetchAllRegimes = async () => {
        console.log('ðŸš€ Parallel prefetch: Life + Developing + Momentum + Legacy');
        setIsLoadingRegimes(true);
        setRegimeLoadingStage('Loading all regimes in parallel...');

        const tabConfigs = [
          { tab: 'life', days: 5 },
          { tab: 'developing', days: 21 },
          { tab: 'momentum', days: 80 },
          { tab: 'legacy', days: 252 }
        ];

        const results = await Promise.allSettled(
          tabConfigs.map(({ tab, days }) =>
            IndustryAnalysisService.analyzeTimeframe(days, tab.charAt(0).toUpperCase() + tab.slice(1))
              .then(data => ({ tab, data }))
              .catch(err => ({ tab, data: null, error: err }))
          )
        );

        const newCache: { [key: string]: TimeframeAnalysis } = {};
        results.forEach((result) => {
          if (result.status === 'fulfilled' && result.value.data) {
            // Store TimeframeAnalysis directly
            newCache[result.value.tab] = result.value.data;
            const bullish = result.value.data.industries?.filter((i: any) => i.trend === 'bullish').length || 0;
            const bearish = result.value.data.industries?.filter((i: any) => i.trend === 'bearish').length || 0;
            console.log(`âœ… ${result.value.tab}: ${bullish}B/${bearish}B industries`);
          }
        });

        setRegimeDataCache(newCache);

        // Build full MarketRegimeData with ALL timeframes
        const fullData: any = {
          life: newCache['life'] || null,
          developing: newCache['developing'] || null,
          momentum: newCache['momentum'] || null,
          legacy: newCache['legacy'] || null
        };
        setMarketRegimeData(fullData as MarketRegimeData);

        setAllRegimesLoaded(true);
        setIsLoadingRegimes(false);
        setLastRegimeUpdate(Date.now());
      };

      fetchAllRegimes();
    }
  }, [activeSidebarPanel, allRegimesLoaded, regimeDataCache, regimesTab]);

  // Load Market Regimes immediately on page load (background prefetch)
  useEffect(() => {
    if (allRegimesLoaded || Object.keys(regimeDataCache).length > 0) {
      return; // Already loaded
    }

    const fetchAllRegimes = async () => {
      setIsLoadingRegimes(true);

      const tabConfigs = [
        { tab: 'life', days: 5 },
        { tab: 'developing', days: 21 },
        { tab: 'momentum', days: 80 },
        { tab: 'legacy', days: 252 }
      ];

      const results = await Promise.allSettled(
        tabConfigs.map(({ tab, days }) =>
          IndustryAnalysisService.analyzeTimeframe(days, tab.charAt(0).toUpperCase() + tab.slice(1))
            .then(data => ({ tab, data }))
            .catch(err => ({ tab, data: null, error: err }))
        )
      );

      const newCache: { [key: string]: TimeframeAnalysis } = {};
      results.forEach((result) => {
        if (result.status === 'fulfilled' && result.value.data) {
          newCache[result.value.tab] = result.value.data;
        }
      });

      setRegimeDataCache(newCache);

      const fullData: any = {
        life: newCache['life'] || null,
        developing: newCache['developing'] || null,
        momentum: newCache['momentum'] || null,
        legacy: newCache['legacy'] || null
      };
      setMarketRegimeData(fullData as MarketRegimeData);

      setAllRegimesLoaded(true);
      setIsLoadingRegimes(false);
      setLastRegimeUpdate(Date.now());
    };

    fetchAllRegimes();
  }, []); // Run once on mount

  // AI Trade Highlighting System - Clean Implementation with per-tab caching
  const [highlightedTrades, setHighlightedTrades] = useState<Record<string, any>>({});
  const [highlightedTradesCache, setHighlightedTradesCache] = useState<{ [key: string]: Record<string, any> }>({});
  const [selectedTradeForModal, setSelectedTradeForModal] = useState<any>(null);
  const [showTradeModal, setShowTradeModal] = useState(false);
  const [expandedScoreComponent, setExpandedScoreComponent] = useState<string | null>(null);
  const [isCalculatingTrades, setIsCalculatingTrades] = useState(false);

  // Scroll position preservation for RegimesPanel
  const regimesPanelScrollRef = useRef<HTMLDivElement>(null);
  const savedRegimesScrollPos = useRef<number>(0);

  // Scroll position preservation for Screeners Panel
  const screenersPanelScrollRef = useRef<HTMLDivElement>(null);
  const savedScreenersScrollPos = useRef<number>(0);

  // Scroll position preservation for News Panel
  const newsPanelScrollRef = useRef<HTMLDivElement>(null);
  const savedNewsScrollPos = useRef<number>(0);

  // Scroll position preservation for Alerts Panel
  const alertsPanelScrollRef = useRef<HTMLDivElement>(null);
  const savedAlertsScrollPos = useRef<number>(0);

  // Expected Range state for probability levels
  const [expectedRangeLevels, setExpectedRangeLevels] = useState<any>(null);
  const [isLoadingExpectedRange, setIsLoadingExpectedRange] = useState(false);
  const [isExpectedRangeActive, setIsExpectedRangeActive] = useState(false);
  const [isExpectedRangeDropdownOpen, setIsExpectedRangeDropdownOpen] = useState(false);
  const [expectedRangeType, setExpectedRangeType] = useState<'weekly' | 'monthly' | 'custom'>('weekly');
  const [isWeeklyActive, setIsWeeklyActive] = useState(false);
  const [isMonthlyActive, setIsMonthlyActive] = useState(false);
  const [isCustomActive, setIsCustomActive] = useState(false);
  const [customExpirationDate, setCustomExpirationDate] = useState<string>('');
  const [pendingCustomDate, setPendingCustomDate] = useState<string>('');
  const [showCustomDatePicker, setShowCustomDatePicker] = useState(false);

  // Seasonal state
  const [isSeasonalDropdownOpen, setIsSeasonalDropdownOpen] = useState(false);

  // Restore scroll positions for all sidebar panels on every render
  useLayoutEffect(() => {
    if (screenersPanelScrollRef.current && savedScreenersScrollPos.current > 0) {
      screenersPanelScrollRef.current.scrollTop = savedScreenersScrollPos.current;
    }
  });

  useLayoutEffect(() => {
    if (newsPanelScrollRef.current && savedNewsScrollPos.current > 0) {
      newsPanelScrollRef.current.scrollTop = savedNewsScrollPos.current;
    }
  });

  useLayoutEffect(() => {
    if (alertsPanelScrollRef.current && savedAlertsScrollPos.current > 0) {
      alertsPanelScrollRef.current.scrollTop = savedAlertsScrollPos.current;
    }
  });
  const [isSeasonalActive, setIsSeasonalActive] = useState(false);
  const [isSeasonal20YActive, setIsSeasonal20YActive] = useState(false);
  const [isSeasonal15YActive, setIsSeasonal15YActive] = useState(false);
  const [isSeasonal10YActive, setIsSeasonal10YActive] = useState(false);
  const [isSeasonalElectionActive, setIsSeasonalElectionActive] = useState(false);
  const seasonalButtonRef = useRef<HTMLButtonElement>(null);
  const [seasonalProjectionData, setSeasonalProjectionData] = useState<Array<{ date: Date, price: number }> | null>(null);
  const [seasonal20YData, setSeasonal20YData] = useState<Array<{ date: Date, price: number }> | null>(null);
  const [seasonal15YData, setSeasonal15YData] = useState<Array<{ date: Date, price: number }> | null>(null);
  const [seasonal10YData, setSeasonal10YData] = useState<Array<{ date: Date, price: number }> | null>(null);
  const [seasonalElectionData, setSeasonalElectionData] = useState<Array<{ date: Date, price: number }> | null>(null);
  const [isLoadingSeasonalProjection, setIsLoadingSeasonalProjection] = useState(false);
  const [isSeasonalEventActive, setIsSeasonalEventActive] = useState(false);
  const [selectedSeasonalEvent, setSelectedSeasonalEvent] = useState<string | null>(null);
  const [seasonalEventData, setSeasonalEventData] = useState<Array<{ date: Date, price: number }> | null>(null);
  const [isEventDropdownOpen, setIsEventDropdownOpen] = useState(false);

  // Event seasonal calculation with Polygon API
  const calculateEventSeasonal = useCallback(async (eventType: string, chartData: ChartDataPoint[]) => {
    console.log('ðŸŽ¯ Event seasonal triggered for:', eventType);
    const API_KEY = 'kjZ4aLJbqHsEhWGOjWMBthMvwDLKd4wf';
    const currentYear = new Date().getFullYear();

    const getEventDates = (event: string): Date[] => {
      const dates: Date[] = [];
      // Include past 5 years + current year + next year for future projections
      for (let year = currentYear - 5; year <= currentYear + 1; year++) {
        switch (event) {
          case 'thanksgiving':
            const nov1 = new Date(year, 10, 1);
            const firstThursday = (4 - nov1.getDay() + 7) % 7 + 1;
            dates.push(new Date(year, 10, firstThursday + 21));
            break;
          case 'christmas':
            dates.push(new Date(year, 11, 25));
            break;
          case 'newyear':
            dates.push(new Date(year, 0, 1));
            break;
          case 'presidentsday':
            const feb1 = new Date(year, 1, 1);
            const firstMonday = (1 - feb1.getDay() + 7) % 7 + 1;
            dates.push(new Date(year, 1, firstMonday + 14));
            break;
          case 'mlkday':
            const jan1 = new Date(year, 0, 1);
            const firstMondayJan = (1 - jan1.getDay() + 7) % 7 + 1;
            dates.push(new Date(year, 0, firstMondayJan + 14));
            break;
          case 'memorialday':
            const may31 = new Date(year, 4, 31);
            const lastMonday = 31 - ((may31.getDay() + 6) % 7);
            dates.push(new Date(year, 4, lastMonday));
            break;
          case 'july4th':
            dates.push(new Date(year, 6, 4));
            break;
          case 'laborday':
            const sep1 = new Date(year, 8, 1);
            const firstMondaySep = (1 - sep1.getDay() + 7) % 7 + 1;
            dates.push(new Date(year, 8, firstMondaySep));
            break;
          case 'quad-witching-mar':
            const mar1 = new Date(year, 2, 1);
            const firstFridayMar = (5 - mar1.getDay() + 7) % 7 + 1;
            dates.push(new Date(year, 2, firstFridayMar + 14));
            break;
          case 'quad-witching-jun':
            const jun1 = new Date(year, 5, 1);
            const firstFridayJun = (5 - jun1.getDay() + 7) % 7 + 1;
            dates.push(new Date(year, 5, firstFridayJun + 14));
            break;
          case 'quad-witching-sep':
            const sep1qw = new Date(year, 8, 1);
            const firstFridaySep = (5 - sep1qw.getDay() + 7) % 7 + 1;
            dates.push(new Date(year, 8, firstFridaySep + 14));
            break;
          case 'quad-witching-dec':
            const dec1 = new Date(year, 11, 1);
            const firstFridayDec = (5 - dec1.getDay() + 7) % 7 + 1;
            dates.push(new Date(year, 11, firstFridayDec + 14));
            break;
          case 'monthlyopex':
            const today = new Date();
            const month1 = new Date(year, today.getMonth(), 1);
            const firstFridayMonth = (5 - month1.getDay() + 7) % 7 + 1;
            dates.push(new Date(year, today.getMonth(), firstFridayMonth + 14));
            break;
          case 'yearendrally':
            dates.push(new Date(year, 11, 31));
            break;
          case 'halloweenrally':
            dates.push(new Date(year, 9, 31));
            break;
          case 'santarally':
            dates.push(new Date(year, 11, 20));
            break;
          case 'q1-earnings':
            dates.push(new Date(year, 3, 15));
            break;
          case 'q2-earnings':
            dates.push(new Date(year, 6, 15));
            break;
          case 'q3-earnings':
            dates.push(new Date(year, 9, 15));
            break;
          case 'q4-earnings':
            dates.push(new Date(year, 0, 15));
            break;
        }
      }
      return dates;
    };

    const isWeekend = (date: Date) => date.getDay() === 0 || date.getDay() === 6;

    const isHoliday = (date: Date) => {
      const month = date.getMonth(), day = date.getDate(), dayOfWeek = date.getDay();
      if (month === 0 && day === 1) return true;
      if (month === 6 && day === 4) return true;
      if (month === 11 && day === 25) return true;
      if (month === 0 && dayOfWeek === 1 && day >= 15 && day <= 21) return true;
      if (month === 1 && dayOfWeek === 1 && day >= 15 && day <= 21) return true;
      if (month === 4 && dayOfWeek === 1 && day >= 25) return true;
      if (month === 8 && dayOfWeek === 1 && day <= 7) return true;
      if (month === 10 && dayOfWeek === 4 && day >= 22 && day <= 28) return true;
      return false;
    };

    const getTradingDays = (startDate: Date, count: number, forward: boolean): Date[] => {
      const days: Date[] = [];
      const current = new Date(startDate);
      let found = 0;
      while (found < count) {
        current.setDate(current.getDate() + (forward ? 1 : -1));
        if (!isWeekend(current) && !isHoliday(current)) {
          days.push(new Date(current));
          found++;
        }
      }
      return forward ? days : days.reverse();
    };

    try {
      const eventDates = getEventDates(eventType);
      console.log('ðŸ“… Event dates found:', eventDates.length, eventDates);

      // Earnings events use 10 days before and 10 after, others use 5 before and 7 after
      const isEarnings = eventType.includes('earnings');
      const daysBefore = isEarnings ? 10 : 5;
      const daysAfter = isEarnings ? 10 : 7;
      const totalPoints = daysBefore + 1 + daysAfter; // before + event + after
      const eventIndex = daysBefore; // Event is at index equal to days before

      console.log(`ðŸ“Š Event type: ${eventType}, Days: ${daysBefore} before + event + ${daysAfter} after = ${totalPoints} total`);

      const allReturns: number[][] = Array(totalPoints).fill(0).map(() => []);

      for (const eventDate of eventDates) {
        const before = getTradingDays(eventDate, daysBefore, false);
        const after = getTradingDays(eventDate, daysAfter, true);
        const allDays = [...before, eventDate, ...after];

        const from = allDays[0].toISOString().split('T')[0];
        const to = allDays[allDays.length - 1].toISOString().split('T')[0];

        console.log(`ðŸ“¡ Fetching ${symbol} from ${from} to ${to}`);
        const response = await fetch(
          `https://api.polygon.io/v2/aggs/ticker/${symbol}/range/1/day/${from}/${to}?adjusted=true&sort=asc&apiKey=${API_KEY}`
        );

        if (!response.ok) {
          console.warn('âš ï¸ API response not ok:', response.status);
          continue;
        }
        const data = await response.json();
        if (!data.results || data.results.length === 0) {
          console.warn('âš ï¸ No data results for', from, to);
          continue;
        }

        console.log('âœ… Got', data.results.length, 'data points');
        const prices = data.results.map((r: any) => r.c);

        // Need at least eventIndex+1 data points to calculate returns
        const minRequired = eventIndex + 1;
        if (prices.length < minRequired) {
          console.warn(`âš ï¸ Skipping year - insufficient data. Need ${minRequired}+ points, got`, prices.length);
          continue;
        }

        const eventPrice = prices[eventIndex];

        if (!eventPrice) {
          console.warn('âš ï¸ Skipping year - no event price at index', eventIndex);
          continue;
        }

        // Calculate returns for all points relative to event price
        for (let i = 0; i < prices.length && i < totalPoints; i++) {
          const returnPct = ((prices[i] - eventPrice) / eventPrice) * 100;
          allReturns[i].push(returnPct);
        }
      }

      const avgReturns = allReturns.map(returns =>
        returns.length > 0 ? returns.reduce((a, b) => a + b, 0) / returns.length : 0
      );

      console.log(`ðŸ“Š Average returns (${daysBefore} before, event, ${daysAfter} after):`, avgReturns);
      console.log('ðŸ“Š All returns data for each point:');
      allReturns.forEach((returns, idx) => {
        console.log(`   Point ${idx + 1}: ${returns.length} samples, avg=${avgReturns[idx].toFixed(4)}%`);
      });

      const lastPrice = chartData.length > 0 ? chartData[chartData.length - 1]?.close : 0;
      console.log('ðŸ’° Last price:', lastPrice, 'from data with', chartData.length, 'points');
      console.log('ðŸ’° Chart data sample:', chartData.slice(-3).map(d => ({ date: d.timestamp, close: d.close })));

      // Find closest event date to today (prefer recent past or near future, not a year away)
      const allEventDates = getEventDates(eventType);
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Find event closest to today (within +/- 30 days is reasonable for projection)
      let closestEvent = allEventDates[0];
      let minDiff = Math.abs(allEventDates[0].getTime() - today.getTime());

      for (const eventDate of allEventDates) {
        const diff = Math.abs(eventDate.getTime() - today.getTime());
        if (diff < minDiff) {
          minDiff = diff;
          closestEvent = eventDate;
        }
      }

      // If closest event is more than 60 days away, use the most recent past event
      const daysDiff = (closestEvent.getTime() - today.getTime()) / (1000 * 60 * 60 * 24);
      if (daysDiff > 60) {
        // Find most recent past event
        const pastEvents = allEventDates.filter(d => d < today);
        if (pastEvents.length > 0) {
          closestEvent = pastEvents[pastEvents.length - 1];
        }
      }

      console.log('ðŸ“† Selected event date:', closestEvent.toISOString().split('T')[0], '(days from today:', Math.round(daysDiff), ')');

      // Create projection starting from daysBefore trading days before event to daysAfter trading days after
      const projectionData: Array<{ date: Date, price: number }> = [];
      const beforeDays = getTradingDays(closestEvent, daysBefore, false);
      const afterDays = getTradingDays(closestEvent, daysAfter, true);
      const projectionDates = [...beforeDays, closestEvent, ...afterDays];

      console.log('ðŸ”¢ PROJECTION DATES - Total:', projectionDates.length);
      console.log(`  ðŸ“… ${daysBefore} Days Before:`, beforeDays.map(d => d.toISOString().split('T')[0]));
      console.log('  ðŸ“… Event Date:', closestEvent.toISOString().split('T')[0]);
      console.log(`  ðŸ“… ${daysAfter} Days After:`, afterDays.map(d => d.toISOString().split('T')[0]));

      for (let i = 0; i < avgReturns.length && i < projectionDates.length; i++) {
        const returnPct = avgReturns[i];
        const projectedPrice = lastPrice * (1 + returnPct / 100);
        console.log(`  ðŸ” Point ${i + 1}: avgReturn=${returnPct.toFixed(4)}%, lastPrice=${lastPrice}, calc=${lastPrice} * (1 + ${returnPct}/100) = ${projectedPrice.toFixed(2)}`);
        projectionData.push({ date: projectionDates[i], price: projectedPrice });
      }

      console.log('ðŸŽ¯ Projection data created:', projectionData.length, 'points from', projectionDates[0].toISOString().split('T')[0], 'to', projectionDates[projectionDates.length - 1].toISOString().split('T')[0]);
      setSeasonalEventData(projectionData);
      setIsSeasonalEventActive(true);
      setIsSeasonalActive(true);
      console.log('âœ… States set - isSeasonalEventActive: true');

    } catch (error) {
      console.error('âŒ Event seasonal calculation failed:', error);
      setSeasonalEventData(null);
      setIsSeasonalEventActive(false);
    }
  }, [symbol]);

  // GEX state for gamma exposure levels
  const [isGexActive, setIsGexActive] = useState(false);
  const [isGexLoading, setIsGexLoading] = useState(false);
  const [gexProgress, setGexProgress] = useState(0);
  const [liveGexData, setLiveGexData] = useState<any>(null);
  const [gexMode, setGexMode] = useState<'live' | 'oi'>('oi'); // 'live' scans flow, 'oi' uses Polygon data
  const [isGexDropdownOpen, setIsGexDropdownOpen] = useState(false);
  const [isLiveGexActive, setIsLiveGexActive] = useState(false);
  const [isOiGexActive, setIsOiGexActive] = useState(false);

  // GEX data hook - ONLY fetch when mode is 'oi', NOT for 'live' mode
  const { data: gexData, loading: isLoadingGex, error: gexError } = useGEXData(
    symbol,
    isGexActive && gexMode === 'oi' // Only auto-refresh when OI GEX is active
  );

  // IV & HV Indicator state - TradingView style bottom panel indicators
  const [isIVHVDropdownOpen, setIsIVHVDropdownOpen] = useState(false);
  const [isIVLoading, setIsIVLoading] = useState(false);
  const [ivProgress, setIVProgress] = useState(0);
  const ivhvButtonRef = useRef<HTMLButtonElement>(null);

  // Main IV Panel toggle - shows the IV panel with line toggles inside
  const [showIVPanel, setShowIVPanel] = useState(false);
  // Individual IV line toggles (controlled within the panel, not dropdown)
  const [showCallIVLine, setShowCallIVLine] = useState(true); // Default to showing Call IV
  const [showPutIVLine, setShowPutIVLine] = useState(true); // Default to showing Put IV
  const [showNetIVLine, setShowNetIVLine] = useState(false); // Net IV off by default
  const [showIVRankIndicator, setShowIVRankIndicator] = useState(false);
  const [showIVPercentileIndicator, setShowIVPercentileIndicator] = useState(false);
  const [showHVIndicator, setShowHVIndicator] = useState(false);

  // IV Panel settings
  const [ivPanelHeight, setIVPanelHeight] = useState(120); // Height per indicator panel
  const [isDraggingIVPanel, setIsDraggingIVPanel] = useState(false); // For resize dragging
  const [ivLookbackPeriod, setIVLookbackPeriod] = useState(365); // Default 1 year
  const [hvWindow, setHVWindow] = useState(20); // Historical Volatility window (10, 20, 30, 60 days)

  // Event Panel settings
  const eventPanelHeight = 360; // Height for event projection panel

  // IV Data state
  const [ivData, setIVData] = useState<Array<{
    date: string;
    callIV: number | null;
    putIV: number | null;
    netIV: number | null;
    ivRank: number | null;
    ivPercentile: number | null;
    hv: number | null;
    price: number;
    expiration: string;
  }>>([]);
  const [currentIVMetrics, setCurrentIVMetrics] = useState<{
    currentPrice: number | null;
    callIV: number | null;
    putIV: number | null;
  }>({ currentPrice: null, callIV: null, putIV: null });

  // Check if any IV/HV indicator is active - showIVPanel controls the IV panel visibility
  const showIVIndicator = showIVPanel; // IV panel is shown when toggled, line visibility controlled inside panel
  const isAnyIVHVActive = showIVPanel || showIVRankIndicator || showIVPercentileIndicator || showHVIndicator;

  // Count active IV panels for height calculation (IV panel counts as 1 even with multiple lines)
  const activeIVPanelCount = [showIVPanel, showIVRankIndicator, showIVPercentileIndicator, showHVIndicator].filter(Boolean).length;

  // Flow Chart state - 4-line chart showing bullish/bearish calls/puts
  const [isFlowChartActive, setIsFlowChartActive] = useState(false);
  const [flowChartViewMode, setFlowChartViewMode] = useState<'detailed' | 'simplified' | 'net'>('detailed');
  const [flowChartHeight, setFlowChartHeight] = useState(150); // Resizable height
  const [isDraggingFlowChart, setIsDraggingFlowChart] = useState(false);
  const [flowMovesTimeframe, setFlowMovesTimeframe] = useState<'1D' | '3D' | '1W'>('1D');
  const [isFlowMovesDropdownOpen, setIsFlowMovesDropdownOpen] = useState(false);
  const [flowChartData, setFlowChartData] = useState<Array<{
    time: number;
    timeLabel: string;
    callsPlus: number;
    callsMinus: number;
    putsPlus: number;
    putsMinus: number;
    bullishTotal: number;
    bearishTotal: number;
    netFlow: number;
  }>>([]);

  // RRG Candle state - Color code candles based on RRG quadrants
  const [isRRGCandleActive, setIsRRGCandleActive] = useState(false);
  const [rrgLookbackPeriod, setRrgLookbackPeriod] = useState<10 | 31 | 87>(31); // For Price mode
  const [rrgIvLookbackPeriod, setRrgIvLookbackPeriod] = useState<30 | 120 | 365>(120); // For IV mode (1mo, 4mo, 1yr)
  const [rrgCandleColors, setRrgCandleColors] = useState<Map<number, string>>(new Map());
  const [rrgMode, setRrgMode] = useState<'price' | 'iv' | 'ivspy'>('price'); // Price, IV (self), or IV/SPY
  const [rrgIvStartTimestamp, setRrgIvStartTimestamp] = useState<number | null>(null); // First candle with IV color
  const [isRrgDropdownOpen, setIsRrgDropdownOpen] = useState(false);

  // Timeframe dropdown state
  const [isTimeframeDropdownOpen, setIsTimeframeDropdownOpen] = useState(false);
  const timeframeButtonRef = useRef<HTMLButtonElement>(null);

  // Flow chart resize handlers
  const handleFlowChartDragStart = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    setIsDraggingFlowChart(true);
  }, []);

  const handleFlowChartDragMove = useCallback((e: MouseEvent) => {
    if (!isDraggingFlowChart) return;

    const container = containerRef.current;
    if (!container) return;

    const rect = container.getBoundingClientRect();
    const mouseY = e.clientY;
    const bottomOfContainer = rect.bottom;

    // Calculate new height from bottom of container
    const newHeight = bottomOfContainer - mouseY;

    // Constrain between 100px and 800px (allow dragging much higher)
    const constrainedHeight = Math.max(100, Math.min(800, newHeight));
    setFlowChartHeight(constrainedHeight);
  }, [isDraggingFlowChart]);

  const handleFlowChartDragEnd = useCallback(() => {
    setIsDraggingFlowChart(false);
  }, []);

  // Add/remove mouse event listeners for dragging
  useEffect(() => {
    if (isDraggingFlowChart) {
      window.addEventListener('mousemove', handleFlowChartDragMove);
      window.addEventListener('mouseup', handleFlowChartDragEnd);
      return () => {
        window.removeEventListener('mousemove', handleFlowChartDragMove);
        window.removeEventListener('mouseup', handleFlowChartDragEnd);
      };
    }
  }, [isDraggingFlowChart, handleFlowChartDragMove, handleFlowChartDragEnd]);

  // IV Panel resize handlers - TradingView style drag to resize
  const handleIVPanelDragStart = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    setIsDraggingIVPanel(true);
  }, []);

  const handleIVPanelDragMove = useCallback((e: MouseEvent) => {
    if (!isDraggingIVPanel) return;

    const container = containerRef.current;
    if (!container) return;

    const rect = container.getBoundingClientRect();
    const mouseY = e.clientY;
    const bottomOfContainer = rect.bottom;

    // Calculate distance from bottom (accounting for volume and time axis)
    const volumeAndTimeHeight = 80 + 25; // volume area + time axis
    const flowChartSpace = isFlowChartActive ? flowChartHeight : 0;
    const distanceFromBottom = bottomOfContainer - mouseY - volumeAndTimeHeight - flowChartSpace;

    // Calculate new height per panel
    const newHeightPerPanel = Math.floor(distanceFromBottom / Math.max(1, activeIVPanelCount));

    // Constrain between 80px and 300px per panel
    const constrainedHeight = Math.max(80, Math.min(300, newHeightPerPanel));
    setIVPanelHeight(constrainedHeight);
  }, [isDraggingIVPanel, isFlowChartActive, flowChartHeight, activeIVPanelCount]);

  const handleIVPanelDragEnd = useCallback(() => {
    setIsDraggingIVPanel(false);
  }, []);

  // Add/remove mouse event listeners for IV panel dragging
  useEffect(() => {
    if (isDraggingIVPanel) {
      window.addEventListener('mousemove', handleIVPanelDragMove);
      window.addEventListener('mouseup', handleIVPanelDragEnd);
      return () => {
        window.removeEventListener('mousemove', handleIVPanelDragMove);
        window.removeEventListener('mouseup', handleIVPanelDragEnd);
      };
    }
  }, [isDraggingIVPanel, handleIVPanelDragMove, handleIVPanelDragEnd]);

  // IV & HV Data Fetch Handler - Fetches historical IV data and calculates metrics
  const fetchIVData = useCallback(async () => {
    if (isIVLoading) return;

    console.log(`ðŸ” Fetching IV data for ${symbol} with ${ivLookbackPeriod} day lookback`);
    setIsIVLoading(true);
    setIVProgress(0);

    try {
      // Fetch calculated historical IV data from API
      const response = await fetch(
        `/api/calculate-historical-iv?ticker=${symbol}&days=${ivLookbackPeriod}`
      );
      const result = await response.json();

      setIVProgress(50);

      if (result.success && result.data.history && result.data.history.length > 0) {
        const { currentPrice, callIV, putIV, history } = result.data;

        console.log(`âœ… IV History received - ${history.length} data points`);

        // Store current metrics
        setCurrentIVMetrics({
          currentPrice,
          callIV,
          putIV
        });

        // Calculate IV Rank and IV Percentile for the full history
        const ivValues = history
          .map((h: any) => (h.callIV && h.putIV) ? (h.callIV + h.putIV) / 2 : null)
          .filter((v: any) => v !== null);
        const minIV = Math.min(...ivValues);
        const maxIV = Math.max(...ivValues);

        // Calculate Historical Volatility (HV) using price data
        const calculateHV = (prices: number[], window: number) => {
          if (prices.length < window + 1) return null;

          const returns: number[] = [];
          for (let i = 1; i <= window; i++) {
            returns.push(Math.log(prices[prices.length - i] / prices[prices.length - i - 1]));
          }

          const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
          const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
          const stdDev = Math.sqrt(variance);

          // Annualize (252 trading days) and convert to percentage
          return stdDev * Math.sqrt(252) * 100;
        };

        // Format history for chart with IV Rank, IV Percentile, and HV
        const chartData = history.map((h: any, index: number) => {
          const netIV = (h.callIV && h.putIV) ? (h.callIV + h.putIV) / 2 : null;

          // IV Rank: (Current - Min) / (Max - Min) * 100
          const ivRank = netIV && maxIV !== minIV ? ((netIV - minIV) / (maxIV - minIV)) * 100 : null;

          // IV Percentile: Percentage of values below current value
          const ivPercentile = netIV ? (ivValues.filter((v: number) => v <= netIV).length / ivValues.length) * 100 : null;

          // Historical Volatility: Calculate using rolling window
          const prices = history.slice(Math.max(0, index - hvWindow), index + 1).map((item: any) => item.price);
          const hv = calculateHV(prices, hvWindow);

          return {
            date: h.date,
            callIV: h.callIV,
            putIV: h.putIV,
            netIV,
            ivRank,
            ivPercentile,
            hv,
            price: h.price,
            expiration: h.expiration
          };
        });

        setIVData(chartData);
        setIVProgress(100);
        console.log(`ðŸ“Š IV data processed: ${chartData.length} data points`);
      } else {
        console.error('âŒ Failed to fetch IV data:', result.error);
      }
    } catch (error) {
      console.error('âŒ IV Fetch Error:', error);
    } finally {
      setIsIVLoading(false);
    }
  }, [symbol, ivLookbackPeriod, hvWindow, isIVLoading]);

  // Recalculate HV when window changes
  const recalculateHV = useCallback((newWindow: number) => {
    if (ivData.length === 0) return;

    const calculateHV = (prices: number[], window: number) => {
      if (prices.length < window + 1) return null;

      const returns: number[] = [];
      for (let i = 1; i <= window; i++) {
        returns.push(Math.log(prices[prices.length - i] / prices[prices.length - i - 1]));
      }

      const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
      const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
      const stdDev = Math.sqrt(variance);

      return stdDev * Math.sqrt(252) * 100;
    };

    const updatedData = ivData.map((item, index) => {
      const prices = ivData.slice(Math.max(0, index - newWindow), index + 1).map((d) => d.price);
      const hv = calculateHV(prices, newWindow);

      return {
        ...item,
        hv
      };
    });

    setIVData(updatedData);
  }, [ivData]);

  // Auto-fetch IV data when any indicator is activated
  useEffect(() => {
    if (isAnyIVHVActive && ivData.length === 0) {
      fetchIVData();
    }
  }, [isAnyIVHVActive, ivData.length, fetchIVData]);

  // Expansion/Liquidation indicator state
  const [isExpansionLiquidationActive, setIsExpansionLiquidationActive] = useState(false);
  const [expansionLiquidationZones, setExpansionLiquidationZones] = useState<any[]>([]);

  // Technalysis indicator state
  const [technalysisActive, setTechnalysisActive] = useState(false);
  const [technalysisFeatures, setTechnalysisFeatures] = useState({
    orderBlocks: false,
    fvg: false,
    liquidity: false,
    structure: false,
    premiumDiscount: false
  });

  // Alerts state
  const [alerts, setAlerts] = useState<PriceAlert[]>([]);
  const [quickNotes, setQuickNotes] = useState<string>('');
  const [isAlertPlacementMode, setIsAlertPlacementMode] = useState(false);
  const [newAlertPrice, setNewAlertPrice] = useState<number | null>(null);
  const [showAlertDialog, setShowAlertDialog] = useState(false);
  const [selectedAlertType, setSelectedAlertType] = useState<'price' | 'options' | 'technical'>('price');

  // Watchlist data state
  const [watchlistData, setWatchlistData] = useState<{
    [key: string]: {
      price: number;
      change1d: number;
      change5d: number;
      change13d: number;
      change21d: number;
      change50d: number;
      changeYTD: number;
      performance: string;
      performanceColor: string;
    }
  }>({}); // Loading state for watchlist data
  const [watchlistLoading, setWatchlistLoading] = useState(true);

  // ETF Holdings Modal state
  const [selectedETF, setSelectedETF] = useState<{ symbol: string; name: string } | null>(null);

  // Market data for major indices and sectors
  const marketSymbols = {
    Markets: ['SPY', 'QQQ', 'IWM', 'DIA', 'XLK', 'XLY', 'XLC', 'XLRE', 'XLV', 'XLU', 'XLP', 'XLB', 'XLF', 'XLI', 'XLE'],
    Industries: ['IGV', 'SMH', 'XRT', 'KIE', 'KRE', 'GDX', 'ITA', 'TAN', 'XBI', 'ITB', 'XHB', 'XOP', 'OIH', 'XME', 'ARKK', 'VNQ', 'JETS', 'KWEB'],
    Special: ['IWF', 'IWD', 'IJR', 'USMV', 'VYM', 'PKW', 'CSD', 'GURU', 'IPO', 'QUAL', 'PSP', 'IVE', 'IVW', 'IJJ', 'IJH', 'IWN', 'IWO']
  };

  // Ticker name mapping
  const tickerNames: Record<string, string> = {
    // Markets
    'SPY': 'S&P 500',
    'QQQ': 'Nasdaq 100',
    'IWM': 'Russell 2000',
    'DIA': 'Dow Jones',
    'XLK': 'Technology',
    'XLY': 'Discretionary',
    'XLC': 'Communication',
    'XLRE': 'Real Estate',
    'XLV': 'Healthcare',
    'XLU': 'Utilities',
    'XLP': 'Staples',
    'XLB': 'Materials',
    'XLF': 'Financials',
    'XLI': 'Industrials',
    'XLE': 'Energy',
    // Industries
    'IGV': 'Software',
    'SMH': 'Semiconductors',
    'XRT': 'Retail',
    'KIE': 'Insurance',
    'KRE': 'Regional Banks',
    'GDX': 'Gold Miners',
    'ITA': 'Aerospace & Defense',
    'TAN': 'Solar',
    'XBI': 'Biotech',
    'ITB': 'Homebuilders',
    'XHB': 'Home Construction',
    'XOP': 'Oil & Gas Exploration',
    'OIH': 'Oil Services',
    'XME': 'Metals & Mining',
    'ARKK': 'Innovation',
    'VNQ': 'REITs',
    'JETS': 'Airlines',
    'KWEB': 'China Internet',
    // Special
    'IWF': 'Russell 1000 Growth',
    'IWD': 'Russell 1000 Value',
    'IJR': 'S&P 600 Small Cap',
    'USMV': 'Min Volatility',
    'VYM': 'High Dividend',
    'PKW': 'Buyback Achievers',
    'CSD': 'Small Cap Dividend',
    'GURU': 'Hedge Fund',
    'IPO': 'IPOs',
    'QUAL': 'Quality',
    'PSP': 'Small Cap Growth',
    'IVE': 'S&P 500 Value',
    'IVW': 'S&P 500 Growth',
    'IJJ': 'S&P 400 Value',
    'IJH': 'S&P 400 Mid Cap',
    'IWN': 'Russell 2000 Value',
    'IWO': 'Russell 2000 Growth'
  };

  // Fetch market data
  useEffect(() => {
    const fetchRealMarketData = async (isInitialLoad = false) => {
      if (isInitialLoad) {
        setWatchlistLoading(true);
      }

      // Prioritized symbols for efficient loading
      const coreSymbols = ['SPY', 'QQQ', 'IWM', 'DIA', 'XLK', 'XLY', 'XLC', 'XLRE', 'XLV'];
      const additionalSymbols = ['XLU', 'XLP', 'XLB', 'XLF', 'XLI', 'XLE', 'IGV', 'SMH', 'XRT', 'KIE', 'KRE', 'GDX', 'ITA', 'TAN', 'XBI', 'ITB', 'XHB', 'XOP', 'OIH', 'XME', 'ARKK', 'IPO', 'VNQ', 'JETS', 'KWEB', 'IWF', 'IWD', 'IJR', 'USMV', 'VYM', 'PKW', 'CSD', 'GURU', 'QUAL', 'PSP', 'IVE', 'IVW', 'IJJ', 'IJH', 'IWN', 'IWO'];

      // Load core symbols first, then additional if not initial load
      const symbols = isInitialLoad ? coreSymbols : [...coreSymbols, ...additionalSymbols];

      const processedData: {
        [symbol: string]: {
          price: number;
          change1d: number;
          change5d: number;
          change13d: number;
          change21d: number;
          change50d: number;
          changeYTD: number;
          performance: string;
          performanceColor: string;
        }
      } = {};

      try {
        // Fetch ALL symbols in parallel - no artificial delays or batching
        const allPromises = symbols.map(async (symbol) => {
          try {
            // Get historical data - need full year for YTD calculation
            // Always fetch up to today's date - Polygon will return data up to last trading day
            const endDate = new Date().toISOString().split('T')[0];
            // Start from December 1st of PREVIOUS year to ensure we capture year-end close
            const year = new Date().getFullYear();
            const previousYear = year - 1;
            const fetchStart = new Date(previousYear, 11, 1); // December 1st of previous year
            const startDate = fetchStart.toISOString().split('T')[0];

            const url = createApiUrl('/api/historical-data', {
              symbol,
              startDate,
              endDate
            });

            const response = await fetch(url);

            if (!response.ok) {
              console.warn(`? Failed to fetch data for ${symbol}: HTTP ${response.status}`);
              return null;
            }

            const result = await response.json();

            if (!result?.results || !Array.isArray(result.results) || result.results.length < 1) {
              console.warn(`?? No data for ${symbol}`);
              return null;
            }

            const data = result.results;
            const latest = data[data.length - 1];
            const currentPrice = latest.c;
            const dataLength = data.length;

            // Calculate price changes - always use previous bar if available
            // For 1D change: Use latest bar's open if we only have 1 bar, or previous bar's close
            let price1DayAgo = currentPrice;
            if (dataLength >= 2) {
              // We have at least 2 bars, use previous bar's close
              price1DayAgo = data[dataLength - 2]?.c;
            } else if (dataLength === 1 && latest.o) {
              // Only 1 bar but it has open price - use that for intraday change
              price1DayAgo = latest.o;
            }

            const price5DaysAgo = dataLength >= 6 ? data[dataLength - 6]?.c : (dataLength >= 2 ? data[0]?.c : currentPrice);
            const price13DaysAgo = dataLength >= 14 ? data[dataLength - 14]?.c : (dataLength >= 2 ? data[0]?.c : currentPrice);
            const price21DaysAgo = dataLength >= 22 ? data[dataLength - 22]?.c : (dataLength >= 2 ? data[0]?.c : currentPrice);
            const price50DaysAgo = dataLength >= 51 ? data[dataLength - 51]?.c : (dataLength >= 2 ? data[0]?.c : currentPrice);

            // Calculate YTD (Year to Date) - find LAST trading day of PREVIOUS year
            // This gives us the proper year-end close to compare against
            const previousYearData = data.filter((d: any) => new Date(d.t).getFullYear() === previousYear).sort((a: any, b: any) => new Date(b.t).getTime() - new Date(a.t).getTime())[0];
            // Fallback: if no previous year data, use first trading day of current year
            const currentYearFirstDay = data.filter((d: any) => new Date(d.t).getFullYear() === year).sort((a: any, b: any) => new Date(a.t).getTime() - new Date(b.t).getTime())[0];
            const yearStartPrice = previousYearData?.c || currentYearFirstDay?.c || data[0]?.c || currentPrice;

            // Calculate percentage changes - ensure we don't divide by zero and actually have different prices
            const change1d = (price1DayAgo && price1DayAgo !== currentPrice) ? ((currentPrice - price1DayAgo) / price1DayAgo) * 100 : 0;
            const change5d = (price5DaysAgo && price5DaysAgo !== currentPrice) ? ((currentPrice - price5DaysAgo) / price5DaysAgo) * 100 : 0;
            const change13d = (price13DaysAgo && price13DaysAgo !== currentPrice) ? ((currentPrice - price13DaysAgo) / price13DaysAgo) * 100 : 0;
            const change21d = (price21DaysAgo && price21DaysAgo !== currentPrice) ? ((currentPrice - price21DaysAgo) / price21DaysAgo) * 100 : 0;
            const change50d = (price50DaysAgo && price50DaysAgo !== currentPrice) ? ((currentPrice - price50DaysAgo) / price50DaysAgo) * 100 : 0;
            const changeYTD = yearStartPrice && yearStartPrice !== currentPrice ? ((currentPrice - yearStartPrice) / yearStartPrice) * 100 : 0;

            return {
              symbol,
              data: {
                price: currentPrice || 0,
                change1d,
                change5d,
                change13d,
                change21d,
                change50d,
                changeYTD,
                performance: 'Neutral',
                performanceColor: 'text-white'
              }
            };
          } catch (symbolError) {
            console.warn(`? Error fetching data for ${symbol}:`, symbolError);
            return null;
          }
        });

        // Wait for ALL fetches to complete in parallel
        const allResults = await Promise.all(allPromises);

        // Process successful results
        allResults.forEach(result => {
          if (result) {
            processedData[result.symbol] = result.data;
          }
        });

        // After collecting all data, calculate relative performance to SPY
        if (Object.keys(processedData).length > 0 && processedData['SPY']) {
          const spyData = processedData['SPY'];

          // Calculate relative performance for each symbol vs SPY
          Object.keys(processedData).forEach(symbol => {
            if (symbol !== 'SPY') {
              const symbolData = processedData[symbol];

              // Calculate relative performance vs SPY
              const relative1d = symbolData.change1d - spyData.change1d;
              const relative5d = symbolData.change5d - spyData.change5d;
              const relative13d = symbolData.change13d - spyData.change13d;
              const relative21d = symbolData.change21d - spyData.change21d;

              let performance = 'Neutral';
              let performanceColor = 'text-white';

              // Performance based on relative strength to SPY (green = outperforming, red = underperforming)
              if (relative21d > 0) {
                performance = 'KING';
                performanceColor = 'text-yellow-400 drop-shadow-[0_0_8px_rgba(255,215,0,0.8)]';
              } else if (relative21d < 0) {
                performance = 'Fallen';
                performanceColor = 'text-orange-600 drop-shadow-[0_0_8px_rgba(255,165,0,0.8)]';
              } else if (relative13d > 0) {
                performance = 'Leader';
                performanceColor = 'text-green-400 drop-shadow-[0_0_8px_rgba(34,197,94,0.8)]';
              } else if (relative13d < 0) {
                performance = 'Laggard';
                performanceColor = 'text-red-400 drop-shadow-[0_0_8px_rgba(239,68,68,0.8)]';
              } else if (relative5d > 0) {
                performance = 'Strong';
                performanceColor = 'text-green-400';
              } else if (relative5d < 0) {
                performance = 'Weak';
                performanceColor = 'text-red-400';
              } else if (relative1d > 0) {
                performance = 'Rising';
                performanceColor = 'text-blue-400';
              } else if (relative1d < 0) {
                performance = 'Falling';
                performanceColor = 'text-purple-400';
              }

              // Update the symbol's performance
              processedData[symbol].performance = performance;
              processedData[symbol].performanceColor = performanceColor;
            } else {
              // SPY gets neutral since it's the benchmark
              processedData[symbol].performance = 'Benchmark';
              processedData[symbol].performanceColor = 'text-blue-300';
            }
          });
        }

        // Update state only if we have some data
        if (Object.keys(processedData).length > 0) {
          setWatchlistData(processedData);

          // Update market regimes for Navigation (calculate inline with processedData)
          const calculateEnhancedRegime = (period: string): RegimeAnalysis => {
            // Core sectors
            const growthSectors = ['XLY', 'XLK', 'XLC'];
            const defensiveSectors = ['XLP', 'XLU', 'XLRE', 'XLV'];
            // Sub-sectors for combined regimes
            const valueSectors = ['XLE', 'XLB']; // Value rotation
            const riskOnSectors = ['XLI', 'XLF']; // Risk-on rotation

            const getChange = (symbol: string) => {
              const data = processedData[symbol];
              if (!data) return 0;
              if (period === '1d') return data.change1d;
              if (period === '5d') return data.change5d;
              if (period === '13d') return data.change13d;
              if (period === '21d') return data.change21d;
              if (period === '50d') return data.change50d;
              if (period === 'ytd') return data.changeYTD;
              return 0;
            };

            const spyChange = getChange('SPY');

            // Calculate average changes for each category
            const defensiveChanges = defensiveSectors.map(s => getChange(s));
            const growthChanges = growthSectors.map(s => getChange(s));
            const valueChanges = valueSectors.map(s => getChange(s));
            const riskOnChanges = riskOnSectors.map(s => getChange(s));

            const defensiveAvg = defensiveChanges.reduce((a, b) => a + b, 0) / defensiveChanges.length;
            const growthAvg = growthChanges.reduce((a, b) => a + b, 0) / growthChanges.length;
            const valueAvg = valueChanges.reduce((a, b) => a + b, 0) / valueChanges.length;
            const riskOnAvg = riskOnChanges.reduce((a, b) => a + b, 0) / riskOnChanges.length;

            // Calculate the spread (KEY METRIC!)
            const defensiveGrowthSpread = defensiveAvg - growthAvg;

            // Determine spread strength
            let spreadStrength: 'STRONG' | 'MODERATE' | 'WEAK';
            if (Math.abs(defensiveGrowthSpread) >= 2.0) spreadStrength = 'STRONG';
            else if (Math.abs(defensiveGrowthSpread) >= 0.5) spreadStrength = 'MODERATE';
            else spreadStrength = 'WEAK';

            // Determine regime with NEW LOGIC for combined regimes
            let regime: 'STRONG DEFENSIVE' | 'MODERATE DEFENSIVE' | 'DEFENSIVE + VALUE' | 'RISK ON' | 'STRONG RISK ON' | 'GROWTH + RISK ON' | 'VALUE' | 'MIXED' | 'RISK OFF';
            let confidence: number;

            // Check for combined regimes
            const valueStrong = valueAvg > defensiveAvg && valueAvg > 0;
            const riskOnStrong = riskOnAvg > growthAvg && riskOnAvg > 0;

            if (defensiveGrowthSpread >= 2.0) {
              if (valueStrong) {
                regime = 'DEFENSIVE + VALUE';
                confidence = Math.min(95, 65 + Math.abs(defensiveGrowthSpread) * 10);
              } else {
                regime = 'STRONG DEFENSIVE';
                confidence = Math.min(95, 60 + Math.abs(defensiveGrowthSpread) * 10);
              }
            } else if (defensiveGrowthSpread >= 0.5) {
              if (valueStrong) {
                regime = 'DEFENSIVE + VALUE';
                confidence = 55 + Math.abs(defensiveGrowthSpread) * 20;
              } else {
                regime = 'MODERATE DEFENSIVE';
                confidence = 50 + Math.abs(defensiveGrowthSpread) * 20;
              }
            } else if (defensiveGrowthSpread <= -2.0) {
              if (riskOnStrong) {
                regime = 'GROWTH + RISK ON';
                confidence = Math.min(95, 65 + Math.abs(defensiveGrowthSpread) * 10);
              } else {
                regime = 'STRONG RISK ON';
                confidence = Math.min(95, 60 + Math.abs(defensiveGrowthSpread) * 10);
              }
            } else if (defensiveGrowthSpread <= -0.5) {
              if (riskOnStrong) {
                regime = 'GROWTH + RISK ON';
                confidence = 55 + Math.abs(defensiveGrowthSpread) * 20;
              } else {
                regime = 'RISK ON';
                confidence = 50 + Math.abs(defensiveGrowthSpread) * 20;
              }
            } else if (valueAvg > defensiveAvg && valueAvg > growthAvg && valueAvg > riskOnAvg && valueAvg > 0) {
              regime = 'VALUE';
              confidence = 60;
            } else if (defensiveAvg < 0 && growthAvg < 0 && valueAvg < 0 && riskOnAvg < 0) {
              regime = 'RISK OFF';
              confidence = 70;
            } else {
              regime = 'MIXED';
              confidence = 30;
            }

            // Build detailed sector analysis - now includes all sectors
            const defensiveSectorsAnalysis: SectorAnalysis[] = defensiveSectors.map(s => ({
              sector: s,
              change: getChange(s),
              relativeToSPY: getChange(s) - spyChange
            }));

            const growthSectorsAnalysis: SectorAnalysis[] = growthSectors.map(s => ({
              sector: s,
              change: getChange(s),
              relativeToSPY: getChange(s) - spyChange
            }));

            const valueSectorsAnalysis: SectorAnalysis[] = [...valueSectors, ...riskOnSectors].map(s => ({
              sector: s,
              change: getChange(s),
              relativeToSPY: getChange(s) - spyChange
            }));

            confidence = Math.max(0, Math.min(100, confidence));

            return {
              defensiveAvg,
              growthAvg,
              valueAvg,
              defensiveGrowthSpread,
              spreadStrength,
              regime,
              confidence,
              defensiveSectors: defensiveSectorsAnalysis,
              growthSectors: growthSectorsAnalysis,
              valueSectors: valueSectorsAnalysis
            };
          };

          // Legacy compatibility function for existing UI
          const calculateRegime = (period: string): string => {
            const analysis = calculateEnhancedRegime(period);
            // Map new regime names to old names for backward compatibility
            if (analysis.regime === 'STRONG DEFENSIVE' || analysis.regime === 'MODERATE DEFENSIVE') return 'DEFENSIVE';
            if (analysis.regime === 'STRONG RISK ON') return 'RISK ON';
            if (analysis.regime === 'RISK ON') return 'RISK ON';
            return analysis.regime; // VALUE, MIXED, RISK OFF stay the same
          };

          const periods = ['1d', '5d', '13d', '21d', '50d', 'ytd'];

          // Calculate enhanced regime for all periods and store
          const enhancedRegimeData: Record<string, RegimeAnalysis> = {};
          periods.forEach(period => {
            enhancedRegimeData[period] = calculateEnhancedRegime(period);
          });
          setRegimeAnalysis(enhancedRegimeData); // Update local state
          setContextRegimeAnalysis(enhancedRegimeData); // Update context for Navigation access

          // Use legacy function for existing regime system
          const activeRegimes = periods.map(period => {
            const regime = calculateRegime(period);
            return regime !== 'MIXED' ? { period: period.toUpperCase(), regime } : null;
          }).filter(Boolean) as { period: string; regime: string }[];

          setRegimes(activeRegimes);
        } else {
          console.error('? No watchlist data processed - market data unavailable');
          setWatchlistData({});
        }

        // Always set loading to false after data processing
        if (isInitialLoad) {
          setWatchlistLoading(false);
        }

      } catch (error) {
        console.error('? Error in market data fetching:', error);
        setWatchlistData({});
        if (isInitialLoad) {
          setWatchlistLoading(false);
        }
      }
    };

    // Initial fetch
    fetchRealMarketData(true); // true = initial load, show spinner

    // Set up interval for regular updates (don't show loading for updates)
    const interval = setInterval(() => {
      fetchRealMarketData(false); // false = update, no spinner
    }, 30000); // Update every 30 seconds

    return () => clearInterval(interval);
  }, []); // Empty dependency array to run only once

  // Close emoji picker when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (showEmojiPicker) {
        const target = event.target as Element;
        if (!target.closest('.emoji-picker-container')) {
          setShowEmojiPicker(false);
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [showEmojiPicker]);

  // Close RRG dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (isRrgDropdownOpen) {
        const target = event.target as Element;
        const dropdown = document.querySelector('[data-rrg-dropdown]');
        const button = rrgButtonRef.current;

        if (dropdown && !dropdown.contains(target) && button && !button.contains(target)) {
          setIsRrgDropdownOpen(false);
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [isRrgDropdownOpen]);

  // Close timeframe dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (isTimeframeDropdownOpen) {
        const target = event.target as Element;
        const dropdown = document.querySelector('[data-timeframe-dropdown]');
        const button = timeframeButtonRef.current;

        if (dropdown && !dropdown.contains(target) && button && !button.contains(target)) {
          setIsTimeframeDropdownOpen(false);
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [isTimeframeDropdownOpen]);

  useEffect(() => {
    // RRG state changes trigger natural re-render
  }, [isRRGCandleActive, rrgCandleColors, rrgMode, rrgLookbackPeriod]);

  // Expected Range data loading - reset when symbol changes
  useEffect(() => {
    // Reset Expected Range levels when symbol changes
    if (expectedRangeLevels) {
      setExpectedRangeLevels(null);
    }
  }, [symbol]);

  // Initialize searchQuery with symbol when component loads or symbol changes
  useEffect(() => {
    setSearchQuery(symbol);
  }, [symbol]);

  // OLD regime loading removed - now using parallel prefetch on panel open

  // Switch to cached highlights instantly when changing tabs
  useEffect(() => {
    if (highlightedTradesCache[regimesTab]) {
      setHighlightedTrades(highlightedTradesCache[regimesTab]);
    }
  }, [regimesTab, highlightedTradesCache]);

  // AI Trade Scoring and Highlighting Logic - Calculate for ALL tabs when data loads
  useEffect(() => {
    const calculateHighlightedTrades = async () => {
      // Skip if already calculating
      if (isCalculatingTrades) {
        return;
      }

      // Find tabs that have data but no highlights yet
      const tabsToCalculate = Object.keys(regimeDataCache).filter(
        tab => regimeDataCache[tab] && !highlightedTradesCache[tab]
      );

      if (tabsToCalculate.length === 0) {
        return; // All tabs either have highlights or no data
      }

      setIsCalculatingTrades(true);

      // Process each tab sequentially
      for (const regimeTab of tabsToCalculate) {
        try {
          const currentTabData = regimeDataCache[regimeTab];

          // Helper function to fetch full trade details for a stock
          const fetchTradeDetails = async (candidate: any, regimeTab: string) => {
            const { symbol, relativePerformance, trend, industry, industrySymbol } = candidate;

            try {
              // Fetch current price
              const priceResponse = await fetch('/api/bulk-chart-data', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  symbols: [symbol],
                  timeframe: '1d',
                  startDate: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                  endDate: new Date().toISOString().split('T')[0]
                })
              });

              if (!priceResponse.ok) {
                console.warn(`âš ï¸ Failed to fetch price for ${symbol}:`, priceResponse.status);
                return null;
              }

              const priceData = await priceResponse.json();
              const prices = priceData.data?.[symbol];
              if (!prices || prices.length === 0) {
                console.warn(`âš ï¸ No price data for ${symbol}`);
                return null;
              }
              const currentPrice = prices[prices.length - 1].close;

              // Fetch options chain
              const optionsResponse = await fetch(`/api/options-chain?symbol=${symbol}`);

              if (!optionsResponse.ok) {
                console.warn(`âš ï¸ Failed to fetch options for ${symbol}:`, optionsResponse.status);
                return null;
              }

              const optionsData = await optionsResponse.json();

              // Handle both API response formats: {results: {...}} or {success: true, data: {...}}
              const resultsData = optionsData.results || optionsData.data;

              // Convert results object to array of [expirationDate, data] tuples
              const expirationEntries = Object.entries(resultsData || {});

              if (expirationEntries.length === 0) {
                console.log(`  âŒ No options available for ${symbol}`, optionsData);
                return null;
              }

              // Select appropriate expiration based on market regime timeframe
              // Life (5d): ~1-2 weeks | Developing (21d): ~3-5 weeks | Momentum (80d): ~3 months | Legacy (252d): ~6-7 months
              let targetDays = 10; // Life default

              if (regimeTab === 'developing') {
                targetDays = 28; // ~4 weeks
              } else if (regimeTab === 'momentum') {
                targetDays = 90; // ~3 months
              } else if (regimeTab === 'legacy') {
                targetDays = 195; // ~6.5 months
              }

              // Find closest available expiration to target, prioritizing next available
              const now = Date.now();
              let closestExpiration: [string, any] | null = null;
              let closestDiff = Infinity;

              for (const [expDateStr, data] of expirationEntries) {
                const expDate = new Date(expDateStr);
                const daysToExp = (expDate.getTime() - now) / (1000 * 60 * 60 * 24);

                // Skip expired options
                if (daysToExp < 1) continue;

                // Calculate difference from target (prefer slightly longer than shorter)
                const diff = Math.abs(daysToExp - targetDays);

                // Prefer this expiration if it's closer to target
                if (diff < closestDiff) {
                  closestDiff = diff;
                  closestExpiration = [expDateStr, data];
                }
              }

              if (!closestExpiration) return null;

              const validExpirations = [closestExpiration];

              // Select optimal strike - extract strikes from calls/puts objects
              const optionType = trend === 'bullish' ? 'call' : 'put';
              const targetStrike = trend === 'bullish' ? currentPrice * 1.05 : currentPrice * 0.95;

              // Find best option by iterating through expiration dates and their strikes
              let bestOption: any = null;
              let bestExpiration = '';

              for (const [expDateStr, data] of validExpirations) {
                const optionsAtStrike = (data as any)[optionType === 'call' ? 'calls' : 'puts'] || {};

                // First pass: Find ATM strike with IV data for reference
                let atmStrikeWithIV: any = null;
                let atmStrike = 0;

                for (const [strikeStr, optionData] of Object.entries(optionsAtStrike)) {
                  if (!optionData || typeof optionData !== 'object') continue;
                  const strike = parseFloat(strikeStr);
                  if (isNaN(strike)) continue;

                  const hasIV = !!(optionData as any).implied_volatility;
                  if (hasIV && (!atmStrikeWithIV || Math.abs(strike - currentPrice) < Math.abs(atmStrike - currentPrice))) {
                    atmStrikeWithIV = optionData;
                    atmStrike = strike;
                  }
                }

                // Second pass: Select optimal strike (prefer those with IV, especially near ATM)
                for (const [strikeStr, optionData] of Object.entries(optionsAtStrike)) {
                  if (!optionData || typeof optionData !== 'object') continue;

                  const strike = parseFloat(strikeStr);
                  if (isNaN(strike)) continue;

                  const hasIV = !!(optionData as any).implied_volatility;
                  const strikeDiff = Math.abs(strike - targetStrike);
                  const distanceFromATM = Math.abs(strike - currentPrice);

                  // Scoring: Prefer IV data, then proximity to target, bonus for being near ATM
                  const score = (hasIV ? 1000 : 0) - strikeDiff - (distanceFromATM * 0.1);
                  const currentBestScore = bestOption ?
                    ((bestOption as any).implied_volatility ? 1000 : 0) - Math.abs(bestOption.strike_price - targetStrike) - (Math.abs(bestOption.strike_price - currentPrice) * 0.1) :
                    -9999;

                  if (!bestOption || score > currentBestScore) {
                    bestOption = {
                      ...optionData,
                      strike_price: strike,
                      expiration_date: expDateStr,
                      option_type: optionType
                    };
                    bestExpiration = expDateStr;
                  }
                }
              }

              if (!bestOption) {
                console.log(`  âŒ No valid options found for ${symbol} (${optionType})`);
                return null;
              }

              const expDate = new Date(bestExpiration);
              const daysToExpiration = Math.floor((expDate.getTime() - now) / (1000 * 60 * 60 * 24));

              // Calculate targets and stop loss using Black-Scholes
              const T = daysToExpiration / 365;
              const r = 0.0387;
              const sigma = bestOption.implied_volatility || 0.5;
              const S = currentPrice;
              const K = bestOption.strike_price;
              const isCall = optionType === 'call';

              // Target calculations (80% and 90% probability targets)
              const expectedMove1SD = S * sigma * Math.sqrt(T);
              const target80StockPrice = isCall ? S + (expectedMove1SD * 0.84) : S - (expectedMove1SD * 0.84);
              const target90StockPrice = isCall ? S + (expectedMove1SD * 1.28) : S - (expectedMove1SD * 1.28);

              // Black-Scholes calculation
              const normalCDF = (x: number): number => {
                const erf = (x: number): number => {
                  const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
                  const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
                  const sign = x >= 0 ? 1 : -1;
                  x = Math.abs(x);
                  const t = 1.0 / (1.0 + p * x);
                  const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
                  return sign * y;
                };
                return 0.5 * (1 + erf(x / Math.sqrt(2)));
              };

              const calculateBSPrice = (S: number, K: number, T: number, r: number, sigma: number, isCall: boolean): number => {
                if (T <= 0) return isCall ? Math.max(0, S - K) : Math.max(0, K - S);
                const d1 = (Math.log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
                const d2 = d1 - sigma * Math.sqrt(T);
                if (isCall) {
                  return S * normalCDF(d1) - K * Math.exp(-r * T) * normalCDF(d2);
                } else {
                  return K * Math.exp(-r * T) * normalCDF(-d2) - S * normalCDF(-d1);
                }
              };

              // Stock price targets (not option premium targets)
              const stockTarget80 = target80StockPrice;
              const stockTarget90 = target90StockPrice;

              // Stop loss calculation
              const delta = Math.abs(bestOption.greeks?.delta || 0.5);
              const iv = bestOption.implied_volatility || 0.5;
              let baseStopPercent = 0.30;
              if (delta > 0.70) baseStopPercent = 0.15;
              else if (delta >= 0.60) baseStopPercent = 0.20;
              else if (delta >= 0.40) baseStopPercent = 0.25;
              else if (delta >= 0.25) baseStopPercent = 0.35;
              else baseStopPercent = 0.40;

              if (daysToExpiration < 7) baseStopPercent = Math.max(0.10, baseStopPercent - 0.10);
              else if (daysToExpiration < 14) baseStopPercent = Math.max(0.15, baseStopPercent - 0.05);

              const ivAdjustment = Math.max(0, (iv - 0.3) * 0.5);
              const adjustedStopPercent = Math.min(0.50, baseStopPercent + ivAdjustment);
              const currentOptionPrice = bestOption.last_price || ((bestOption.bid || 0) + (bestOption.ask || 0)) / 2;
              const stopLoss = currentOptionPrice > 0 ? currentOptionPrice * (1 - adjustedStopPercent) : 0;

              // Theta decay per day
              const thetaDecay = Math.abs(bestOption.greeks?.theta || 0);

              return {
                symbol,
                trend,
                industry,
                industrySymbol,
                currentPrice,
                relativePerformance,
                optionType: optionType.toUpperCase(),
                strike: bestOption.strike_price,
                optionPrice: bestOption.last_price || 0,
                expiration: bestExpiration,
                daysToExpiration,
                impliedVolatility: bestOption.implied_volatility ? (bestOption.implied_volatility * 100).toFixed(1) : 'N/A',
                delta: bestOption.greeks?.delta || 0,
                gamma: bestOption.greeks?.gamma || 0,
                theta: bestOption.greeks?.theta || 0,
                vega: bestOption.greeks?.vega || 0,
                contractPrice: currentOptionPrice,
                contractBid: bestOption.bid || 0,
                contractAsk: bestOption.ask || 0,
                stockTarget80: stockTarget80,
                stockTarget90: stockTarget90,
                stopLoss: stopLoss,
                thetaDecay: thetaDecay,
                contractSymbol: bestOption.ticker || `${symbol}${bestExpiration.replace(/-/g, '')}${optionType[0].toUpperCase()}${bestOption.strike_price}`,
                triggeredAt: new Date(),
                score: 0,
                details: {},
                highlightType: '',
                industryLeaderOf: ''
              } as any;
            } catch (error) {
              console.error(`Error fetching trade details for ${symbol}:`, error);
              return null;
            }
          };

          // Web Worker pool for parallel scoring computation with DUAL STRATEGIES
          const scoreWithWorkers = (candidates: any[], pricesMap: Map<string, any[]>, timeframe: string): Promise<{ setup: any[], momentum: any[] }> => {
            return new Promise((resolve, reject) => {
              const workerCount = Math.min(4, Math.max(1, Math.floor(candidates.length / 20))); // 4 workers max, 1 per 20 candidates
              const setupWorkers: Worker[] = [];
              const momentumWorkers: Worker[] = [];
              const setupResults: any[][] = [];
              const momentumResults: any[][] = [];
              let completedSetupWorkers = 0;
              let completedMomentumWorkers = 0;

              // Convert Map to plain object for worker transfer
              const pricesObj: Record<string, any[]> = {};
              pricesMap.forEach((value, key) => {
                pricesObj[key] = value;
              });

              // Split candidates across workers
              const chunkSize = Math.ceil(candidates.length / workerCount);

              // Launch SETUP-QUALITY workers
              for (let i = 0; i < workerCount; i++) {
                const start = i * chunkSize;
                const end = Math.min(start + chunkSize, candidates.length);
                const chunk = candidates.slice(start, end);

                if (chunk.length === 0) continue;

                const setupWorker = new Worker('/workers/aiTradeScoreWorkerNew.js');
                setupWorkers.push(setupWorker);

                setupWorker.onmessage = (e) => {
                  if (e.data.success) {
                    setupResults[i] = e.data.scoredCandidates;
                    completedSetupWorkers++;

                    if (completedSetupWorkers === workerCount && completedMomentumWorkers === workerCount) {
                      // All workers done, combine results
                      const allSetup = setupResults.flat();
                      const allMomentum = momentumResults.flat();
                      setupWorkers.forEach(w => w.terminate());
                      momentumWorkers.forEach(w => w.terminate());
                      resolve({ setup: allSetup, momentum: allMomentum });
                    }
                  } else {
                    setupWorkers.forEach(w => w.terminate());
                    momentumWorkers.forEach(w => w.terminate());
                    reject(new Error(e.data.error));
                  }
                };

                setupWorker.onerror = (error) => {
                  setupWorkers.forEach(w => w.terminate());
                  momentumWorkers.forEach(w => w.terminate());
                  reject(error);
                };

                setupWorker.postMessage({ candidates: chunk, pricesMap: pricesObj, timeframe });
              }

              // Launch MOMENTUM-VOLATILITY workers in parallel
              for (let i = 0; i < workerCount; i++) {
                const start = i * chunkSize;
                const end = Math.min(start + chunkSize, candidates.length);
                const chunk = candidates.slice(start, end);

                if (chunk.length === 0) continue;

                const momentumWorker = new Worker('/workers/aiTradeScoreMomentumWorker.js');
                momentumWorkers.push(momentumWorker);

                momentumWorker.onmessage = (e) => {
                  if (e.data.success) {
                    momentumResults[i] = e.data.scoredCandidates;
                    completedMomentumWorkers++;

                    if (completedSetupWorkers === workerCount && completedMomentumWorkers === workerCount) {
                      // All workers done, combine results
                      const allSetup = setupResults.flat();
                      const allMomentum = momentumResults.flat();
                      setupWorkers.forEach(w => w.terminate());
                      momentumWorkers.forEach(w => w.terminate());
                      resolve({ setup: allSetup, momentum: allMomentum });
                    }
                  } else {
                    setupWorkers.forEach(w => w.terminate());
                    momentumWorkers.forEach(w => w.terminate());
                    reject(new Error(e.data.error));
                  }
                };

                momentumWorker.onerror = (error) => {
                  setupWorkers.forEach(w => w.terminate());
                  momentumWorkers.forEach(w => w.terminate());
                  reject(error);
                };

                momentumWorker.postMessage({ candidates: chunk, pricesMap: pricesObj, timeframe });
              }
            });
          };

          // currentTabData is already TimeframeAnalysis, use it directly
          const currentData = currentTabData;

          if (!currentData || !currentData.industries) {
            setIsCalculatingTrades(false);
            return;
          }

          // Collect all visible stocks from all industries
          const bullishIndustries = currentData.industries.filter(ind => ind.trend === 'bullish').slice(0, 20);
          const bearishIndustries = currentData.industries.filter(ind => ind.trend === 'bearish').slice(0, 20);

          const allCandidates: any[] = [];

          // Collect top 3 from each bullish industry
          for (const industry of bullishIndustries) {
            if (industry.topPerformers && industry.topPerformers.length > 0) {
              const top3 = industry.topPerformers.slice(0, 3);
              for (const stock of top3) {
                allCandidates.push({
                  symbol: stock.symbol,
                  relativePerformance: stock.relativePerformance,
                  trend: 'bullish',
                  industry: industry.name,
                  industrySymbol: industry.symbol
                });
              }
            }
          }

          // Collect worst 3 from each bearish industry
          for (const industry of bearishIndustries) {
            if (industry.worstPerformers && industry.worstPerformers.length > 0) {
              const worst3 = industry.worstPerformers.slice(0, 3);
              for (const stock of worst3) {
                allCandidates.push({
                  symbol: stock.symbol,
                  relativePerformance: stock.relativePerformance,
                  trend: 'bearish',
                  industry: industry.name,
                  industrySymbol: industry.symbol
                });
              }
            }
          }

          if (allCandidates.length === 0) {
            setIsCalculatingTrades(false);
            return;
          }

          // Fetch bulk price data for all candidates (parallel batching with 10 symbols per batch)
          const symbols = [...new Set(allCandidates.map(c => c.symbol))];

          const pricesMap = new Map<string, any[]>();
          const batchSize = 10;

          // Create all batch promises
          const batchPromises = [];
          for (let i = 0; i < symbols.length; i += batchSize) {
            const batch = symbols.slice(i, i + batchSize);

            batchPromises.push(
              fetch('/api/bulk-chart-data', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  symbols: batch,
                  timeframe: '1d',
                  startDate: new Date(Date.now() - 60 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                  endDate: new Date().toISOString().split('T')[0]
                })
              })
                .then(async res => {
                  if (!res.ok) {
                    const error = await res.text();
                    return { success: false, batch, error };
                  }
                  const data = await res.json();
                  return { success: true, batch, data: data.data };
                })
                .catch(error => ({ success: false, batch, error: error.message }))
            );
          }

          // Execute all batches in parallel
          const results = await Promise.allSettled(batchPromises);

          // Process successful results
          let successCount = 0;
          for (const result of results) {
            if (result.status === 'fulfilled') {
              if (result.value.success && 'data' in result.value && result.value.data) {
                Object.entries(result.value.data).forEach(([symbol, prices]) => {
                  pricesMap.set(symbol, prices as any[]);
                  successCount++;
                });
              } else if (!result.value.success) {
                console.warn(`âš ï¸ Batch [${result.value.batch.join(', ')}] failed:`, result.value.error);
              }
            } else {
              console.error(`âŒ Batch promise rejected:`, result.reason);
            }
          }

          // Score all candidates in parallel using DUAL STRATEGY Web Workers (with timeframe context)
          const { setup: setupScored, momentum: momentumScored } = await scoreWithWorkers(allCandidates, pricesMap, regimeTab);
          const validSetup = setupScored.filter((c: any) => c.score > 0);
          const validMomentum = momentumScored.filter((c: any) => c.score > 0);

          console.log(`ðŸ“Š Setup scored: ${validSetup.length}/${setupScored.length}, ðŸš€ Momentum scored: ${validMomentum.length}/${momentumScored.length}`);

          if (validSetup.length === 0 && validMomentum.length === 0) {
            setIsCalculatingTrades(false);
            return;
          }

          // SETUP-QUALITY STRATEGY: Find best bullish and bearish (GOLD highlights)
          const setupBullish = validSetup.filter((c: any) => c.trend === 'bullish');
          const setupBearish = validSetup.filter((c: any) => c.trend === 'bearish');

          const bestSetupBullish = setupBullish.length > 0 ? setupBullish.reduce((best: any, curr: any) => curr.score > best.score ? curr : best) : null;
          const bestSetupBearish = setupBearish.length > 0 ? setupBearish.reduce((best: any, curr: any) => curr.score > best.score ? curr : best) : null;

          // SETUP-QUALITY STRATEGY: Find best in each industry (PURPLE highlights)
          const setupIndustryBestMap = new Map<string, any>();

          for (const industry of [...bullishIndustries, ...bearishIndustries]) {
            const industryStocks = validSetup.filter(c => c.industrySymbol === industry.symbol);
            if (industryStocks.length > 0) {
              const best = industryStocks.reduce((best, curr) => curr.score > best.score ? curr : best);
              setupIndustryBestMap.set(industry.symbol, best);
            }
          }

          // MOMENTUM-VOLATILITY STRATEGY: Find best bullish and bearish (ORANGE highlights)
          const momentumBullish = validMomentum.filter((c: any) => c.trend === 'bullish');
          const momentumBearish = validMomentum.filter((c: any) => c.trend === 'bearish');

          const bestMomentumBullish = momentumBullish.length > 0 ? momentumBullish.reduce((best: any, curr: any) => curr.score > best.score ? curr : best) : null;
          const bestMomentumBearish = momentumBearish.length > 0 ? momentumBearish.reduce((best: any, curr: any) => curr.score > best.score ? curr : best) : null;

          // MOMENTUM-VOLATILITY STRATEGY: Find best in each industry (BLUE highlights)
          const momentumIndustryBestMap = new Map<string, any>();

          for (const industry of [...bullishIndustries, ...bearishIndustries]) {
            const industryStocks = validMomentum.filter(c => c.industrySymbol === industry.symbol);
            if (industryStocks.length > 0) {
              const best = industryStocks.reduce((best, curr) => curr.score > best.score ? curr : best);
              momentumIndustryBestMap.set(industry.symbol, best);
            }
          }

          // Fetch full trade details for all highlighted stocks (4 types)
          const tradesMap: Record<string, any> = {};

          // Fetch SETUP-QUALITY: Gold highlights (best overall)
          if (bestSetupBullish) {
            const details = await fetchTradeDetails(bestSetupBullish, regimeTab);
            if (details) {
              details.score = bestSetupBullish.score;
              details.details = bestSetupBullish.details;
              details.highlightType = 'gold';
              details.strategy = 'setup';
              details.sourceTab = regimeTab;
              tradesMap[bestSetupBullish.symbol] = details;
            }
          }

          if (bestSetupBearish && bestSetupBearish.symbol !== bestSetupBullish?.symbol) {
            const details = await fetchTradeDetails(bestSetupBearish, regimeTab);
            if (details) {
              details.score = bestSetupBearish.score;
              details.details = bestSetupBearish.details;
              details.highlightType = 'gold';
              details.strategy = 'setup';
              details.sourceTab = regimeTab;
              tradesMap[bestSetupBearish.symbol] = details;
            }
          }

          // Fetch MOMENTUM-VOLATILITY: Orange highlights (best overall)
          if (bestMomentumBullish && !tradesMap[bestMomentumBullish.symbol]) {
            const details = await fetchTradeDetails(bestMomentumBullish, regimeTab);
            if (details) {
              details.score = bestMomentumBullish.score;
              details.details = bestMomentumBullish.details;
              details.highlightType = 'blue';
              details.strategy = 'momentum';
              details.sourceTab = regimeTab;
              tradesMap[bestMomentumBullish.symbol] = details;
            }
          }

          if (bestMomentumBearish && bestMomentumBearish.symbol !== bestMomentumBullish?.symbol && !tradesMap[bestMomentumBearish.symbol]) {
            const details = await fetchTradeDetails(bestMomentumBearish, regimeTab);
            if (details) {
              details.score = bestMomentumBearish.score;
              details.details = bestMomentumBearish.details;
              details.highlightType = 'blue';
              details.strategy = 'momentum';
              details.sourceTab = regimeTab;
              tradesMap[bestMomentumBearish.symbol] = details;
            }
          }

          // Fetch SETUP-QUALITY: Purple highlights (industry leaders) - PARALLEL
          const purplePromises = Array.from(setupIndustryBestMap.entries()).map(async ([industrySymbol, candidate]) => {
            // Skip if already fetched
            if (tradesMap[candidate.symbol]) return null;

            const details = await fetchTradeDetails(candidate, regimeTab);
            if (details) {
              details.score = candidate.score;
              details.details = candidate.details;
              details.highlightType = 'purple';
              details.strategy = 'setup';
              details.sourceTab = regimeTab;
              details.industryLeaderOf = industrySymbol;
              return { symbol: candidate.symbol, details };
            } else {
              return null;
            }
          });

          // Fetch MOMENTUM-VOLATILITY: Pink highlights (industry leaders) - PARALLEL
          const pinkPromises = Array.from(momentumIndustryBestMap.entries()).map(async ([industrySymbol, candidate]) => {
            // Skip if already fetched
            if (tradesMap[candidate.symbol]) return null;

            const details = await fetchTradeDetails(candidate, regimeTab);
            if (details) {
              details.score = candidate.score;
              details.details = candidate.details;
              details.highlightType = 'pink';
              details.strategy = 'momentum';
              details.sourceTab = regimeTab;
              details.industryLeaderOf = industrySymbol;
              return { symbol: candidate.symbol, details };
            } else {
              return null;
            }
          });

          const [purpleResults, pinkResults] = await Promise.all([Promise.all(purplePromises), Promise.all(pinkPromises)]);

          purpleResults.forEach(result => {
            if (result) {
              tradesMap[result.symbol] = result.details;
            }
          });

          pinkResults.forEach(result => {
            if (result) {
              tradesMap[result.symbol] = result.details;
            }
          });

          // Update state and cache for this tab
          const goldCount = Object.values(tradesMap).filter(t => t.highlightType === 'gold').length;
          const purpleCount = Object.values(tradesMap).filter(t => t.highlightType === 'purple').length;
          const blueCount = Object.values(tradesMap).filter(t => t.highlightType === 'blue').length;
          const pinkCount = Object.values(tradesMap).filter(t => t.highlightType === 'pink').length;

          console.log(`âœ… ${regimeTab} Highlights: ðŸ¥‡ Gold=${goldCount} ðŸŸ£ Purple=${purpleCount} ðŸ”µ Blue=${blueCount} ðŸ©· Pink=${pinkCount}`);

          // Update cache for this specific tab
          setHighlightedTradesCache(prev => ({ ...prev, [regimeTab]: tradesMap }));

          // If this is the currently active tab, update visible highlights too
          if (regimeTab === regimesTab) {
            setHighlightedTrades(tradesMap);
          }

        } catch (error) {
          console.error(`Error calculating highlighted trades for ${regimeTab}:`, error);
        }
      } // End of for loop for each tab

      setIsCalculatingTrades(false);
    };

    calculateHighlightedTrades();
  }, [regimeDataCache, highlightedTradesCache, isCalculatingTrades, regimesTab]); // Calculate for all tabs when data loads

  // Essential drawing state (keep minimal set for existing functionality)
  const [showToolsDropdown, setShowToolsDropdown] = useState(false);
  const [activeTool, setActiveTool] = useState<string | null>(null);
  const [isDrawing, setIsDrawing] = useState(false);
  const [selectedDrawing, setSelectedDrawing] = useState<any | null>(null);

  // Drawing persistence
  const drawingsRef = useRef<Drawing[]>([]);
  const [drawings, setDrawingsState] = useState<Drawing[]>([]);

  // Multi-point drawing state
  const [multiPointDrawing, setMultiPointDrawing] = useState<{ x: number; y: number }[]>([]);
  const [currentDrawingPhase, setCurrentDrawingPhase] = useState(0);

  // Drawing interaction state
  const [drawingStartPoint, setDrawingStartPoint] = useState<{ x: number; y: number; timestamp?: number; price?: number } | null>(null);
  const [showTextInput, setShowTextInput] = useState(false);
  const [textInputPosition, setTextInputPosition] = useState<{ x: number; y: number } | null>(null);

  // Drawing editor and selection state
  const [isDraggingDrawing, setIsDraggingDrawing] = useState(false);
  const [dragOffset, setDragOffset] = useState<{ x: number; y: number } | null>(null);
  const [dragStartPosition, setDragStartPosition] = useState<{ x: number; y: number } | null>(null);
  const [originalDrawing, setOriginalDrawing] = useState<any | null>(null);
  // Drawing editor removed - drawing tools were removed as requested

  // Properties panel state
  const [showPropertiesPanel, setShowPropertiesPanel] = useState(false);
  const [propertiesPanelPosition, setPropertiesPanelPosition] = useState({ x: 0, y: 0 });

  // Context menu state
  const [showContextMenu, setShowContextMenu] = useState(false);
  const [contextMenuPosition, setContextMenuPosition] = useState({ x: 0, y: 0 });
  const [contextMenuDrawing, setContextMenuDrawing] = useState<Drawing | null>(null);

  // Multi-selection support
  const [selectedDrawings, setSelectedDrawings] = useState<Drawing[]>([]);

  // Advanced drawing features
  const [magnetMode, setMagnetMode] = useState(false);
  const [showDrawingHandles, setShowDrawingHandles] = useState(true);

  // Click detection
  const [lastClickTime, setLastClickTime] = useState(0);
  const [lastClickDrawing, setLastClickDrawing] = useState<any | null>(null);

  // Additional drawing state
  const [drawingText, setDrawingText] = useState('');
  const [dragPreviewOffset, setDragPreviewOffset] = useState<{ x: number; y: number } | null>(null);
  const [hoveredDrawing, setHoveredDrawing] = useState<any | null>(null);
  const [drawingClipboard, setDrawingClipboard] = useState<Drawing[]>([]);

  // Drawing style
  const [drawingStyle, setDrawingStyle] = useState({
    color: '#00ff88',
    lineWidth: 2,
    lineStyle: 'solid' as const,
    lineDash: [],
    fillOpacity: 0.1,
    textSize: 12,
    showLabels: true,
    showLevels: true
  });

  // setDrawings function
  const setDrawings = useCallback((updater: Drawing[] | ((prev: Drawing[]) => Drawing[])) => {
    const newValue = typeof updater === 'function' ? updater(drawingsRef.current) : updater;
    drawingsRef.current = newValue;
    setDrawingsState(newValue);
  }, []);

  // Essential drawing functions
  const handleDrawingSelection = useCallback((drawing: Drawing, multiSelect = false) => {
    setSelectedDrawing(drawing);
    setSelectedDrawings([drawing]);
  }, []);

  const updateDrawing = useCallback((drawingId: string | number, updates: Partial<Drawing>) => {
    setDrawings(prevDrawings =>
      prevDrawings.map(drawing =>
        drawing.id === drawingId ? { ...drawing, ...updates } : drawing
      )
    );
  }, []);

  const handleDrawingPropertiesUpdate = useCallback((updates: Partial<Drawing & { isDeleted?: boolean }>) => {
    if (!selectedDrawing) return;
    if (updates.isDeleted) {
      setDrawings(prev => prev.filter(d => d.id !== selectedDrawing.id));
      setSelectedDrawing(null);
      setShowPropertiesPanel(false);
      return;
    }
    updateDrawing(selectedDrawing.id, updates);
  }, [selectedDrawing, updateDrawing]);

  const handleCopyDrawing = useCallback((drawing?: Drawing) => {
    const targetDrawing = drawing || selectedDrawing;
    if (!targetDrawing) return;
    setDrawingClipboard([{ ...targetDrawing, id: `copy_${Date.now()}` }]);
  }, [selectedDrawing]);

  const handlePasteDrawing = useCallback(() => {
    if (drawingClipboard.length === 0) return;
    drawingClipboard.forEach(drawingTemplate => {
      const newDrawing: Drawing = {
        ...drawingTemplate,
        id: `drawing_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      };
      setDrawings(prev => [...prev, newDrawing]);
    });
  }, [drawingClipboard]);

  const handleDuplicateDrawing = useCallback((drawing?: Drawing) => {
    const targetDrawing = drawing || selectedDrawing;
    if (!targetDrawing) return;
    const duplicated: Drawing = {
      ...targetDrawing,
      id: `drawing_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    };
    setDrawings(prev => [...prev, duplicated]);
    setSelectedDrawing(duplicated);
  }, [selectedDrawing]);

  const handleDeleteDrawing = useCallback((drawing?: Drawing) => {
    const targetDrawing = drawing || selectedDrawing;
    if (!targetDrawing) return;
    setDrawings(prev => prev.filter(d => d.id !== targetDrawing.id));
    if (selectedDrawing && selectedDrawing.id === targetDrawing.id) {
      setSelectedDrawing(null);
      setShowPropertiesPanel(false);
    }
  }, [selectedDrawing]);

  const bringDrawingToFront = useCallback((drawing?: Drawing) => {
    const targetDrawing = drawing || selectedDrawing;
    if (!targetDrawing) return;
    const maxZIndex = Math.max(...drawings.map(d => d.style?.zIndex || 0));
    updateDrawing(targetDrawing.id, {
      style: { ...targetDrawing.style, zIndex: maxZIndex + 1 }
    });
  }, [selectedDrawing, drawings, updateDrawing]);

  const sendDrawingToBack = useCallback((drawing?: Drawing) => {
    const targetDrawing = drawing || selectedDrawing;
    if (!targetDrawing) return;
    const minZIndex = Math.min(...drawings.map(d => d.style?.zIndex || 0));
    updateDrawing(targetDrawing.id, {
      style: { ...targetDrawing.style, zIndex: Math.max(0, minZIndex - 1) }
    });
  }, [selectedDrawing, drawings, updateDrawing]);

  // Data state - SIMPLE
  const [data, setData] = useState<ChartDataPoint[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Chart interaction state
  const [isDragging, _setIsDragging] = useState(false);
  const setIsDragging = useCallback((value: boolean) => {
    _setIsDragging(value);
  }, []);

  const [crosshairPosition, setCrosshairPosition] = useState({ x: 0, y: 0 });
  const [priceRange, setPriceRange] = useState({ min: 0, max: 0 });

  // Y-Axis Dynamic Scaling State
  const [isAutoScale, setIsAutoScale] = useState(true);
  const [manualPriceRange, setManualPriceRange] = useState<{ min: number; max: number } | null>(null);
  const manualPriceRangeRef = useRef<{ min: number; max: number } | null>(null); // For real-time drag updates
  const lastRenderedPriceRangeRef = useRef<{ min: number; max: number }>({ min: 0, max: 100 }); // Store actual rendered range
  // Y-axis drag/pan removed - only zoom remains

  const [boxZoomStart, setBoxZoomStart] = useState<{ x: number; y: number } | null>(null);
  const [boxZoomEnd, setBoxZoomEnd] = useState<{ x: number; y: number } | null>(null);
  const [isBoxZooming, setIsBoxZooming] = useState(false);

  // Momentum Scrolling State
  const [lastMouseTimestamp, setLastMouseTimestamp] = useState(0);
  const [velocity, setVelocity] = useState({ x: 0, y: 0 });
  const [momentumAnimationId, setMomentumAnimationId] = useState<number | null>(null);

  // Y-axis drag to zoom state
  const [isDraggingYAxisZoom, setIsDraggingYAxisZoom] = useState(false);
  const [yAxisZoomDragStart, setYAxisZoomDragStart] = useState<{ y: number; priceRange: { min: number; max: number } } | null>(null);

  // TradingView Y-axis resize state
  const [isResizingYAxis, setIsResizingYAxis] = useState(false);
  const [yAxisResizeStart, setYAxisResizeStart] = useState<{ y: number; priceRange: { min: number; max: number } } | null>(null);
  const [showYAxisResizeCursor, setShowYAxisResizeCursor] = useState(false);

  // Track if this is the first frame of a new drag (to avoid jumps)
  const [isFirstDragFrame, setIsFirstDragFrame] = useState(false);
  const isFirstDragFrameRef = useRef(false); // Ref for synchronous updates

  // TradingView-style navigation state
  const [scrollOffset, setScrollOffset] = useState(9999999); // Start at end - will be corrected when data loads
  const [visibleCandleCount, setVisibleCandleCount] = useState(150); // Number of visible candles

  // Mouse tracking for drag
  const [lastMouseX, setLastMouseX] = useState(0);
  const [lastMouseY, setLastMouseY] = useState(0);
  const [dragStartX, setDragStartX] = useState(0);
  const [dragStartOffset, setDragStartOffset] = useState(0);

  // Y-axis zoom state (TradingView-style price scaling)
  const [priceZoomLevel, setPriceZoomLevel] = useState(1.0); // 1.0 = auto-fit, >1 = zoomed in, <1 = zoomed out
  const [priceZoomCenter, setPriceZoomCenter] = useState(0); // Price level to zoom around
  const [isAutoFitPrice, setIsAutoFitPrice] = useState(true); // Auto-fit price range

  // Price info state
  const [currentPrice, setCurrentPrice] = useState(0);
  const [priceChange, setPriceChange] = useState(0);
  const [priceChangePercent, setPriceChangePercent] = useState(0);

  // Chart dimensions
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  const chartHeight = dimensions.height;

  // Overlay effect for other drawings only (not rays - they're now on main canvas)
  useEffect(() => {
    const overlayCanvas = overlayCanvasRef.current;
    if (!overlayCanvas) return;

    const ctx = overlayCanvas.getContext('2d');
    if (!ctx) return;

    // Clear overlay 
    ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    // Draw other drawings (but NOT horizontal rays - they're on main canvas now)
    if (drawings.length > 0) {
      drawStoredDrawings(ctx);
    }
  }, [drawings]);

  // TradingView-style color scheme (dynamic based on theme)
  const colors = {
    background: config.theme === 'dark' ? '#000000' : '#ffffff',
    grid: config.theme === 'dark' ? '#1a1a1a' : '#e1e4e8',
    text: config.theme === 'dark' ? '#ffffff' : '#000000',
    textSecondary: config.theme === 'dark' ? '#999999' : '#6a737d',
    bullish: config.colors.bullish.body,
    bearish: config.colors.bearish.body,
    crosshair: config.theme === 'dark' ? '#666666' : '#6a737d',
    selection: '#2962ff',
    border: config.theme === 'dark' ? '#333333' : '#e1e4e8',
    header: config.theme === 'dark' ? '#111111' : '#f8f9fa'
  };

  // Y-Axis Dynamic Scaling Utility Functions
  const calculateAutoPriceRange = useCallback((visibleData: ChartDataPoint[]) => {
    if (visibleData.length === 0) return { min: 0, max: 100 };

    const prices = visibleData.flatMap(d => [d.high, d.low]);
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);
    const padding = (maxPrice - minPrice) * 0.1;

    return {
      min: minPrice - padding,
      max: maxPrice + padding
    };
  }, []);

  const getCurrentPriceRange = useCallback((visibleData: ChartDataPoint[]) => {
    if (!isAutoScale && manualPriceRange) {
      return manualPriceRange;
    }
    return calculateAutoPriceRange(visibleData);
  }, [isAutoScale, manualPriceRange, calculateAutoPriceRange]);

  const setManualPriceRangeAndDisableAuto = useCallback((newRange: { min: number; max: number }) => {
    manualPriceRangeRef.current = newRange; // Set ref immediately for real-time rendering
    setManualPriceRange(newRange);
    setIsAutoScale(false);
  }, [manualPriceRange]);

  const resetToAutoScale = useCallback(() => {
    setIsAutoScale(true);
    setManualPriceRange(null);
  }, []);

  // Y-Axis Zoom Functions (TradingView-style)
  const zoomYAxis = useCallback((direction: 'in' | 'out', centerPrice?: number) => {
    setIsAutoFitPrice(false);

    const zoomFactor = direction === 'in' ? 0.8 : 1.25; // Zoom in = smaller range, zoom out = larger range
    const newZoomLevel = Math.max(0.1, Math.min(10, priceZoomLevel * zoomFactor));

    // If centerPrice provided, zoom around that price, otherwise use current center
    if (centerPrice !== undefined) {
      setPriceZoomCenter(centerPrice);
    }

    setPriceZoomLevel(newZoomLevel);
    console.log(`ðŸ” Y-axis zoom ${direction}: level=${newZoomLevel.toFixed(2)}, center=$${(centerPrice || priceZoomCenter).toFixed(2)}`);
  }, [priceZoomLevel, priceZoomCenter]);

  const resetYAxisZoom = useCallback(() => {
    setIsAutoFitPrice(true);
    setPriceZoomLevel(1.0);
    setPriceZoomCenter(0);
    console.log('ðŸ” Y-axis zoom reset to auto-fit');
  }, []);

  // Reset Y-axis zoom when symbol changes
  useEffect(() => {
    resetYAxisZoom();
    setScrollOffset(9999999); // Reset to end of chart for new symbol
    setData([]); // Clear old data to prevent showing wrong price range
    setManualPriceRange(null); // Clear manual price range
    setIsAutoScale(true); // Re-enable auto-scale
    manualPriceRangeRef.current = null; // Clear manual price range ref
    lastRenderedPriceRangeRef.current = { min: 0, max: 100 }; // Reset rendered range ref
  }, [config.symbol, resetYAxisZoom]);

  const isInYAxisArea = useCallback((x: number, canvasWidth: number) => {
    return x > canvasWidth - 80; // Y-axis area is rightmost 80px
  }, []);

  // TradingView: Check if mouse is on Y-axis left border (for resize)
  const isOnYAxisBorder = useCallback((x: number, canvasWidth: number) => {
    const yAxisLeft = canvasWidth - 80;
    return x >= yAxisLeft - 10 && x <= yAxisLeft + 10; // 10px tolerance on border (wider for easier targeting)
  }, []);

  // Helper to get future periods based on timeframe - TradingView style
  // 100% margin to the right of last candle for drawing space
  const getFuturePeriods = useCallback((visibleCount: number): number => {
    // Return 100% of visible candles as right margin, minimum 5 candles
    return Math.max(5, Math.ceil(visibleCount * 1.0));
  }, []); // ============================================================================
  // TRADINGVIEW-STYLE MOMENTUM SCROLLING - EXACT IMPLEMENTATION
  // ============================================================================
  const startMomentumAnimation = useCallback(() => {
    if (momentumAnimationId) {
      cancelAnimationFrame(momentumAnimationId);
    }

    const animate = () => {
      setVelocity(prevVelocity => {
        // TradingView uses exponential decay: v = v * friction
        const friction = 0.90; // TradingView-like friction factor
        const threshold = 0.05; // Stop threshold

        const newVelocityX = Math.abs(prevVelocity.x) > threshold ? prevVelocity.x * friction : 0;
        const newVelocityY = Math.abs(prevVelocity.y) > threshold ? prevVelocity.y * friction : 0;

        // Apply X-axis velocity (horizontal momentum)
        if (Math.abs(newVelocityX) > threshold) {
          setScrollOffset(prevOffset => {
            const Y_AXIS_WIDTH = 80;
            const chartWidth = dimensions.width - Y_AXIS_WIDTH;
            const pixelsPerCandle = chartWidth / visibleCandleCount;

            // Convert velocity (pixels per frame) to candle offset
            const candlesPerFrame = newVelocityX / pixelsPerCandle;
            const newOffset = prevOffset - candlesPerFrame;

            const futurePeriods = getFuturePeriods(visibleCandleCount);
            const maxScrollOffset = data.length - visibleCandleCount + futurePeriods;
            return Math.max(0, Math.min(maxScrollOffset, newOffset));
          });
        }

        // Apply Y-axis velocity (vertical momentum) - TradingView style
        if (Math.abs(newVelocityY) > threshold && manualPriceRange) {
          setManualPriceRange(prevRange => {
            if (!prevRange) return prevRange;

            const timeAxisHeight = 25;
            const priceChartHeight = dimensions.height - timeAxisHeight;
            const priceHeight = prevRange.max - prevRange.min;
            const pricePerPixel = priceHeight / priceChartHeight;

            // Apply velocity to price range
            const priceShift = newVelocityY * pricePerPixel;

            return {
              min: prevRange.min + priceShift,
              max: prevRange.max + priceShift
            };
          });
        }

        // Continue animation if still moving
        if (Math.abs(newVelocityX) > threshold || Math.abs(newVelocityY) > threshold) {
          const id = requestAnimationFrame(animate);
          setMomentumAnimationId(id);
          return { x: newVelocityX, y: newVelocityY };
        } else {
          setMomentumAnimationId(null);
          return { x: 0, y: 0 };
        }
      });
    };

    const id = requestAnimationFrame(animate);
    setMomentumAnimationId(id);
  }, [momentumAnimationId, visibleCandleCount, data.length, dimensions.width, dimensions.height, getFuturePeriods, manualPriceRange]);

  const stopMomentumAnimation = useCallback(() => {
    if (momentumAnimationId) {
      cancelAnimationFrame(momentumAnimationId);
      setMomentumAnimationId(null);
    }
    setVelocity({ x: 0, y: 0 });
  }, [momentumAnimationId]);

  // Fetch real-time price for current price display
  const fetchRealTimePrice = useCallback(async (sym: string) => {
    try {
      // Use Polygon API directly for real-time price instead of custom endpoint
      const polygonUrl = `https://api.polygon.io/v2/last/trade/${sym}?apikey=kjZ4aLJbqHsEhWGOjWMBthMvwDLKd4wf`;
      const response = await fetch(polygonUrl);
      const result = await response.json();

      if (response.ok && result.status === 'OK' && result.results?.p) {
        const livePrice = result.results.p; // Polygon's last trade price
        setCurrentPrice(livePrice);

        // For price change calculation, use current dates - NOT HARDCODED
        const today = new Date();
        const todayStr = today.toISOString().split('T')[0];
        const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
        const yesterdayStr = yesterday.toISOString().split('T')[0];

        const histUrl = createApiUrl('/api/historical-data', {
          symbol: sym,
          startDate: yesterdayStr,
          endDate: todayStr,
          timeframe: '1d',
          _t: Date.now().toString()
        });
        const histResponse = await fetch(histUrl);
        if (histResponse.ok) {
          const histResult = await histResponse.json();
          if (histResult?.results && histResult.results.length >= 2) {
            const current = livePrice;
            const previous = histResult.results[histResult.results.length - 2]?.c || current;
            const change = current - previous;
            const changePercent = ((change) / previous) * 100;
            setPriceChange(change);
            setPriceChangePercent(changePercent);
            console.log(`?? CHANGE: ${sym} ${change >= 0 ? '+' : ''}${change.toFixed(2)} (${changePercent.toFixed(2)}%)`);
          }
        }
      } else {
        console.log(`?? No live trade data for ${sym}, trying last close price...`);

        // Fallback: Try to get the most recent close price from daily data
        const fallbackUrl = `https://api.polygon.io/v2/aggs/ticker/${sym}/prev?adjusted=true&apikey=kjZ4aLJbqHsEhWGOjWMBthMvwDLKd4wf`;
        try {
          const fallbackResponse = await fetch(fallbackUrl);
          const fallbackResult = await fallbackResponse.json();

          if (fallbackResult.status === 'OK' && fallbackResult.results?.[0]?.c) {
            const closePrice = fallbackResult.results[0].c;
            console.log(`?? FALLBACK: Using previous close price for ${sym}: $${closePrice}`);
            setCurrentPrice(closePrice);
          } else {
            console.error(`? Failed to get fallback price for ${sym}:`, fallbackResult);
          }
        } catch (fallbackError) {
          console.error(`? Fallback price fetch failed for ${sym}:`, fallbackError);
        }
      }
    } catch (error) {
      console.error('? Real-time price fetch failed:', error);
      if (error instanceof Error) {
        if (error.message.includes('fetch')) {
          console.error('?? Network connection issue - check if server is running on correct port');
        } else if (error.message.includes('timeout')) {
          console.error('?? Request timeout - API response too slow');
        }
      }
    }
  }, []);

  // Search handler
  const handleSearch = (symbol: string) => {
    if (symbol && symbol.length > 0) {
      const upperSymbol = symbol.toUpperCase();

      // Check if this is a benchmark pattern (Ticker/Ticker)
      if (upperSymbol.includes('/')) {
        const symbols = upperSymbol.split('/').map(s => s.trim()).filter(s => s.length > 0);
        if (symbols.length === 2) {
          console.log(`ðŸ“Š Benchmark Mode: ${symbols[0]} vs ${symbols[1]}`);
          setIsBenchmarkMode(true);
          setBenchmarkSymbol1(symbols[0]);
          setBenchmarkSymbol2(symbols[1]);
          handleSymbolChange(symbols[0]); // Set primary symbol for display
          setSearchQuery('');
          setShowSearchResults(false);
          return;
        }
      }

      // Normal mode - single ticker
      setIsBenchmarkMode(false);
      setBenchmarkSymbol1('');
      setBenchmarkSymbol2('');
      handleSymbolChange(upperSymbol);
      setSearchQuery('');
      setShowSearchResults(false);
    }
  };

  const handleSearchKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleSearch(searchQuery);
    }
  };

  const fetchData = useCallback(async (sym: string, timeframe: string) => {
    const startTime = performance.now();

    setLoading(true);
    setError(null);

    try {
      // FORCE FRESH DATA: Clear cache for volume data
      const cache = ChartDataCache.getInstance();

      // Clear cache for this symbol to force fresh data with volume
      if (cache.clear) {
        cache.clear();
      }

      // Skip cache check - always fetch fresh data for volume

      // Check if we're in benchmark mode
      if (isBenchmarkMode && benchmarkSymbol1 && benchmarkSymbol2) {
        console.log(`\ud83d\udcca BENCHMARK MODE: Fetching ${benchmarkSymbol1} and ${benchmarkSymbol2}`);

        // Fetch data for both symbols in parallel
        const now = new Date();
        const endDate = now.toISOString().split('T')[0];
        const timeframeConfig = TRADINGVIEW_TIMEFRAMES.find(tf => tf.value === timeframe);
        const daysBack = timeframeConfig?.lookback || 365;
        const startDate = new Date(now.getTime() - (daysBack * 24 * 60 * 60 * 1000))
          .toISOString().split('T')[0];

        const [response1, response2] = await Promise.all([
          fetch(`/api/historical-data?symbol=${benchmarkSymbol1}&startDate=${startDate}&endDate=${endDate}&timeframe=${timeframe}&ultrafast=true&forceRefresh=true&_t=${Date.now()}`),
          fetch(`/api/historical-data?symbol=${benchmarkSymbol2}&startDate=${startDate}&endDate=${endDate}&timeframe=${timeframe}&ultrafast=true&forceRefresh=true&_t=${Date.now()}`)
        ]);

        if (!response1.ok || !response2.ok) {
          throw new Error('Failed to fetch benchmark data');
        }

        const [result1, result2] = await Promise.all([
          response1.json(),
          response2.json()
        ]);

        if (!result1?.results?.length || !result2?.results?.length) {
          throw new Error('No data available for one or both symbols');
        }

        // Calculate relative performance (Symbol1 / Symbol2)
        const data1 = result1.results;
        const data2 = result2.results;

        // Create a map of Symbol2 prices by timestamp for easy lookup
        const symbol2PriceMap = new Map(
          data2.map((item: any) => [item.t, item.c])
        );

        // Calculate relative performance for each data point
        const benchmarkData = data1
          .map((item1: any) => {
            const price2 = symbol2PriceMap.get(item1.t);
            if (!price2 || typeof price2 !== 'number') return null;

            const relativePrice = (item1.c / price2) * 100; // Normalize to 100

            return {
              timestamp: item1.t,
              open: (item1.o / price2) * 100,
              high: (item1.h / price2) * 100,
              low: (item1.l / price2) * 100,
              close: relativePrice,
              volume: item1.v || 0,
              date: new Date(item1.t).toISOString().split('T')[0],
              time: new Date(item1.t).toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
              })
            };
          })
          .filter((item: any): item is ChartDataPoint => item !== null);

        console.log(`\ud83d\udcca Benchmark data calculated: ${benchmarkData.length} data points`);

        setData(benchmarkData);
        setLoading(false);

        // Initialize scroll position
        setTimeout(() => {
          const defaultVisible = 150;
          const targetOffset = Math.max(0, benchmarkData.length - defaultVisible);
          setVisibleCandleCount(150);
          setScrollOffset(targetOffset);
        }, 50);

        return;
      }

      // Not in cache - use optimized API fetch with smart batching
      const data = await cache.getOrFetch(sym, timeframe, async () => {
        const now = new Date();
        const endDate = now.toISOString().split('T')[0];

        // Use proper TradingView timeframe lookback periods for full historical data
        const timeframeConfig = TRADINGVIEW_TIMEFRAMES.find(tf => tf.value === timeframe);
        const daysBack = timeframeConfig?.lookback || 365; // Default to 1 year if not found
        const startDate = new Date(now.getTime() - (daysBack * 24 * 60 * 60 * 1000))
          .toISOString().split('T')[0];

        const response = await fetch(
          `/api/historical-data?symbol=${sym}&startDate=${startDate}&endDate=${endDate}&timeframe=${timeframe}&ultrafast=true&forceRefresh=true&_t=${Date.now()}`
        );

        if (!response.ok) {
          throw new Error(`API error: ${response.status}`);
        }

        const result = await response.json();

        // Check if ALL volume values are 0 or undefined
        const allVolumes = result.results?.map((item: any) => item.v).filter((v: any) => v !== undefined && v !== null) || [];
        const nonZeroVolumes = allVolumes.filter((v: any) => v > 0);

        if (!result?.results?.length) {
          throw new Error(`No data available for ${sym}`);
        }

        // Data transformation with pre-allocated arrays
        const rawData = result.results;
        const dataLength = rawData.length;
        const transformedData = new Array(dataLength);

        for (let i = 0; i < dataLength; i++) {
          const item = rawData[i];
          transformedData[i] = {
            timestamp: item.t,
            open: item.o,
            high: item.h,
            low: item.l,
            close: item.c,
            volume: item.v || 0, // ADD VOLUME FIELD!
            date: new Date(item.t).toISOString().split('T')[0],
            time: new Date(item.t).toLocaleTimeString('en-US', {
              hour: '2-digit',
              minute: '2-digit',
              hour12: false
            })
          };
        }

        return transformedData;
      });

      // Set data and complete loading
      setData(data);
      setLoading(false);

      // CRITICAL: Initialize scroll position to show MOST RECENT candles
      setTimeout(() => {
        const defaultVisible = 150;
        const targetOffset = Math.max(0, data.length - defaultVisible);
        setVisibleCandleCount(150);
        setScrollOffset(targetOffset);
      }, 50);

      const loadTime = performance.now() - startTime;

      // SMART PREFETCHING for related symbols and timeframes
      setTimeout(() => {
        const relatedSymbols = getRelatedSymbols(sym);
        const otherTimeframes = ['1d', '1h', '5m'].filter(tf => tf !== timeframe);

        // Prefetch other timeframes for current symbol
        otherTimeframes.forEach(tf => {
          cache.getOrFetch(sym, tf, () => fetchSymbolData(sym, tf)).catch(() => { });
        });

        // Prefetch current timeframe for related symbols
        relatedSymbols.slice(0, 2).forEach(relSym => {
          cache.getOrFetch(relSym, timeframe, () => fetchSymbolData(relSym, timeframe)).catch(() => { });
        });
      }, 100);

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error(`âŒ FETCH FAILED: ${sym} ${timeframe}:`, errorMessage);
      setError(`Failed to load ${timeframe} data for ${sym}: ${errorMessage}`);
      setData([]);
      setLoading(false);
    }
  }, [isBenchmarkMode, benchmarkSymbol1, benchmarkSymbol2]);

  // Helper function to get related symbols for smart prefetching
  const getRelatedSymbols = (symbol: string): string[] => {
    const symbolGroups: Record<string, string[]> = {
      'SPY': ['QQQ', 'IWM'],
      'QQQ': ['SPY', 'TQQQ'],
      'IWM': ['SPY', 'QQQ'],
      'AAPL': ['MSFT', 'GOOGL'],
      'MSFT': ['AAPL', 'NVDA'],
      'NVDA': ['AMD', 'MSFT'],
      'TSLA': ['AAPL', 'NVDA'],
      'GOOGL': ['AAPL', 'MSFT'],
      'AMZN': ['AAPL', 'MSFT'],
      'META': ['GOOGL', 'AAPL'],
      'GM': ['F', 'TSLA'],
      'F': ['GM', 'TSLA']
    };

    return symbolGroups[symbol.toUpperCase()] || [];
  };

  // Helper function for individual symbol data fetching
  const fetchSymbolData = async (symbol: string, timeframe: string) => {
    const now = new Date();
    const endDate = now.toISOString().split('T')[0];

    // Use proper TradingView timeframe lookback periods for full historical data
    const timeframeConfig = TRADINGVIEW_TIMEFRAMES.find(tf => tf.value === timeframe);
    const daysBack = timeframeConfig?.lookback || 365; // Default to 1 year if not found
    const startDate = new Date(now.getTime() - (daysBack * 24 * 60 * 60 * 1000))
      .toISOString().split('T')[0];

    const response = await fetch(
      `/api/historical-data?symbol=${symbol}&startDate=${startDate}&endDate=${endDate}&timeframe=${timeframe}&prefetch=true`
    );

    if (!response.ok) throw new Error(`API error: ${response.status}`);

    const result = await response.json();
    if (!result?.results?.length) throw new Error(`No data for ${symbol}`);

    const mappedData = result.results.map((item: any, index: number) => {
      const mapped = {
        timestamp: item.t,
        open: item.o,
        high: item.h,
        low: item.l,
        close: item.c,
        volume: item.v || 0,
        date: new Date(item.t).toISOString().split('T')[0],
        time: new Date(item.t).toLocaleTimeString('en-US', {
          hour: '2-digit', minute: '2-digit', hour12: false
        })
      };

      return mapped;
    });

    // Debug: Check mapped data

    return mappedData;
  };

  // Auto-fit chart to data
  const fitChart = useCallback(() => {
    if (data.length === 0) return;

    const prices = data.flatMap(d => [d.high, d.low]);
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);
    const padding = (maxPrice - minPrice) * 0.1;

    setPriceRange({
      min: minPrice - padding,
      max: maxPrice + padding
    });
  }, [data]);

  // Handle container resize
  useEffect(() => {
    const updateDimensions = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        setDimensions({ width: rect.width, height: rect.height });
      }
    };

    // Immediate update
    updateDimensions();

    // Delayed update to account for CSS transition (300ms)
    const timer = setTimeout(updateDimensions, 350);

    window.addEventListener('resize', updateDimensions);
    return () => {
      clearTimeout(timer);
      window.removeEventListener('resize', updateDimensions);
    };
  }, [isGuideAIOpen]);

  // Initialize chart - SIMPLE
  useEffect(() => {
    fetchData(symbol, config.timeframe);
  }, [symbol, config.timeframe, fetchData]);

  // Refetch data when benchmark mode changes
  useEffect(() => {
    if (isBenchmarkMode && benchmarkSymbol1 && benchmarkSymbol2) {
      console.log(`\ud83d\udcca Benchmark mode activated, fetching data for ${benchmarkSymbol1}/${benchmarkSymbol2}`);
      fetchData(benchmarkSymbol1, config.timeframe);
    }
  }, [isBenchmarkMode, benchmarkSymbol1, benchmarkSymbol2, config.timeframe, fetchData]);

  // Fetch current price independently when symbol changes
  useEffect(() => {
    fetchRealTimePrice(symbol);
  }, [symbol, fetchRealTimePrice]);

  // Calculate price change when data is loaded
  useEffect(() => {
    if (data.length >= 2 && currentPrice > 0) {
      const latestCandle = data[data.length - 1];
      const previousCandle = data[data.length - 2];
      const change = currentPrice - previousCandle.close;
      const changePercent = (change / previousCandle.close) * 100;
      setPriceChange(change);
      setPriceChangePercent(changePercent);
    }
  }, [data, currentPrice, symbol]);

  // Set up live price updates every 5 seconds for live data
  useEffect(() => {
    const interval = setInterval(() => {
      fetchRealTimePrice(symbol);
    }, 5000); // Update every 5 seconds

    return () => clearInterval(interval);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [symbol]);

  // CRITICAL: Ensure scroll position shows most recent data when data loads
  useEffect(() => {
    if (data.length > 0 && !loading) {
      const defaultVisible = Math.min(150, data.length);
      const targetOffset = Math.max(0, data.length - defaultVisible);

      setVisibleCandleCount(150);
      setScrollOffset(targetOffset);
    }
  }, [data.length, loading]);

  // Initialize scroll position with FULL DATA - DISABLED to prevent override
  // This was overriding the timeframe-specific scroll positioning
  /*
  useEffect(() => {
  if (data.length > 0) {
  const defaultVisible = Math.min(500, data.length); // SHOW UP TO 500 CANDLES
  setVisibleCandleCount(defaultVisible);
  setScrollOffset(Math.max(0, data.length - defaultVisible));
  }
  }, [data.length]);
  */

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      const target = event.target as Element;

      if (showToolsDropdown && !target.closest('.tools-dropdown')) {
        setShowToolsDropdown(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [showToolsDropdown]);

  // Render overlay (crosshair, zoom feedback)
  const renderOverlay = useCallback(() => {
    const canvas = overlayCanvasRef.current;
    if (!canvas || dimensions.width === 0 || dimensions.height === 0) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const { width, height } = dimensions;

    // Set canvas size
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.scale(dpr, dpr);

    // Enable crisp rendering for sharp lines and shapes
    ctx.imageSmoothingEnabled = false;
    (ctx as any).webkitImageSmoothingEnabled = false;
    (ctx as any).mozImageSmoothingEnabled = false;
    (ctx as any).msImageSmoothingEnabled = false;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);

    // Draw crosshair if enabled and mouse is over chart
    if (config.crosshair && crosshairPosition.x > 0 && crosshairPosition.y > 0) {
      ctx.strokeStyle = config.theme === 'dark' ? '#555555' : '#cccccc';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 2]);

      // Vertical crosshair line
      ctx.beginPath();
      ctx.moveTo(crosshairPosition.x, 0);
      ctx.lineTo(crosshairPosition.x, height);
      ctx.stroke();

      // Horizontal crosshair line 
      ctx.beginPath();
      ctx.moveTo(0, crosshairPosition.y);
      ctx.lineTo(width, crosshairPosition.y);
      ctx.stroke();

      ctx.setLineDash([]);

      // PROFESSIONAL CROSSHAIR LABELS - Display price and date/time on axes
      if (crosshairInfo.visible) {
        // CRISP HIGH-QUALITY TEXT RENDERING - Larger and crisper
        ctx.font = 'bold 18px "Segoe UI", system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.imageSmoothingEnabled = false; // Disable for crisper text
        ctx.imageSmoothingQuality = 'high';

        // Y-AXIS PRICE LABEL (right side)
        const priceText = crosshairInfo.price;
        const priceTextWidth = ctx.measureText(priceText).width + 24; // Increased padding for larger text
        const priceY = crosshairPosition.y;

        // Price label background (right side of chart) - darker for contrast
        ctx.fillStyle = config.theme === 'dark' ? '#1a202c' : '#2d3748';
        ctx.strokeStyle = config.theme === 'dark' ? '#2d3748' : '#4a5568';
        ctx.lineWidth = 1;
        ctx.fillRect(width - priceTextWidth - 5, priceY - 16, priceTextWidth, 32); // Larger background
        ctx.strokeRect(width - priceTextWidth - 5, priceY - 16, priceTextWidth, 32);

        // CRISP WHITE PRICE TEXT with enhanced shadow for maximum clarity
        ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
        ctx.shadowBlur = 3;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        ctx.fillStyle = '#FF6600';
        ctx.textAlign = 'center';
        ctx.fillText(priceText, width - priceTextWidth / 2 - 5, priceY);

        // Reset shadow
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        // X-AXIS DATE/TIME LABEL (bottom)
        // Show date + time for intraday timeframes (5m, 30m, 1h), date only for daily+
        const isIntradayTimeframe = ['5m', '30m', '1h', '15m', '1m', '4h'].includes(config.timeframe);
        const dateText = isIntradayTimeframe
          ? `${crosshairInfo.date} ${crosshairInfo.time}`
          : crosshairInfo.date;
        const dateTextWidth = ctx.measureText(dateText).width + 24; // Increased padding
        const dateX = crosshairPosition.x;

        // Ensure date label doesn't go off screen
        const labelX = Math.max(dateTextWidth / 2, Math.min(width - dateTextWidth / 2, dateX));

        // Date label background (bottom of chart) - darker for contrast
        ctx.fillStyle = config.theme === 'dark' ? '#1a202c' : '#2d3748';
        ctx.strokeStyle = config.theme === 'dark' ? '#2d3748' : '#4a5568';
        ctx.lineWidth = 1;
        ctx.fillRect(labelX - dateTextWidth / 2, height - 35, dateTextWidth, 28); // Reduced background size
        ctx.strokeRect(labelX - dateTextWidth / 2, height - 35, dateTextWidth, 28);

        // CRISP WHITE DATE TEXT with enhanced shadow for maximum clarity
        ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
        ctx.shadowBlur = 3;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        ctx.fillStyle = '#FF6600';
        ctx.textAlign = 'center';
        ctx.fillText(dateText, labelX, height - 21); // Moved up to match reduced background

        // Reset shadow
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        // Enhanced OHLC Info Panel (top-left corner) - Desktop only
        // Hide on mobile devices (screen width < 768px)
        const isMobile = window.innerWidth < 768;
        if (crosshairInfo.ohlc && !isMobile) {
          const ohlc = crosshairInfo.ohlc;
          const panelX = 20;
          const panelY = 20;
          const panelWidth = 200;
          const panelHeight = 80;

          // Panel background - solid black with border
          ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
          ctx.strokeStyle = '#333333';
          ctx.lineWidth = 1;
          ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
          ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

          // Panel content with larger text
          ctx.font = 'bold 13px "Segoe UI", system-ui, sans-serif';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';

          const lineHeight = 18;
          let currentY = panelY + 8;

          // Crispy orange color for labels at 100% opacity
          const labelColor = '#FF6600';

          // OHLC values in a clean grid layout
          // First row: Open and High
          ctx.fillStyle = labelColor;
          ctx.globalAlpha = 1.0;
          ctx.fillText('O:', panelX + 12, currentY);
          ctx.fillStyle = '#ffffff';
          ctx.fillText(`$${ohlc.open.toFixed(2)}`, panelX + 35, currentY);

          ctx.fillStyle = labelColor;
          ctx.fillText('H:', panelX + 120, currentY);
          ctx.fillStyle = '#00ff88'; // Bright green for high
          ctx.fillText(`$${ohlc.high.toFixed(2)}`, panelX + 143, currentY);
          currentY += lineHeight;

          // Second row: Low and Close
          ctx.fillStyle = labelColor;
          ctx.fillText('L:', panelX + 12, currentY);
          ctx.fillStyle = '#ff4444'; // Bright red for low
          ctx.fillText(`$${ohlc.low.toFixed(2)}`, panelX + 35, currentY);

          ctx.fillStyle = labelColor;
          ctx.fillText('C:', panelX + 120, currentY);
          const closeColor = (ohlc.change !== undefined && ohlc.change >= 0) ? '#00ff88' : '#ff4444';
          ctx.fillStyle = closeColor;
          ctx.fillText(`$${ohlc.close.toFixed(2)}`, panelX + 143, currentY);
          currentY += lineHeight;

          // Third row: Volume
          if (ohlc.volume !== undefined && ohlc.volume > 0) {
            ctx.fillStyle = labelColor;
            ctx.fillText('V:', panelX + 12, currentY);

            // Format volume for display
            let volumeText = '';
            if (ohlc.volume >= 1000000) {
              volumeText = `${(ohlc.volume / 1000000).toFixed(2)}M`;
            } else if (ohlc.volume >= 1000) {
              volumeText = `${(ohlc.volume / 1000).toFixed(2)}K`;
            } else {
              volumeText = ohlc.volume.toFixed(0);
            }

            ctx.fillStyle = '#ffffff';
            ctx.fillText(volumeText, panelX + 35, currentY);
            currentY += lineHeight;
          }

          // Change and percentage in one line
          if (ohlc.change !== undefined && ohlc.changePercent !== undefined) {
            const changeText = ohlc.change >= 0 ? `+$${ohlc.change.toFixed(2)}` : `-$${Math.abs(ohlc.change).toFixed(2)}`;
            const percentText = ohlc.changePercent >= 0 ? `+${ohlc.changePercent.toFixed(2)}%` : `${ohlc.changePercent.toFixed(2)}%`;

            ctx.fillStyle = closeColor;
            ctx.font = 'bold 12px "Segoe UI", system-ui, sans-serif';
            ctx.fillText(`${changeText} (${percentText})`, panelX + 12, currentY);
            currentY += lineHeight - 2;
          }

          // Reset global alpha
          ctx.globalAlpha = 1.0;
        }
      }
    }

    // Draw box zoom selection
    if (isBoxZooming && boxZoomStart && boxZoomEnd) {
      const startX = Math.min(boxZoomStart.x, boxZoomEnd.x);
      const endX = Math.max(boxZoomStart.x, boxZoomEnd.x);
      const startY = Math.min(boxZoomStart.y, boxZoomEnd.y);
      const endY = Math.max(boxZoomStart.y, boxZoomEnd.y);

      // Box zoom selection overlay
      ctx.fillStyle = 'rgba(41, 98, 255, 0.1)'; // Blue with transparency
      ctx.strokeStyle = '#2962ff'; // Blue border
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);

      // Fill the selection area
      ctx.fillRect(startX, startY, endX - startX, endY - startY);

      // Stroke the border
      ctx.strokeRect(startX, startY, endX - startX, endY - startY);

      // Reset line dash
      ctx.setLineDash([]);

      // Add corner handles
      const handleSize = 6;
      ctx.fillStyle = '#2962ff';
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1;

      // Four corner handles
      const corners = [
        { x: startX, y: startY },
        { x: endX, y: startY },
        { x: startX, y: endY },
        { x: endX, y: endY }
      ];

      corners.forEach(corner => {
        ctx.fillRect(corner.x - handleSize / 2, corner.y - handleSize / 2, handleSize, handleSize);
        ctx.strokeRect(corner.x - handleSize / 2, corner.y - handleSize / 2, handleSize, handleSize);
      });

      // Add text instruction
      ctx.font = '12px "Segoe UI", system-ui, sans-serif';
      ctx.fillStyle = '#2962ff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const centerX = (startX + endX) / 2;
      const centerY = (startY + endY) / 2;
      ctx.fillText('Release to zoom', centerX, centerY);
    }
  }, [dimensions, config.crosshair, config.theme, crosshairPosition, crosshairInfo, isBoxZooming, boxZoomStart, boxZoomEnd]);

  // Update overlay when interactions change
  useEffect(() => {
    renderOverlay();
  }, [renderOverlay]);

  // Debug: Monitor drawings state changes
  useEffect(() => {
  }, [drawings]);

  // Keyboard shortcuts for TradingView-like functionality
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.target && (e.target as HTMLElement).tagName === 'INPUT') return; // Don't interfere with inputs

      switch (e.key) {
        case 'Home':
          e.preventDefault();
          // Go to beginning of data
          setScrollOffset(0);
          break;
        case 'End':
          e.preventDefault();
          // Go to end of data
          setScrollOffset(Math.max(0, data.length - visibleCandleCount));
          break;
        case '+':
        case '=':
          e.preventDefault();
          // Plus: X-axis zoom in (show fewer candles)
          const newCountIn = Math.max(20, Math.round(visibleCandleCount * 0.8));
          const centerRatio = (scrollOffset + visibleCandleCount / 2) / data.length;
          const newOffsetIn = Math.max(0, Math.min(
            data.length - newCountIn,
            Math.round(centerRatio * data.length - newCountIn / 2)
          ));
          setVisibleCandleCount(newCountIn);
          setScrollOffset(newOffsetIn);
          break;
        case '-':
          e.preventDefault();
          // Minus: X-axis zoom out (show more candles)
          const newCountOut = Math.min(500, Math.round(visibleCandleCount * 1.25));
          const centerRatioOut = (scrollOffset + visibleCandleCount / 2) / data.length;
          const newOffsetOut = Math.max(0, Math.min(
            data.length - newCountOut,
            Math.round(centerRatioOut * data.length - newCountOut / 2)
          ));
          setVisibleCandleCount(newCountOut);
          setScrollOffset(newOffsetOut);
          break;
        case 'ArrowLeft':
          e.preventDefault();
          // Pan left (go back in time)
          const panLeft = Math.max(1, Math.round(visibleCandleCount * 0.1));
          setScrollOffset(Math.max(0, scrollOffset - panLeft));
          break;
        case 'ArrowRight':
          e.preventDefault();
          // Pan right (go forward in time) - allow extending beyond data for future view
          const panRight = Math.max(1, Math.round(visibleCandleCount * 0.1));
          const futurePeriods = getFuturePeriods(visibleCandleCount);
          const maxFuturePeriods = Math.min(futurePeriods, Math.ceil(visibleCandleCount * 0.2));
          const maxScrollOffset = data.length - visibleCandleCount + maxFuturePeriods;
          setScrollOffset(Math.min(maxScrollOffset, scrollOffset + panRight));
          break;
        case 'ArrowUp':
          e.preventDefault();
          // TradingView: Arrow Up = Pan Y-axis up (show lower prices)
          if (manualPriceRange) {
            const priceSpan = manualPriceRange.max - manualPriceRange.min;
            const panAmount = priceSpan * 0.05; // Pan 5% of range
            setManualPriceRangeAndDisableAuto({
              min: manualPriceRange.min - panAmount,
              max: manualPriceRange.max - panAmount
            });
          }
          break;
        case 'ArrowDown':
          e.preventDefault();
          // TradingView: Arrow Down = Pan Y-axis down (show higher prices)
          if (manualPriceRange) {
            const priceSpan = manualPriceRange.max - manualPriceRange.min;
            const panAmount = priceSpan * 0.05; // Pan 5% of range
            setManualPriceRangeAndDisableAuto({
              min: manualPriceRange.min + panAmount,
              max: manualPriceRange.max + panAmount
            });
          }
          break;
        case 'a':
        case 'A':
          e.preventDefault();
          // TradingView: 'A' key = Toggle auto-scale
          if (isAutoScale) {
            // Switch to manual with current range
            const startIdx = Math.max(0, Math.floor(scrollOffset));
            const endIdx = Math.min(data.length, startIdx + visibleCandleCount);
            const visData = data.slice(startIdx, endIdx);
            if (visData.length > 0) {
              const currRange = getCurrentPriceRange(visData);
              setManualPriceRangeAndDisableAuto(currRange);
            }
          } else {
            // Switch back to auto-scale
            resetToAutoScale();
          }
          break;
        case 'r':
        case 'R':
          e.preventDefault();
          // Reset both X and Y axes to default view
          resetToAutoScale();
          setScrollOffset(Math.max(0, data.length - 100));
          setVisibleCandleCount(Math.min(100, data.length));
          break;
        case 'Delete':
        case 'Backspace':
          // Don't prevent default if user is typing in an input/textarea
          const target = e.target as HTMLElement;
          if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
            return;
          }
          e.preventDefault();
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [data.length, scrollOffset, visibleCandleCount, selectedChannel, getFuturePeriods, manualPriceRange, isAutoScale, setManualPriceRangeAndDisableAuto, resetToAutoScale, getCurrentPriceRange]);

  // ============================================================================
  // TRADINGVIEW-STYLE ZOOM & SCROLL - EXACT IMPLEMENTATION
  // ============================================================================
  // Wheel event handler - exactly like TradingView
  useEffect(() => {
    const handleWheelEvent = (e: WheelEvent) => {
      const overlayCanvas = overlayCanvasRef.current;
      const chartCanvas = chartCanvasRef.current;

      if (!overlayCanvas || !chartCanvas || data.length === 0) return;

      const target = e.target as Element;
      if (!overlayCanvas.contains(target) && !chartCanvas.contains(target) && target !== overlayCanvas && target !== chartCanvas) {
        return;
      }

      e.preventDefault();

      const rect = overlayCanvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const canvasWidth = overlayCanvas.width / window.devicePixelRatio;
      const canvasHeight = overlayCanvas.height / window.devicePixelRatio;

      const isOverYAxis = isInYAxisArea(mouseX, canvasWidth);

      if (isOverYAxis) {
        // TradingView Y-AXIS: Alt+Scroll = pan, plain scroll = zoom
        if (e.altKey) {
          // ALT + SCROLL on Y-axis = Vertical pan
          const startIndex = Math.max(0, Math.floor(scrollOffset));
          const endIndex = Math.min(data.length, startIndex + visibleCandleCount);
          const visibleData = data.slice(startIndex, endIndex);

          if (visibleData.length > 0) {
            const currentRange = manualPriceRange || getCurrentPriceRange(visibleData);
            const panAmount = e.deltaY > 0 ? 1 : -1;
            const priceSpan = currentRange.max - currentRange.min;
            const panPercent = 0.05; // Pan 5% of range per tick
            const priceShift = panAmount * priceSpan * panPercent;

            const newRange = {
              min: currentRange.min + priceShift,
              max: currentRange.max + priceShift
            };

            setManualPriceRangeAndDisableAuto(newRange);
          }
        } else {
          // Y-AXIS ZOOM - TradingView exact behavior
          const zoomIn = e.deltaY < 0;
          const zoomFactor = zoomIn ? 0.925 : 1.075; // 7.5% per scroll tick (50% faster)

          const startIndex = Math.max(0, Math.floor(scrollOffset));
          const endIndex = Math.min(data.length, startIndex + visibleCandleCount);
          const visibleData = data.slice(startIndex, endIndex);

          if (visibleData.length > 0) {
            // Get current range (manual or auto)
            const currentRange = manualPriceRange || getCurrentPriceRange(visibleData);
            const timeAxisHeight = 25;
            const priceChartHeight = canvasHeight - timeAxisHeight;

            // Price at mouse position
            const priceAtMouse = currentRange.max - ((mouseY / priceChartHeight) * (currentRange.max - currentRange.min));

            // Calculate new range maintaining mouse price position
            const currentSpan = currentRange.max - currentRange.min;
            const newSpan = currentSpan * zoomFactor;

            const mouseRatio = (priceAtMouse - currentRange.min) / currentSpan;

            const newRange = {
              min: priceAtMouse - (newSpan * mouseRatio),
              max: priceAtMouse + (newSpan * (1 - mouseRatio))
            };

            setManualPriceRangeAndDisableAuto(newRange);
          }
        }
      } else {
        // X-AXIS ZOOM/SCROLL - TradingView exact behavior
        const zoomIn = e.deltaY < 0;

        // TradingView: plain scroll = zoom, Ctrl = faster zoom, Alt = pan
        if (e.altKey) {
          // ALT + SCROLL = Horizontal pan (like TradingView)
          const panAmount = e.deltaY > 0 ? 3 : -3;
          const futurePeriods = getFuturePeriods(visibleCandleCount);
          const maxScrollOffset = data.length - visibleCandleCount + futurePeriods;
          const newOffset = Math.max(0, Math.min(maxScrollOffset, scrollOffset + panAmount));
          setScrollOffset(newOffset);
        } else {
          // PLAIN SCROLL or CTRL+SCROLL = Zoom
          const Y_AXIS_WIDTH = 80;
          const chartWidth = canvasWidth - Y_AXIS_WIDTH;

          // Calculate zoom factor - faster zoom speed
          const baseZoomFactor = e.ctrlKey || e.metaKey ? 0.375 : 0.18; // Ctrl = faster zoom (50% faster)
          const zoomMultiplier = zoomIn ? (1 - baseZoomFactor) : (1 + baseZoomFactor);

          const currentCount = visibleCandleCount;
          let newCount = Math.round(currentCount * zoomMultiplier);

          // Clamp candle count
          const minCandles = 5;
          const maxCandles = Math.min(data.length, 1000);
          newCount = Math.max(minCandles, Math.min(maxCandles, newCount));

          if (newCount !== currentCount) {
            // TradingView: zoom centers on mouse position
            const candleWidth = chartWidth / currentCount;
            const mouseChartX = Math.max(0, Math.min(chartWidth, mouseX));

            // Which candle is under the mouse
            const candleIndexUnderMouse = scrollOffset + (mouseChartX / candleWidth);

            // After zoom, keep that candle under mouse
            const newCandleWidth = chartWidth / newCount;
            const newScrollOffset = candleIndexUnderMouse - (mouseChartX / newCandleWidth);

            // Clamp scroll offset
            const futurePeriods = getFuturePeriods(newCount);
            const maxScrollOffset = data.length - newCount + futurePeriods;
            const clampedOffset = Math.max(0, Math.min(maxScrollOffset, newScrollOffset));

            setVisibleCandleCount(newCount);
            setScrollOffset(clampedOffset);
          }
        }
      }
    };

    const overlayCanvas = overlayCanvasRef.current;
    const chartCanvas = chartCanvasRef.current;

    if (overlayCanvas) {
      overlayCanvas.addEventListener('wheel', handleWheelEvent, { passive: false });
    }
    if (chartCanvas) {
      chartCanvas.addEventListener('wheel', handleWheelEvent, { passive: false });
    }

    return () => {
      if (overlayCanvas) {
        overlayCanvas.removeEventListener('wheel', handleWheelEvent);
      }
      if (chartCanvas) {
        chartCanvas.removeEventListener('wheel', handleWheelEvent);
      }
    };
  }, [data.length, scrollOffset, visibleCandleCount, isInYAxisArea, getCurrentPriceRange, setManualPriceRangeAndDisableAuto, getFuturePeriods, config.timeframe]);

  // Helper function to determine if a timestamp is during market hours
  const isMarketHours = (timestamp: number): boolean => {
    // Convert to PST/PDT timezone
    const date = new Date(timestamp);
    const pstString = date.toLocaleString("en-US", { timeZone: "America/Los_Angeles" });
    const pstDate = new Date(pstString);
    const hour = pstDate.getHours();
    const minute = pstDate.getMinutes();
    const totalMinutes = hour * 60 + minute;

    // Regular market hours: 6:30 AM - 1:00 PM PST (390 - 780 minutes)
    const marketOpen = 6 * 60 + 30; // 6:30 AM PST
    const marketClose = 13 * 60; // 1:00 PM PST

    return totalMinutes >= marketOpen && totalMinutes < marketClose;
  };

  // Draw market hours background shading
  const drawMarketHoursBackground = (
    ctx: CanvasRenderingContext2D,
    width: number,
    height: number,
    visibleData: ChartDataPoint[],
    chartWidth: number,
    visibleCandleCount: number
  ) => {
    // Only show market hours shading for intraday timeframes
    if (!config.timeframe.includes('m') && !config.timeframe.includes('h')) {
      return; // Skip for daily and longer timeframes
    }

    const candleSpacing = chartWidth / visibleCandleCount;

    visibleData.forEach((candle, index) => {
      const x = 40 + (index * candleSpacing);
      const isMarket = isMarketHours(candle.timestamp);

      if (!isMarket) {
        // Draw gray background for pre-market and after-hours
        ctx.fillStyle = colors.grid + '20'; // Semi-transparent gray
        ctx.fillRect(x, 0, candleSpacing, height);
      }
    });
  };

  // Render main price chart
  const renderChart = useCallback(() => {
    const canvas = chartCanvasRef.current;

    if (!canvas || !data.length || dimensions.width === 0 || dimensions.height === 0) {
      return;
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.log(`?? renderChart - no canvas context`);
      return;
    }

    const { width } = dimensions;
    const height = chartHeight;

    // Set canvas size with device pixel ratio
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.scale(dpr, dpr);

    // Enable crisp rendering for sharp lines and shapes
    ctx.imageSmoothingEnabled = false;
    (ctx as any).webkitImageSmoothingEnabled = false;
    (ctx as any).mozImageSmoothingEnabled = false;
    (ctx as any).msImageSmoothingEnabled = false;

    // Clear canvas with theme-appropriate background
    ctx.fillStyle = colors.background;
    ctx.fillRect(0, 0, width, height);

    // Calculate chart areas - reserve space for volume and time axis
    const timeAxisHeight = 30;
    const actualFlowChartHeight = isFlowChartActive ? flowChartHeight : 0; // Reserve space for flow chart when active
    const actualIVPanelHeight = isAnyIVHVActive ? (activeIVPanelCount * ivPanelHeight) : 0; // Reserve space for IV indicator panels
    const actualEventPanelHeight = 0; // No event panel needed
    const volumeAreaHeight = 80; // Volume bars area
    // Adjust price chart height based on active indicators
    const totalBottomSpace = actualFlowChartHeight + actualIVPanelHeight + actualEventPanelHeight + volumeAreaHeight + timeAxisHeight;
    const priceChartHeight = height - totalBottomSpace;

    // Draw grid first for price chart area (only if enabled)
    if (config.showGrid) {
      drawGrid(ctx, width, priceChartHeight);
    }

    // Calculate visible data range using scrollOffset and visibleCandleCount
    const startIndex = Math.max(0, Math.floor(scrollOffset));
    const endIndex = Math.min(data.length, startIndex + visibleCandleCount);

    const visibleData = data.slice(startIndex, endIndex);

    // ENHANCED: Handle future scrolling beyond actual data
    const beyondDataOffset = Math.max(0, scrollOffset + visibleCandleCount - data.length);
    const showingFutureSpace = beyondDataOffset > 0;

    // Only return if no data at all (not even in future space mode)
    if (visibleData.length === 0 && !showingFutureSpace && data.length === 0) return;

    // Calculate chart dimensions - only extend when scrolled near the end
    const chartWidth = width - 120; // Leave more space for price scale to prevent overlap

    // Check if we're showing future area (scrolled beyond data)
    const actualDataEnd = startIndex + visibleData.length;
    const requestedEnd = startIndex + visibleCandleCount;
    const showingFutureArea = requestedEnd > data.length;

    let totalPeriods = visibleCandleCount; // Always use full visible candle count for consistent spacing
    let limitedFuturePeriods = 0;

    if (showingFutureArea) {
      // We're in the future area, calculate how much
      limitedFuturePeriods = requestedEnd - data.length;
    }

    // Draw market hours background shading
    drawMarketHoursBackground(ctx, width, priceChartHeight, visibleData, chartWidth, visibleCandleCount);

    // Calculate price range for visible data using shared function
    // If showing only future space (no visible data), use the last 100 candles for price range
    let currentPriceRange;
    if (visibleData.length === 0 && data.length > 0) {
      // In future space - use last 100 candles for price context
      const lastDataSlice = data.slice(Math.max(0, data.length - 100));
      currentPriceRange = getCurrentPriceRange(lastDataSlice);
    } else {
      currentPriceRange = getCurrentChartPriceRange();
    }
    let adjustedMin = currentPriceRange.min;
    let adjustedMax = currentPriceRange.max;

    // Apply Y-axis zoom if not in auto-fit mode
    if (!isAutoFitPrice && priceZoomLevel !== 1.0) {
      const originalRange = adjustedMax - adjustedMin;
      const zoomedRange = originalRange / priceZoomLevel;

      // Use zoom center or current chart center
      const centerPrice = priceZoomCenter || (adjustedMin + adjustedMax) / 2;

      adjustedMin = centerPrice - zoomedRange / 2;
      adjustedMax = centerPrice + zoomedRange / 2;

      console.log(`ðŸ” Applied Y-axis zoom: level=${priceZoomLevel.toFixed(2)}, range=$${adjustedMin.toFixed(2)}-$${adjustedMax.toFixed(2)}`);
    }

    // Expand price range to include Expected Range levels if active
    if (isExpectedRangeActive && expectedRangeLevels) {
      const allLevels = [
        expectedRangeLevels.weekly80Call,
        expectedRangeLevels.weekly90Call,
        expectedRangeLevels.weekly80Put,
        expectedRangeLevels.weekly90Put,
        expectedRangeLevels.monthly80Call,
        expectedRangeLevels.monthly90Call,
        expectedRangeLevels.monthly80Put,
        expectedRangeLevels.monthly90Put
      ];

      const minLevel = Math.min(...allLevels);
      const maxLevel = Math.max(...allLevels);

      // Expand the range to include all Expected Range levels with some padding
      const originalRange = adjustedMax - adjustedMin;
      const padding = originalRange * 0.05; // 5% padding

      adjustedMin = Math.min(adjustedMin, minLevel - padding);
      adjustedMax = Math.max(adjustedMax, maxLevel + padding);
    }

    // Store the FINAL rendered range AFTER all adjustments for drag initialization
    lastRenderedPriceRangeRef.current = { min: adjustedMin, max: adjustedMax };

    // Draw chart in price chart area - use consistent spacing regardless of future area
    const candleWidth = Math.max(2, chartWidth / visibleCandleCount * 0.8);
    const candleSpacing = chartWidth / visibleCandleCount;

    // Save context and apply clipping to prevent overflow into volume/x-axis areas
    ctx.save();
    ctx.beginPath();
    ctx.rect(0, 0, width, priceChartHeight);
    ctx.clip();

    if (config.chartType === 'line') {
      // Draw line chart connecting close prices
      if (visibleData.length > 1) {
        ctx.strokeStyle = colors.bullish;
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();

        visibleData.forEach((candle, index) => {
          const x = 40 + (index * candleSpacing) + candleSpacing / 2;
          const closeY = priceChartHeight - ((candle.close - adjustedMin) / (adjustedMax - adjustedMin)) * priceChartHeight;

          if (index === 0) {
            ctx.moveTo(x, closeY);
          } else {
            ctx.lineTo(x, closeY);
          }
        });

        ctx.stroke();

        // Draw dots at each price point
        ctx.fillStyle = colors.bullish;
        visibleData.forEach((candle, index) => {
          const x = 40 + (index * candleSpacing) + candleSpacing / 2;
          const closeY = priceChartHeight - ((candle.close - adjustedMin) / (adjustedMax - adjustedMin)) * priceChartHeight;

          ctx.beginPath();
          ctx.arc(x, closeY, 2, 0, Math.PI * 2);
          ctx.fill();
        });
      }
    } else {
      // Draw candlesticks/bars/area/hollow candles
      visibleData.forEach((candle, index) => {
        const x = Math.round(40 + (index * candleSpacing) + (candleSpacing - candleWidth) / 2);
        drawCandle(ctx, candle, x, Math.round(candleWidth), priceChartHeight, adjustedMin, adjustedMax);
      });

      // ENHANCED: Draw future space grid when scrolled beyond actual data
      if (showingFutureSpace && beyondDataOffset > 0) {
        const futureStartX = Math.round(40 + (visibleData.length * candleSpacing));
        const futureWidth = width - futureStartX - 80; // Leave space for Y-axis
      }
    }

    // Restore context after clipping
    ctx.restore();

    // Draw price scale on the right for price chart area
    drawPriceScale(ctx, width, priceChartHeight, adjustedMin, adjustedMax);

    // Draw IV RRG start indicator line (dashed vertical line at first colored candle)
    if (isRRGCandleActive && (rrgMode === 'iv' || rrgMode === 'ivspy') && rrgIvStartTimestamp) {
      const startIndex = visibleData.findIndex(candle => candle.timestamp === rrgIvStartTimestamp);
      if (startIndex !== -1) {
        const lineX = Math.round(40 + (startIndex * candleSpacing) + candleSpacing / 2);
        ctx.save();
        ctx.strokeStyle = '#FFD700'; // Gold color
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]); // Dashed line
        ctx.beginPath();
        ctx.moveTo(lineX, 0);
        ctx.lineTo(lineX, priceChartHeight);
        ctx.stroke();
        ctx.setLineDash([]); // Reset dash

        // Add label at top
        ctx.fillStyle = '#FFD700';
        ctx.font = 'bold 11px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('IV Start', lineX, 12);
        ctx.restore();
      }
    }

    // Draw Expected Range lines on top of candlesticks (standalone button)
    if (isExpectedRangeActive && expectedRangeLevels) {
      if (isWeeklyActive) renderExpectedRangeLines(ctx, chartWidth, priceChartHeight, adjustedMin, adjustedMax, expectedRangeLevels, 'weekly', visibleData, visibleCandleCount);
      if (isMonthlyActive) renderExpectedRangeLines(ctx, chartWidth, priceChartHeight, adjustedMin, adjustedMax, expectedRangeLevels, 'monthly', visibleData, visibleCandleCount);
      if (isCustomActive) renderExpectedRangeLines(ctx, chartWidth, priceChartHeight, adjustedMin, adjustedMax, expectedRangeLevels, 'custom', visibleData, visibleCandleCount);
    }

    // Draw Seasonal Projection lines on top of candlesticks
    if (isSeasonalActive && visibleData && visibleData.length > 0) {
      const lastVisibleCandle = visibleData[visibleData.length - 1];
      const lastCandleTime = new Date(lastVisibleCandle.timestamp).getTime();
      const lastCandlePrice = lastVisibleCandle.close;
      const lastCandleIndex = visibleData.length - 1;
      const lastCandleX = 40 + (lastCandleIndex * candleSpacing) + candleSpacing / 2;
      const lastCandleY = priceChartHeight - ((lastCandlePrice - adjustedMin) / (adjustedMax - adjustedMin)) * priceChartHeight;

      // Helper function to draw a seasonal projection line
      const drawSeasonalLine = (projectionData: Array<{ date: Date, price: number }> | null, color: string, isDashed: boolean, eventLabel?: string) => {
        if (!projectionData || projectionData.length === 0) {
          console.log('âš ï¸ No projection data to draw');
          return;
        }

        // Helper to count trading days between dates (excluding weekends and holidays) - handles both directions
        const countTradingDaysBetween = (startDate: Date, endDate: Date): number => {
          const isWeekend = (d: Date) => d.getDay() === 0 || d.getDay() === 6;
          const isHoliday = (d: Date) => {
            const m = d.getMonth(), day = d.getDate(), dow = d.getDay();
            return (m === 0 && day === 1) || (m === 6 && day === 4) || (m === 11 && day === 25) ||
              (m === 0 && dow === 1 && day >= 15 && day <= 21) ||
              (m === 1 && dow === 1 && day >= 15 && day <= 21) ||
              (m === 4 && dow === 1 && day >= 25) ||
              (m === 8 && dow === 1 && day <= 7) ||
              (m === 10 && dow === 4 && day >= 22 && day <= 28);
          };

          const start = new Date(startDate);
          const end = new Date(endDate);
          start.setHours(0, 0, 0, 0);
          end.setHours(0, 0, 0, 0);

          // Determine direction
          const forward = end >= start;
          const current = new Date(forward ? start : end);
          const target = new Date(forward ? end : start);

          let count = 0;
          while (current < target) {
            current.setDate(current.getDate() + 1);
            if (!isWeekend(current) && !isHoliday(current)) count++;
          }

          return forward ? count : -count;
        };

        console.log('ðŸ–Œï¸ Drawing seasonal line with', projectionData.length, 'points, color:', color);
        const lastCandleDate = new Date(lastVisibleCandle.timestamp);
        lastCandleDate.setHours(0, 0, 0, 0);

        console.log('ðŸ“ Last candle date:', lastCandleDate.toISOString().split('T')[0]);
        console.log('ðŸ“ First projection date:', projectionData[0].date.toISOString().split('T')[0]);

        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;

        if (isDashed) {
          ctx.setLineDash([5, 5]);
        }

        ctx.beginPath();
        let firstPoint = true;
        let eventX = 0;
        let pointsDrawn = 0;

        // Draw projection line with proper date-based positioning
        projectionData.forEach((point, index) => {
          const projDate = new Date(point.date);
          projDate.setHours(0, 0, 0, 0);

          // Calculate trading days from last candle to this projection point
          const tradingDaysFromLast = countTradingDaysBetween(lastCandleDate, projDate);

          // Calculate x position based on trading days
          const x = Math.round(lastCandleX + (tradingDaysFromLast * candleSpacing));
          const y = priceChartHeight - ((point.price - adjustedMin) / (adjustedMax - adjustedMin)) * priceChartHeight;

          console.log(`  Point ${index}: date=${projDate.toISOString().split('T')[0]}, tradingDays=${tradingDaysFromLast}, x=${x}, y=${y}, price=${point.price.toFixed(2)}`);

          // Always draw the line, canvas will clip
          if (firstPoint) {
            ctx.moveTo(x, y);
            firstPoint = false;
          } else {
            ctx.lineTo(x, y);
          }
          pointsDrawn++;

          // Track event position - for earnings it's at index 10, others at index 5
          const isEarningsEvent = eventLabel && eventLabel.toLowerCase().includes('earnings');
          const expectedEventIndex = isEarningsEvent ? 10 : 5;
          if (index === expectedEventIndex) {
            eventX = x;
          }
        });

        if (pointsDrawn > 0) {
          ctx.stroke();
          console.log('âœ… Line stroked with', pointsDrawn, 'points');
        } else {
          console.warn('âš ï¸ No points drawn!');
        }
        ctx.setLineDash([]); // Reset dash

        // Draw vertical line at event date
        if (eventX >= 40 && eventX <= chartWidth) {
          ctx.save();
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.setLineDash([10, 5]);
          ctx.globalAlpha = 0.6;
          ctx.beginPath();
          ctx.moveTo(eventX, 0);
          ctx.lineTo(eventX, priceChartHeight);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();

          // Label event name at top
          if (eventLabel) {
            ctx.save();
            ctx.fillStyle = color;
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(eventLabel.toUpperCase(), eventX, 10);
            ctx.restore();
          }
        }

        // Draw numbered labels on each point
        projectionData.forEach((point, index) => {
          const projDate = new Date(point.date);
          projDate.setHours(0, 0, 0, 0);
          const tradingDaysFromLast = countTradingDaysBetween(lastCandleDate, projDate);
          const x = Math.round(lastCandleX + (tradingDaysFromLast * candleSpacing));
          const y = priceChartHeight - ((point.price - adjustedMin) / (adjustedMax - adjustedMin)) * priceChartHeight;

          if (x >= 40 && x <= chartWidth && y >= 0 && y <= priceChartHeight) {
            // Draw circle at point
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();

            // Draw number label
            ctx.fillStyle = color;
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(String(index + 1), x, y - 12);
          }
        });

        ctx.restore();
      };

      // Draw each active seasonal line with its color and style
      if (isSeasonal20YActive) drawSeasonalLine(seasonal20YData, '#FFFFFF', false); // Solid white
      if (isSeasonal15YActive) drawSeasonalLine(seasonal15YData, '#FFD700', false); // Solid yellow
      if (isSeasonal10YActive) drawSeasonalLine(seasonal10YData, '#4169E1', false); // Solid blue
      if (isSeasonalElectionActive) drawSeasonalLine(seasonalElectionData, '#9370DB', true); // Purple dashed
      if (isSeasonalEventActive) {
        console.log('ðŸŽ¨ Drawing event seasonal line, event:', selectedSeasonalEvent);
        console.log('   ðŸ“Š Data points:', seasonalEventData?.length || 0);
        if (seasonalEventData) {
          seasonalEventData.forEach((pt, idx) => {
            console.log(`   Point ${idx + 1}: ${pt.date.toISOString().split('T')[0]} = $${pt.price.toFixed(2)}`);
          });
        }
        drawSeasonalLine(seasonalEventData, '#00FF00', true, selectedSeasonalEvent || undefined); // Green dashed
      }
    }

    // Keep old seasonalProjectionData logic for backwards compatibility (remove later)
    if (isSeasonalActive && seasonalProjectionData && seasonalProjectionData.length > 0) {

      // Get last candle position from visible data
      if (visibleData && visibleData.length > 0) {
        const lastVisibleCandle = visibleData[visibleData.length - 1];
        const lastCandleTime = new Date(lastVisibleCandle.timestamp).getTime();
        const lastCandlePrice = lastVisibleCandle.close;

        // Calculate last candle x position using same coordinate system as candlesticks
        // Last visible candle is at index (visibleData.length - 1)
        const lastCandleIndex = visibleData.length - 1;
        const lastCandleX = 40 + (lastCandleIndex * candleSpacing) + candleSpacing / 2;

        // Draw the projection line starting from last visible candle
        ctx.save();
        ctx.strokeStyle = '#FFFFFF'; // Crispy white color
        ctx.lineWidth = 2;

        ctx.beginPath();

        // Start from last candle price
        const lastCandleY = priceChartHeight - ((lastCandlePrice - adjustedMin) / (adjustedMax - adjustedMin)) * priceChartHeight;
        ctx.moveTo(lastCandleX, lastCandleY);

        // Draw projection points
        let pointsDrawn = 0;
        let maxX = lastCandleX;

        seasonalProjectionData.forEach((point, index) => {
          const pointTime = point.date.getTime();

          // Calculate days from last candle
          const timeDiff = pointTime - lastCandleTime;
          const daysFromEnd = timeDiff / (24 * 60 * 60 * 1000);

          // Calculate x position (extend to the right from last candle)
          const x = lastCandleX + (daysFromEnd * candleSpacing);

          // Calculate y position based on price
          const y = priceChartHeight - ((point.price - adjustedMin) / (adjustedMax - adjustedMin)) * priceChartHeight;

          // Draw all points (even if off screen to the right)
          if (y >= 0 && y <= priceChartHeight) {
            ctx.lineTo(x, y);
            pointsDrawn++;
            maxX = Math.max(maxX, x);
          }
        });

        ctx.stroke();

        // Draw start marker at last candle
        ctx.beginPath();
        ctx.arc(lastCandleX, lastCandleY, 4, 0, 2 * Math.PI);
        ctx.fillStyle = '#FFFFFF';
        ctx.fill();

        // Draw end marker
        const lastPoint = seasonalProjectionData[seasonalProjectionData.length - 1];
        const lastPointTime = lastPoint.date.getTime();
        const daysFromEnd = (lastPointTime - lastCandleTime) / (24 * 60 * 60 * 1000);
        const endX = lastCandleX + (daysFromEnd * candleSpacing);
        const endY = priceChartHeight - ((lastPoint.price - adjustedMin) / (adjustedMax - adjustedMin)) * priceChartHeight;

        if (endY >= 0 && endY <= priceChartHeight) {
          ctx.beginPath();
          ctx.arc(endX, endY, 4, 0, 2 * Math.PI);
          ctx.fillStyle = '#FFFFFF';
          ctx.fill();
        }

        ctx.restore();
      }
    }

    // Draw GEX levels on top of candlesticks (standalone button)
    if (isGexActive && (liveGexData || gexData)) {
      const gexDataToUse = liveGexData || gexData;
      console.log(`ðŸŽ¯ Rendering GEX levels ${liveGexData ? 'with LIVE OI' : 'with snapshot OI'}`);
      console.log('ðŸ“Š GEX Data Source:', {
        hasLiveGexData: !!liveGexData,
        hasGexData: !!gexData,
        gexMode: gexMode,
        usingLive: !!liveGexData,
        totalCallGEX: gexDataToUse?.gexData?.totalCallGEX,
        totalPutGEX: gexDataToUse?.gexData?.totalPutGEX
      });
      renderGEXLevels(
        ctx,
        chartWidth,
        priceChartHeight,
        adjustedMin,
        adjustedMax,
        gexDataToUse,
        visibleData,
        visibleCandleCount
      );
      console.log('âœ… GEX levels rendered');
    } // Draw Expansion/Liquidation zones (standalone button)
    if (isExpansionLiquidationActive) {
      console.log('?? Detecting and rendering Expansion/Liquidation zones');

      // Get all data for zone detection (not just visible data)
      const allZones = detectExpansionLiquidation(data);
      const validZones = invalidateTouchedZones(allZones, data);

      // Render zones that are in the visible range (using the same startIndex and endIndex as candlesticks)
      validZones.forEach(zone => {
        if (!zone.isValid) return;

        // Check if zone breakout is in visible range
        if (zone.breakoutIndex >= startIndex && zone.breakoutIndex <= endIndex + 50) {
          renderExpansionLiquidationZone(
            ctx,
            zone,
            data,
            chartWidth,
            priceChartHeight,
            adjustedMin,
            adjustedMax,
            startIndex,
            visibleCandleCount
          );
        }
      });

      console.log(`?? Rendered ${validZones.filter(z => z.isValid).length} valid zones`);
    }

    // Draw Technalysis indicators
    const anyFeatureEnabled = technalysisActive || Object.values(technalysisFeatures).some(f => f);
    if (anyFeatureEnabled) {
      console.log('ðŸ”¥ Rendering Technalysis indicators');
      renderTechnalysisIndicators(
        ctx,
        data,
        chartWidth,
        priceChartHeight,
        adjustedMin,
        adjustedMax,
        startIndex,
        visibleCandleCount,
        technalysisFeatures
      );
    }

    // Draw flow chart above volume if active (only on 5min timeframe)
    if (isFlowChartActive && flowChartData.length > 0) {
      console.log(`ðŸ” Flow Chart Check: timeframe=${config.timeframe}, flowData=${flowChartData.length}, visibleData=${visibleData.length}`);

      // DEBUG: Log candlestick timestamps
      if (visibleData.length > 0) {
        console.log('ðŸ” DEBUG: Sample candlestick timestamps:');
        visibleData.slice(0, 5).forEach(candle => {
          const date = new Date(candle.timestamp);
          console.log(`  Candle => timestamp: ${candle.timestamp} => ${date.toISOString()} => ET: ${date.toLocaleString('en-US', { timeZone: 'America/New_York' })}`);
        });
      }

      if (config.timeframe === '5min' || config.timeframe === '5m') {
        // Filter flow data to match visible candlestick time range
        const visibleFlowData = flowChartData.filter(point => {
          if (visibleData.length === 0) return false;
          const firstCandleTime = new Date(visibleData[0].timestamp).getTime();
          const lastCandleTime = new Date(visibleData[visibleData.length - 1].timestamp).getTime();
          return point.time >= firstCandleTime && point.time <= lastCandleTime;
        });

        if (visibleData.length > 0) {
          console.log(`ðŸ“Š First candle: ${new Date(visibleData[0].timestamp).toISOString()}`);
          console.log(`ðŸ“Š Last candle: ${new Date(visibleData[visibleData.length - 1].timestamp).toISOString()}`);
          console.log(`ðŸ“Š First flow: ${new Date(flowChartData[0].time).toISOString()}`);
          console.log(`ðŸ“Š Last flow: ${new Date(flowChartData[flowChartData.length - 1].time).toISOString()}`);
        }
        console.log(`âœ… Rendering flow chart with ${visibleFlowData.length} visible points`);
        if (visibleFlowData.length > 0) {
          // Y-axis at fixed position on the right
          const yAxisXPos = chartWidth - 85;

          drawFlowChart(ctx, visibleFlowData, visibleData, chartWidth, priceChartHeight, visibleCandleCount, actualFlowChartHeight, yAxisXPos);
        }
      } else {
        console.log(`âš ï¸ Flow chart only displays on 5min timeframe (current: ${config.timeframe})`);
      }
    }

    // Draw IV/HV indicator panels after flow chart
    if (isAnyIVHVActive) {
      let currentPanelY = priceChartHeight + actualFlowChartHeight + actualEventPanelHeight;

      // If no data yet, show loading panels
      if (ivData.length === 0) {
        // Draw loading panel placeholder
        const drawLoadingPanel = (panelY: number, panelTitle: string) => {
          ctx.fillStyle = '#000000';
          ctx.fillRect(0, panelY, chartWidth, ivPanelHeight);
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(0, panelY);
          ctx.lineTo(chartWidth, panelY);
          ctx.stroke();

          ctx.font = 'bold 12px JetBrains Mono, monospace';
          ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
          ctx.textAlign = 'center';
          ctx.fillText(`Loading ${panelTitle}...`, chartWidth / 2, panelY + ivPanelHeight / 2 + 4);
        };

        if (showIVIndicator) {
          drawLoadingPanel(currentPanelY, 'IV Data');
          currentPanelY += ivPanelHeight;
        }
        if (showIVRankIndicator) {
          drawLoadingPanel(currentPanelY, 'IV Rank');
          currentPanelY += ivPanelHeight;
        }
        if (showIVPercentileIndicator) {
          drawLoadingPanel(currentPanelY, 'IV Percentile');
          currentPanelY += ivPanelHeight;
        }
        if (showHVIndicator) {
          drawLoadingPanel(currentPanelY, 'Historical Volatility');
          currentPanelY += ivPanelHeight;
        }
      } else {
        // Draw each active indicator panel with data
        if (showIVIndicator) {
          drawIVPanel(ctx, 'iv', ivData, visibleData, chartWidth, currentPanelY, visibleCandleCount, ivPanelHeight);
          currentPanelY += ivPanelHeight;
        }
        if (showIVRankIndicator) {
          drawIVPanel(ctx, 'ivRank', ivData, visibleData, chartWidth, currentPanelY, visibleCandleCount, ivPanelHeight);
          currentPanelY += ivPanelHeight;
        }
        if (showIVPercentileIndicator) {
          drawIVPanel(ctx, 'ivPercentile', ivData, visibleData, chartWidth, currentPanelY, visibleCandleCount, ivPanelHeight);
          currentPanelY += ivPanelHeight;
        }
        if (showHVIndicator) {
          drawIVPanel(ctx, 'hv', ivData, visibleData, chartWidth, currentPanelY, visibleCandleCount, ivPanelHeight);
          currentPanelY += ivPanelHeight;
        }
      }
    }

    // Draw volume bars above the time axis (TradingView style)
    drawVolumeProfile(ctx, visibleData, chartWidth, priceChartHeight + actualFlowChartHeight + actualEventPanelHeight + actualIVPanelHeight, visibleCandleCount, volumeAreaHeight, timeAxisHeight, config);

    // Draw time axis at the bottom
    drawTimeAxis(ctx, width, height, visibleData, chartWidth, visibleCandleCount, scrollOffset, data);

    // Draw stored drawings on overlay canvas (not main chart)
    const overlayCanvas = overlayCanvasRef.current;
    if (overlayCanvas) {
      const overlayCtx = overlayCanvas.getContext('2d');
      if (overlayCtx) {
        drawStoredDrawings(overlayCtx);
      }
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [data.length, dimensions.width, dimensions.height, scrollOffset, visibleCandleCount, isFlowChartActive, flowChartData, flowChartViewMode, flowChartHeight, isAnyIVHVActive, ivData, ivData.length, isIVLoading, showIVPanel, showIVIndicator, showCallIVLine, showPutIVLine, showNetIVLine, showIVRankIndicator, showIVPercentileIndicator, showHVIndicator, ivPanelHeight, hvWindow, activeIVPanelCount]); // Draw volume bars above the x-axis (TradingView style)
  const drawVolumeProfile = (
    ctx: CanvasRenderingContext2D,
    visibleData: ChartDataPoint[],
    chartWidth: number,
    priceChartHeight: number,
    visibleCandleCount: number,
    volumeAreaHeight: number = 80,
    timeAxisHeight: number = 25,
    config: ChartConfig
  ) => {
    // Early return if no data or no volume data
    if (!visibleData.length) return;

    // Calculate volume profile area - dedicated space between price chart and time axis
    const volumeStartY = priceChartHeight + 20; // Start 20px lower
    const volumeEndY = priceChartHeight + volumeAreaHeight - 5; // End 5px higher

    // Draw subtle volume background area (reduced height)
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(40, volumeStartY, chartWidth - 80, volumeEndY - volumeStartY);

    // Find max volume for scaling
    const volumes = visibleData.map(d => d.volume || 0).filter(v => v > 0);

    // Require real volume data - no fallback
    if (volumes.length === 0) {
      console.error('âŒ NO VOLUME DATA - Cannot render volume chart');
      return;
    }

    const maxVolume = Math.max(...volumes);
    const candleSpacing = chartWidth / visibleCandleCount;
    const candleWidth = Math.max(1, candleSpacing * 0.8);

    // Remove volume border - commented out for cleaner look
    // ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    // ctx.lineWidth = 1;
    // ctx.strokeRect(40, volumeStartY, chartWidth - 80, volumeAreaHeight);

    // Draw volume bars
    visibleData.forEach((candle, index) => {
      const x = Math.round(40 + (index * candleSpacing) + (candleSpacing - candleWidth) / 2);

      // Use only real volume data
      const volumeValue = candle.volume;
      if (!volumeValue || volumeValue <= 0) return;

      const volumeHeight = (volumeValue / maxVolume) * volumeAreaHeight;
      const barY = volumeEndY - volumeHeight;

      // Color volume bars based on price movement and user settings
      const isGreen = candle.close > candle.open;
      const volumeColor = isGreen ? config.colors.volume.bullish : config.colors.volume.bearish;

      // Solid colors - 100% opacity
      ctx.fillStyle = volumeColor;

      // Draw volume bar
      ctx.fillRect(x, barY, Math.round(candleWidth), volumeHeight);
    });

    // Draw volume scale labels on the right
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'left';
    ctx.globalAlpha = 1.0;

    // Draw volume labels (3 levels: 0, 50%, 100%)
    for (let i = 0; i <= 2; i++) {
      const volumeLevel = (maxVolume / 2) * i;
      const y = volumeEndY - (i * volumeAreaHeight / 2);

      // Format volume for display
      let volumeText = '';
      if (volumeLevel >= 1000000) {
        volumeText = `${(volumeLevel / 1000000).toFixed(1)}M`;
      } else if (volumeLevel >= 1000) {
        volumeText = `${(volumeLevel / 1000).toFixed(1)}K`;
      } else {
        volumeText = volumeLevel.toFixed(0);
      }

      // Position volume labels even MORE RIGHT 
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'right';
      ctx.fillText(volumeText, chartWidth + 80, y + 6); // Much further beyond chart edge

      // Draw tick mark at edge
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(chartWidth - 10, y);
      ctx.lineTo(chartWidth - 5, y);
      ctx.stroke();
    }

    // Remove volume label - text removed for cleaner look
    // ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    // ctx.font = 'bold 10px Arial';
  };

  // Draw 4-line flow chart indicator (like AlgoFlow screener)
  const drawFlowChart = (
    ctx: CanvasRenderingContext2D,
    flowData: Array<{ time: number; timeLabel: string; callsPlus: number; callsMinus: number; putsPlus: number; putsMinus: number; bullishTotal: number; bearishTotal: number; netFlow: number }>,
    visibleData: ChartDataPoint[],
    chartWidth: number,
    priceChartHeight: number,
    visibleCandleCount: number,
    flowChartHeight: number,
    yAxisXPosition: number
  ) => {
    if (!flowData.length || !visibleData.length) return;

    const flowStartY = priceChartHeight;
    const flowEndY = priceChartHeight + flowChartHeight;

    // Draw background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(40, flowStartY, chartWidth - 120, flowChartHeight);

    // Add padding for Y-axis labels inside the box
    const yAxisPadding = 25;
    const effectiveFlowStartY = flowStartY + yAxisPadding;
    const effectiveFlowEndY = flowEndY - yAxisPadding;
    const effectiveFlowHeight = effectiveFlowEndY - effectiveFlowStartY;

    // Calculate candle spacing to align with price chart
    const candleSpacing = chartWidth / visibleCandleCount;

    // Create a map of candlestick timestamps to x positions
    const candlePositions = new Map<number, number>();
    visibleData.forEach((candle, index) => {
      const candleTime = new Date(candle.timestamp).getTime();
      const x = 40 + (index * candleSpacing) + (candleSpacing / 2); // Center of candle
      candlePositions.set(candleTime, x);
    });

    // Determine which lines to draw based on flowChartViewMode
    let linesToDraw: Array<{ key: string; color: string; name: string; isNegative?: boolean }> = [];
    let maxValue = 1;

    if (flowChartViewMode === 'detailed') {
      // Find max value for scaling (across all 4 lines)
      const allValues = flowData.flatMap(d => [d.callsPlus, d.callsMinus, d.putsPlus, d.putsMinus]);
      maxValue = Math.max(...allValues, 1);

      linesToDraw = [
        { key: 'callsPlus', color: '#00FF00', name: 'Bullish Calls' },
        { key: 'callsMinus', color: '#0066FF', name: 'Bearish Calls' },
        { key: 'putsPlus', color: '#FF8800', name: 'Bullish Puts' },
        { key: 'putsMinus', color: '#FF0000', name: 'Bearish Puts' }
      ];
    } else if (flowChartViewMode === 'simplified') {
      // Find max absolute value for scaling (bullishTotal positive, bearishTotal negative)
      const allValues = flowData.flatMap(d => [Math.abs(d.bullishTotal), Math.abs(d.bearishTotal)]);
      maxValue = Math.max(...allValues, 1);

      linesToDraw = [
        { key: 'bullishTotal', color: '#00FF00', name: 'Bullish Total', isNegative: false },
        { key: 'bearishTotal', color: '#FF0000', name: 'Bearish Total', isNegative: true }
      ];
    } else if (flowChartViewMode === 'net') {
      // Find max absolute value for scaling (netFlow can be positive or negative)
      const allValues = flowData.map(d => Math.abs(d.netFlow));
      maxValue = Math.max(...allValues, 1);

      linesToDraw = [
        { key: 'netFlow', color: '#ffffff', name: 'Net Flow' }
      ];
    }

    // Draw horizontal zero line for simplified and net modes
    if (flowChartViewMode === 'simplified' || flowChartViewMode === 'net') {
      const zeroY = effectiveFlowStartY + (effectiveFlowHeight / 2);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(40, zeroY);
      ctx.lineTo(chartWidth - 40, zeroY);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Draw lines
    linesToDraw.forEach(line => {
      if (flowChartViewMode === 'net') {
        // For net flow mode, draw segment by segment with color based on value
        let firstPoint = true;
        let prevX: number | null = null;
        let prevY: number | null = null;
        let prevValue: number | null = null;

        flowData.forEach((point, index) => {
          const x = candlePositions.get(point.time);

          if (x !== undefined) {
            let value = (point as any)[line.key];
            const centerY = effectiveFlowStartY + (effectiveFlowHeight / 2);
            const normalizedValue = (Math.abs(value) / maxValue) * (effectiveFlowHeight / 2);
            const y = value >= 0 ? centerY - normalizedValue : centerY + normalizedValue;

            if (!firstPoint && prevX !== null && prevY !== null && prevValue !== null) {
              // Draw segment with color based on current value
              ctx.strokeStyle = value >= 0 ? '#00FF00' : '#FF0000';
              ctx.lineWidth = 3;
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.globalAlpha = 1.0;
              ctx.beginPath();
              ctx.moveTo(prevX, prevY);
              ctx.lineTo(x, y);
              ctx.stroke();
            }

            prevX = x;
            prevY = y;
            prevValue = value;
            firstPoint = false;
          }
        });
      } else {
        // Original logic for detailed and simplified modes
        ctx.strokeStyle = line.color;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.globalAlpha = 1.0;
        ctx.beginPath();

        let firstPoint = true;
        flowData.forEach((point) => {
          const x = candlePositions.get(point.time);

          if (x !== undefined) {
            let value = (point as any)[line.key];

            // For simplified mode, normalize around center line
            let y: number;
            if (flowChartViewMode === 'simplified') {
              const centerY = effectiveFlowStartY + (effectiveFlowHeight / 2);
              const normalizedValue = (Math.abs(value) / maxValue) * (effectiveFlowHeight / 2);
              y = value >= 0 ? centerY - normalizedValue : centerY + normalizedValue;
            } else {
              // Detailed mode: scale from bottom
              const normalizedValue = (value / maxValue) * effectiveFlowHeight;
              y = effectiveFlowEndY - normalizedValue;
            }

            if (firstPoint) {
              ctx.moveTo(x, y);
              firstPoint = false;
            } else {
              ctx.lineTo(x, y);
            }
          }
        });

        ctx.stroke();
      }
    });

    // Reset alpha
    ctx.globalAlpha = 1.0;

    // Draw line labels at the end of each line
    const lastPoint = flowData[flowData.length - 1];
    const lastCandleX = candlePositions.get(lastPoint.time);

    if (lastCandleX !== undefined) {
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'left';

      // Calculate vertical positions to avoid overlap
      let labelYPositions: Array<{ y: number; height: number }> = [];

      linesToDraw.forEach((line, index) => {
        let value = (lastPoint as any)[line.key];

        // Calculate y position based on line value
        let targetY: number;
        if (flowChartViewMode === 'simplified' || flowChartViewMode === 'net') {
          const centerY = effectiveFlowStartY + (effectiveFlowHeight / 2);
          const normalizedValue = (Math.abs(value) / maxValue) * (effectiveFlowHeight / 2);
          targetY = value >= 0 ? centerY - normalizedValue : centerY + normalizedValue;
        } else {
          const normalizedValue = (value / maxValue) * effectiveFlowHeight;
          targetY = effectiveFlowEndY - normalizedValue;
        }

        // Adjust y position to avoid overlap with previously drawn labels
        let adjustedY = targetY;
        const labelHeight = 24;
        const minSpacing = 30;

        for (const prevLabel of labelYPositions) {
          if (Math.abs(adjustedY - prevLabel.y) < minSpacing) {
            // Overlap detected, shift down
            if (adjustedY >= prevLabel.y) {
              adjustedY = prevLabel.y + minSpacing;
            } else {
              adjustedY = prevLabel.y - minSpacing;
            }
          }
        }

        labelYPositions.push({ y: adjustedY, height: labelHeight });

        // Draw background box for better readability
        const textWidth = ctx.measureText(line.name).width;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(lastCandleX + 8, adjustedY - 14, textWidth + 12, 24);

        // Draw colored label at the end of the line
        // For net flow mode, use the color based on current value
        if (flowChartViewMode === 'net') {
          ctx.fillStyle = value >= 0 ? '#00FF00' : '#FF0000';
        } else {
          ctx.fillStyle = line.color;
        }
        ctx.fillText(line.name, lastCandleX + 14, adjustedY + 4);
      });
    }

    // Draw scale labels (always visible)
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'right';
    ctx.globalAlpha = 1.0;

    if (flowChartViewMode === 'detailed') {
      // Detailed mode: 0 at bottom, max at top (4 values)
      ctx.fillStyle = '#FF8800';
      for (let i = 0; i <= 3; i++) {
        const valueLevel = (maxValue / 3) * i;
        const y = effectiveFlowEndY - (i * effectiveFlowHeight / 3);

        let valueText = '';
        if (valueLevel >= 1000000) {
          valueText = `$${(valueLevel / 1000000).toFixed(1)}M`;
        } else if (valueLevel >= 1000) {
          valueText = `$${(valueLevel / 1000).toFixed(0)}K`;
        } else {
          valueText = `$${valueLevel.toFixed(0)}`;
        }

        ctx.fillText(valueText, yAxisXPosition, y + 6);
      }
    } else {
      // Simplified/Net mode: negative at bottom, 0 in center, positive at top
      const centerY = effectiveFlowStartY + (effectiveFlowHeight / 2);
      const steps = 2; // 2 steps above and 2 below zero = 5 total labels

      for (let i = -steps; i <= steps; i++) {
        const valueLevel = (maxValue / steps) * i;
        const y = centerY - (i * effectiveFlowHeight / (steps * 2));

        // Color based on value: green for positive, orange for zero, red for negative
        if (i > 0) {
          ctx.fillStyle = '#00FF00'; // Green for positive
        } else if (i < 0) {
          ctx.fillStyle = '#FF0000'; // Red for negative
        } else {
          ctx.fillStyle = '#FF8800'; // Orange for zero
        }

        let valueText = '';
        if (i === 0) {
          valueText = '$0';
        } else if (Math.abs(valueLevel) >= 1000000) {
          valueText = `${i < 0 ? '-' : ''}$${(Math.abs(valueLevel) / 1000000).toFixed(1)}M`;
        } else if (Math.abs(valueLevel) >= 1000) {
          valueText = `${i < 0 ? '-' : ''}$${(Math.abs(valueLevel) / 1000).toFixed(0)}K`;
        } else {
          valueText = `${i < 0 ? '-' : ''}$${Math.abs(valueLevel).toFixed(0)}`;
        }

        ctx.fillText(valueText, yAxisXPosition, y + 6);
      }
    }
  };

  // Draw IV/HV indicator panels at the bottom of the chart (TradingView style)
  const drawIVPanel = (
    ctx: CanvasRenderingContext2D,
    panelType: 'iv' | 'ivRank' | 'ivPercentile' | 'hv',
    ivDataArray: typeof ivData,
    visibleData: ChartDataPoint[],
    chartWidth: number,
    panelStartY: number,
    visibleCandleCount: number,
    panelHeight: number
  ) => {
    if (!ivDataArray.length || !visibleData.length) return;

    const panelEndY = panelStartY + panelHeight;

    // Panel colors based on type - black background, crisp bright lines
    const panelConfig = {
      iv: { title: 'IMPLIED VOLATILITY', lineColor: '#FF9500', bgColor: '#000000' },
      ivRank: { title: 'IV RANK', lineColor: '#FF6B9D', bgColor: '#000000' },
      ivPercentile: { title: 'IV PERCENTILE', lineColor: '#00FF88', bgColor: '#000000' },
      hv: { title: `HISTORICAL VOLATILITY (${hvWindow}D)`, lineColor: '#00D4FF', bgColor: '#000000' }
    };

    const config = panelConfig[panelType];

    // Draw panel background - solid black
    ctx.fillStyle = config.bgColor;
    ctx.fillRect(40, panelStartY, chartWidth - 120, panelHeight);

    // Draw panel border at top
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(40, panelStartY);
    ctx.lineTo(chartWidth - 80, panelStartY);
    ctx.stroke();

    // Draw panel title
    ctx.font = 'bold 11px JetBrains Mono, monospace';
    ctx.fillStyle = '#FFFFFF';
    ctx.textAlign = 'left';
    ctx.fillText(config.title, 50, panelStartY + 15);

    // Add padding for chart area
    const yAxisPadding = 20;
    const effectivePanelStartY = panelStartY + yAxisPadding;
    const effectivePanelEndY = panelEndY - 10;
    const effectivePanelHeight = effectivePanelEndY - effectivePanelStartY;

    // Calculate candle spacing to align with price chart
    const candleSpacing = chartWidth / visibleCandleCount;

    // Create a date to x position mapping
    const datePositions = new Map<string, number>();
    visibleData.forEach((candle, index) => {
      const dateStr = candle.date;
      const x = 40 + (index * candleSpacing) + (candleSpacing / 2);
      datePositions.set(dateStr, x);
    });

    // For IV panel, we may draw multiple lines (Call, Put, Net)
    if (panelType === 'iv') {
      // Calculate min/max across all IV types for consistent scaling
      let minValue = Infinity;
      let maxValue = -Infinity;

      ivDataArray.forEach(item => {
        if (showCallIVLine && item.callIV !== null) {
          minValue = Math.min(minValue, item.callIV);
          maxValue = Math.max(maxValue, item.callIV);
        }
        if (showPutIVLine && item.putIV !== null) {
          minValue = Math.min(minValue, item.putIV);
          maxValue = Math.max(maxValue, item.putIV);
        }
        if (showNetIVLine && item.netIV !== null) {
          minValue = Math.min(minValue, item.netIV);
          maxValue = Math.max(maxValue, item.netIV);
        }
      });

      const range = maxValue - minValue;
      const paddedMin = minValue - range * 0.1;
      const paddedMax = maxValue + range * 0.1;
      const paddedRange = paddedMax - paddedMin;

      // Define line configs for IV
      const ivLines = [
        { key: 'callIV', color: '#00FF00', name: 'Call IV', show: showCallIVLine },
        { key: 'putIV', color: '#FF0000', name: 'Put IV', show: showPutIVLine },
        { key: 'netIV', color: '#FF9500', name: 'Net IV', show: showNetIVLine }
      ];

      // Draw each active IV line
      ivLines.forEach(lineConfig => {
        if (!lineConfig.show) return;

        ctx.strokeStyle = lineConfig.color;
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();

        let firstPoint = true;
        let lastX = 0;
        let lastY = 0;
        let lastValue: number | null = null;

        ivDataArray.forEach(item => {
          const x = datePositions.get(item.date);
          const value = (item as any)[lineConfig.key] as number | null;

          if (x !== undefined && value !== null) {
            const y = effectivePanelEndY - ((value - paddedMin) / paddedRange) * effectivePanelHeight;

            if (firstPoint) {
              ctx.moveTo(x, y);
              firstPoint = false;
            } else {
              ctx.lineTo(x, y);
            }

            lastX = x;
            lastY = y;
            lastValue = value;
          }
        });

        ctx.stroke();

        // Draw label at end of line
        if (lastValue !== null && typeof lastValue === 'number') {
          ctx.font = 'bold 11px JetBrains Mono, monospace';
          ctx.textAlign = 'left';
          const labelText = `${lineConfig.name}: ${(lastValue as number).toFixed(2)}%`;
          const textWidth = ctx.measureText(labelText).width;

          ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
          ctx.fillRect(lastX + 5, lastY - 8, textWidth + 8, 16);

          ctx.fillStyle = lineConfig.color;
          ctx.fillText(labelText, lastX + 9, lastY + 4);
        }
      });

      // Draw Y-axis scale labels
      ctx.font = 'bold 12px JetBrains Mono, monospace';
      ctx.textAlign = 'right';
      ctx.fillStyle = '#FFFFFF';

      const steps = 3;
      for (let i = 0; i <= steps; i++) {
        const value = paddedMin + (paddedRange / steps) * i;
        const y = effectivePanelEndY - (i * effectivePanelHeight / steps);
        ctx.fillText(`${value.toFixed(1)}%`, chartWidth - 45, y + 4);
      }

      return; // Exit early for IV panel
    }

    // Get the appropriate data key for non-IV panels
    const getDataValue = (item: typeof ivData[0]): number | null => {
      switch (panelType) {
        case 'ivRank': return item.ivRank;
        case 'ivPercentile': return item.ivPercentile;
        case 'hv': return item.hv;
        default: return null;
      }
    };

    // Calculate min/max for scaling
    let minValue = Infinity;
    let maxValue = -Infinity;

    ivDataArray.forEach(item => {
      const value = getDataValue(item);
      if (value !== null) {
        minValue = Math.min(minValue, value);
        maxValue = Math.max(maxValue, value);
      }
    });

    // For rank and percentile, use 0-100 scale
    if (panelType === 'ivRank' || panelType === 'ivPercentile') {
      minValue = 0;
      maxValue = 100;
    }

    // Add padding to the range
    const range = maxValue - minValue;
    const paddedMin = panelType === 'ivRank' || panelType === 'ivPercentile' ? 0 : minValue - range * 0.1;
    const paddedMax = panelType === 'ivRank' || panelType === 'ivPercentile' ? 100 : maxValue + range * 0.1;
    const paddedRange = paddedMax - paddedMin;

    // Draw 50% reference line for rank and percentile
    if (panelType === 'ivRank' || panelType === 'ivPercentile') {
      const y50 = effectivePanelEndY - ((50 - paddedMin) / paddedRange) * effectivePanelHeight;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(40, y50);
      ctx.lineTo(chartWidth - 80, y50);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Draw the line chart - crisp solid line
    ctx.strokeStyle = config.lineColor;
    ctx.lineWidth = 2.5;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.imageSmoothingEnabled = false;
    ctx.beginPath();

    let firstPoint = true;
    let lastX = 0;
    let lastY = 0;
    let lastValue: number | null = null;

    ivDataArray.forEach(item => {
      const x = datePositions.get(item.date);
      const value = getDataValue(item);

      if (x !== undefined && value !== null) {
        const y = effectivePanelEndY - ((value - paddedMin) / paddedRange) * effectivePanelHeight;

        if (firstPoint) {
          ctx.moveTo(x, y);
          firstPoint = false;
        } else {
          ctx.lineTo(x, y);
        }

        lastX = x;
        lastY = y;
        lastValue = value;
      }
    });

    ctx.stroke();

    // Draw current value label at the end of the line
    if (lastValue !== null && typeof lastValue === 'number') {
      ctx.font = 'bold 12px JetBrains Mono, monospace';
      ctx.textAlign = 'left';

      // Draw background box
      const displayValue = lastValue as number;
      const labelText = panelType === 'ivRank' || panelType === 'ivPercentile'
        ? `${displayValue.toFixed(1)}%`
        : `${displayValue.toFixed(2)}%`;
      const textWidth = ctx.measureText(labelText).width;

      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(lastX + 5, lastY - 10, textWidth + 10, 20);

      ctx.fillStyle = config.lineColor;
      ctx.fillText(labelText, lastX + 10, lastY + 4);
    }

    // Draw Y-axis scale labels - crispy white text
    ctx.font = 'bold 12px JetBrains Mono, monospace';
    ctx.textAlign = 'right';
    ctx.fillStyle = '#FFFFFF';

    const steps = 3;
    for (let i = 0; i <= steps; i++) {
      const value = paddedMin + (paddedRange / steps) * i;
      const y = effectivePanelEndY - (i * effectivePanelHeight / steps);

      const labelText = panelType === 'ivRank' || panelType === 'ivPercentile'
        ? `${value.toFixed(0)}%`
        : `${value.toFixed(1)}%`;

      ctx.fillText(labelText, chartWidth - 45, y + 4);
    }
  };

  // Draw grid lines for price chart area only
  const drawGrid = (ctx: CanvasRenderingContext2D, width: number, priceHeight: number) => {
    ctx.strokeStyle = colors.grid;
    ctx.lineWidth = 1;

    // Horizontal grid lines (price levels) - only in price chart area
    for (let i = 0; i <= 10; i++) {
      const y = (priceHeight / 10) * i;
      ctx.beginPath();
      ctx.moveTo(50, y);
      ctx.lineTo(width - 20, y);
      ctx.stroke();
    }

    // Vertical grid lines (time)
    const gridSpacing = Math.max(50, (width - 70) / 20);
    for (let x = 50; x < width - 20; x += gridSpacing) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, priceHeight);
      ctx.stroke();
    }
  };

  // Technical Indicator Calculations
  const calculateRSI = (data: ChartDataPoint[], period = 14): number[] => {
    if (data.length < period + 1) return [];

    const rsi: number[] = [];
    const gains: number[] = [];
    const losses: number[] = [];

    for (let i = 1; i < data.length; i++) {
      const change = data[i].close - data[i - 1].close;
      gains.push(change > 0 ? change : 0);
      losses.push(change < 0 ? Math.abs(change) : 0);
    }

    for (let i = period - 1; i < gains.length; i++) {
      const avgGain = gains.slice(i - period + 1, i + 1).reduce((a, b) => a + b) / period;
      const avgLoss = losses.slice(i - period + 1, i + 1).reduce((a, b) => a + b) / period;

      if (avgLoss === 0) {
        rsi.push(100);
      } else {
        const rs = avgGain / avgLoss;
        rsi.push(100 - (100 / (1 + rs)));
      }
    }

    return rsi;
  };

  const calculateSMA = (data: ChartDataPoint[], period: number): number[] => {
    const sma: number[] = [];
    for (let i = period - 1; i < data.length; i++) {
      const sum = data.slice(i - period + 1, i + 1).reduce((acc, candle) => acc + candle.close, 0);
      sma.push(sum / period);
    }
    return sma;
  };

  const calculateEMA = (data: ChartDataPoint[], period: number): number[] => {
    const ema: number[] = [];
    const multiplier = 2 / (period + 1);

    // Start with SMA for first value
    const firstSMA = data.slice(0, period).reduce((acc, candle) => acc + candle.close, 0) / period;
    ema.push(firstSMA);

    for (let i = period; i < data.length; i++) {
      const currentEMA: number = (data[i].close * multiplier) + (ema[ema.length - 1] * (1 - multiplier));
      ema.push(currentEMA);
    }

    return ema;
  };

  const calculateMACD = (data: ChartDataPoint[]): { macdLine: number[], signalLine: number[] } => {
    const ema12 = calculateEMA(data, 12);
    const ema26 = calculateEMA(data, 26);

    const macdLine: number[] = [];
    const startIndex = Math.max(0, ema26.length - ema12.length);

    for (let i = startIndex; i < ema12.length; i++) {
      macdLine.push(ema12[i] - ema26[i - startIndex]);
    }

    // Signal line (9-period EMA of MACD)
    const signalLine = calculateEMA(macdLine.map((value, index) => ({ close: value })) as ChartDataPoint[], 9);

    return { macdLine, signalLine };
  };

  const calculateBollingerBands = (data: ChartDataPoint[], period = 20, stdDev = 2): Array<{ upper: number, middle: number, lower: number }> => {
    const sma = calculateSMA(data, period);
    const bands: Array<{ upper: number, middle: number, lower: number }> = [];

    for (let i = period - 1; i < data.length; i++) {
      const slice = data.slice(i - period + 1, i + 1);
      const mean = sma[i - period + 1];
      const variance = slice.reduce((acc, candle) => acc + Math.pow(candle.close - mean, 2), 0) / period;
      const standardDeviation = Math.sqrt(variance);

      bands.push({
        upper: mean + (standardDeviation * stdDev),
        middle: mean,
        lower: mean - (standardDeviation * stdDev)
      });
    }

    return bands;
  };

  const drawSMA = (
    ctx: CanvasRenderingContext2D,
    visibleData: ChartDataPoint[],
    chartWidth: number,
    chartHeight: number,
    minPrice: number,
    maxPrice: number,
    candleSpacing: number,
    period: number,
    color: string
  ) => {
    console.log(`?? Drawing SMA${period} with ${visibleData.length} data points, color: ${color}`);
    const sma = calculateSMA(visibleData, period);
    console.log(`?? Calculated SMA${period}: ${sma.length} values, first few:`, sma.slice(0, 3));

    if (sma.length < 2) {
      console.log(`? Not enough SMA data: ${sma.length} values`);
      return;
    }

    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();

    const startOffset = period - 1;
    sma.forEach((value, index) => {
      const x = 40 + ((index + startOffset) * candleSpacing) + candleSpacing / 2;
      const y = chartHeight - ((value - minPrice) / (maxPrice - minPrice)) * chartHeight;

      if (index === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });

    ctx.stroke();
    console.log(`? SMA${period} drawn successfully`);
  };

  const drawEMA = (
    ctx: CanvasRenderingContext2D,
    visibleData: ChartDataPoint[],
    chartWidth: number,
    chartHeight: number,
    minPrice: number,
    maxPrice: number,
    candleSpacing: number,
    period: number,
    color: string
  ) => {
    const ema = calculateEMA(visibleData, period);
    if (ema.length < 2) return;

    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();

    const startOffset = period - 1;
    ema.forEach((value, index) => {
      const x = 40 + ((index + startOffset) * candleSpacing) + candleSpacing / 2;
      const y = chartHeight - ((value - minPrice) / (maxPrice - minPrice)) * chartHeight;

      if (index === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });

    ctx.stroke();
  };

  const drawBollingerBands = (
    ctx: CanvasRenderingContext2D,
    visibleData: ChartDataPoint[],
    chartWidth: number,
    chartHeight: number,
    minPrice: number,
    maxPrice: number,
    candleSpacing: number
  ) => {
    const bands = calculateBollingerBands(visibleData);
    if (bands.length < 2) return;

    const bandColors = ['#e91e63', '#4caf50', '#e91e63']; // Upper, Middle, Lower
    const lines = ['upper', 'middle', 'lower'];

    lines.forEach((line, lineIndex) => {
      ctx.strokeStyle = bandColors[lineIndex];
      ctx.lineWidth = 1.5;
      ctx.setLineDash(line === 'middle' ? [] : [5, 5]);
      ctx.beginPath();

      bands.forEach((band, index) => {
        const value = band[line as keyof typeof band];
        const x = 40 + ((index + 19) * candleSpacing) + candleSpacing / 2;
        const y = chartHeight - ((value - minPrice) / (maxPrice - minPrice)) * chartHeight;

        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });

      ctx.stroke();
      ctx.setLineDash([]);
    });
  };

  const drawRSI = (
    ctx: CanvasRenderingContext2D,
    visibleData: ChartDataPoint[],
    chartWidth: number,
    candleSpacing: number,
    panelStartY: number,
    panelEndY: number
  ) => {
    const rsi = calculateRSI(visibleData);
    if (rsi.length < 2) return;

    // Calculate RSI panel dimensions with proper margins
    const margin = 5;
    const rsiStartY = panelStartY + margin;
    const rsiHeight = panelEndY - panelStartY - (margin * 2);

    // Draw RSI panel background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.fillRect(40, rsiStartY, chartWidth - 80, rsiHeight);

    // Draw RSI panel border
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
    ctx.lineWidth = 1;
    ctx.strokeRect(40, rsiStartY, chartWidth - 80, rsiHeight);

    // RSI reference lines (30, 50, 70) with proper scaling
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 1;
    ctx.font = '10px monospace';
    ctx.textAlign = 'right';

    [30, 50, 70].forEach(level => {
      const y = rsiStartY + rsiHeight - (level / 100) * rsiHeight;
      ctx.beginPath();
      ctx.moveTo(40, y);
      ctx.lineTo(chartWidth - 40, y);
      ctx.stroke();

      // Draw level labels
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.fillText(level.toString(), chartWidth - 45, y + 3);
    });

    // Calculate visible data range
    const dataStartIndex = 14; // RSI needs 14 periods to calculate

    if (rsi.length === 0) return;

    // RSI line - start from the beginning of visible area
    ctx.strokeStyle = '#ff9800';
    ctx.lineWidth = 2;
    ctx.beginPath();

    // Map RSI values to the visible chart area
    rsi.forEach((value, index) => {
      // Calculate x position to align with the candlestick data
      // RSI index 0 corresponds to candlestick at dataStartIndex (14th candle)
      const candlestickIndex = index + dataStartIndex;
      const x = 40 + (candlestickIndex * candleSpacing) + candleSpacing / 2;
      const y = rsiStartY + rsiHeight - (value / 100) * rsiHeight;

      // Only draw if within chart bounds and we have valid data
      if (x >= 40 && x <= chartWidth - 40 && candlestickIndex < visibleData.length) {
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
    });

    ctx.stroke();

    // Draw RSI label and current value
    ctx.fillStyle = '#ff9800';
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('RSI', 45, rsiStartY + 18);

    // Show current RSI value
    if (rsi.length > 0) {
      const currentRSI = rsi[rsi.length - 1];
      ctx.fillStyle = currentRSI > 70 ? '#f44336' : currentRSI < 30 ? '#4caf50' : '#ff9800';
      ctx.fillText(currentRSI.toFixed(1), 80, rsiStartY + 18);
    }
  };

  const drawMACD = (
    ctx: CanvasRenderingContext2D,
    visibleData: ChartDataPoint[],
    chartWidth: number,
    candleSpacing: number,
    panelStartY: number,
    panelEndY: number
  ) => {
    const { macdLine, signalLine } = calculateMACD(visibleData);
    if (macdLine.length < 2) return;

    // Calculate MACD panel dimensions with proper margins
    const margin = 5;
    const macdStartY = panelStartY + margin;
    const macdHeight = panelEndY - panelStartY - (margin * 2);

    // Draw MACD panel background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.fillRect(40, macdStartY, chartWidth - 80, macdHeight);

    // Draw MACD panel border
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
    ctx.lineWidth = 1;
    ctx.strokeRect(40, macdStartY, chartWidth - 80, macdHeight);

    // Find MACD range for scaling
    const allValues = [...macdLine, ...signalLine];
    const macdMin = Math.min(...allValues);
    const macdMax = Math.max(...allValues);
    const macdRange = macdMax - macdMin || 1; // Prevent division by zero

    // Draw zero line
    const zeroY = macdStartY + macdHeight - ((0 - macdMin) / macdRange) * macdHeight;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.setLineDash([2, 2]);
    ctx.beginPath();
    ctx.moveTo(40, zeroY);
    ctx.lineTo(chartWidth - 40, zeroY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw MACD histogram (bars)
    ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
    macdLine.forEach((macdValue, index) => {
      if (index < signalLine.length) {
        const histogram = macdValue - signalLine[index];
        const dataIndex = index + 26; // MACD calculation offset
        const x = 40 + (dataIndex * candleSpacing) + candleSpacing / 2;

        // Only draw if within chart bounds and we have valid data
        if (x >= 40 && x <= chartWidth - 40 && dataIndex < visibleData.length) {
          const barHeight = Math.abs((histogram / macdRange) * macdHeight);
          const barY = histogram >= 0
            ? zeroY - barHeight
            : zeroY;

          ctx.fillStyle = histogram >= 0 ? 'rgba(76, 175, 80, 0.3)' : 'rgba(244, 67, 54, 0.3)';
          ctx.fillRect(x - candleSpacing / 4, barY, candleSpacing / 2, barHeight);
        }
      }
    });

    // MACD line (blue)
    ctx.strokeStyle = '#2196f3';
    ctx.lineWidth = 2;
    ctx.beginPath();

    macdLine.forEach((value, index) => {
      const dataIndex = index + 26; // MACD calculation offset
      const x = 40 + (dataIndex * candleSpacing) + candleSpacing / 2;
      const y = macdStartY + macdHeight - ((value - macdMin) / macdRange) * macdHeight;

      // Only draw if within chart bounds and we have valid data
      if (x >= 40 && x <= chartWidth - 40 && dataIndex < visibleData.length) {
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
    });

    ctx.stroke();

    // Signal line (red)
    ctx.strokeStyle = '#f44336';
    ctx.lineWidth = 2;
    ctx.beginPath();

    signalLine.forEach((value, index) => {
      const dataIndex = index + 35; // Signal line calculation offset (26 + 9)
      const x = 40 + (dataIndex * candleSpacing) + candleSpacing / 2;
      const y = macdStartY + macdHeight - ((value - macdMin) / macdRange) * macdHeight;

      // Only draw if within chart bounds and we have valid data
      if (x >= 40 && x <= chartWidth - 40 && dataIndex < visibleData.length) {
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
    });

    ctx.stroke();

    // Draw MACD labels and current values
    ctx.font = 'bold 12px monospace';
    ctx.textAlign = 'left';

    ctx.fillStyle = '#2196f3';
    ctx.fillText('MACD', 45, macdStartY + 18);

    ctx.fillStyle = '#f44336';
    ctx.fillText('Signal', 90, macdStartY + 18);

    // Show current values
    if (macdLine.length > 0 && signalLine.length > 0) {
      const currentMACD = macdLine[macdLine.length - 1];
      const currentSignal = signalLine[signalLine.length - 1];
      const currentHistogram = currentMACD - currentSignal;

      ctx.fillStyle = '#2196f3';
      ctx.fillText(currentMACD.toFixed(3), 140, macdStartY + 18);

      ctx.fillStyle = '#f44336';
      ctx.fillText(currentSignal.toFixed(3), 200, macdStartY + 18);

      ctx.fillStyle = currentHistogram >= 0 ? '#4caf50' : '#f44336';
      ctx.fillText(currentHistogram.toFixed(3), 260, macdStartY + 18);
    }
  };

  // Draw individual candle
  const drawCandle = (
    ctx: CanvasRenderingContext2D,
    candle: ChartDataPoint,
    x: number,
    width: number,
    height: number,
    minPrice: number,
    maxPrice: number
  ) => {
    const { open, high, low, close } = candle;
    const isGreen = close > open;

    // Check if RRG Candle is active and get custom color
    let candleColor: string | null = null;
    if (isRRGCandleActive && rrgCandleColors.size > 0) {
      const timestamp = candle.timestamp;
      candleColor = rrgCandleColors.get(timestamp) || null;
    }

    // Get custom colors - use RRG color if available, otherwise use default
    const candleColors = candleColor
      ? { body: candleColor, wick: candleColor, border: candleColor }
      : (isGreen ? config.colors.bullish : config.colors.bearish);

    // Convert prices to canvas coordinates
    const priceToY = (price: number) => {
      const ratio = (price - minPrice) / (maxPrice - minPrice);
      const chartArea = height - 25; // Reserve 25px at bottom for time labels
      return Math.round(chartArea - (ratio * (chartArea - 20)) - 10); // Round to crisp pixels
    };

    const openY = priceToY(open);
    const closeY = priceToY(close);
    const highY = priceToY(high);
    const lowY = priceToY(low);

    // Round x position for crisp rendering
    const crispX = Math.round(x);
    const crispWidth = Math.max(1, Math.round(width));

    // Draw wick (high-low line) - ensure all coordinates are pixel-aligned
    ctx.strokeStyle = candleColors.wick;
    ctx.lineWidth = Math.max(1, Math.round(width * 0.05)); // Reduced from 0.1 to 0.05 for thinner wicks
    ctx.beginPath();
    const wickCenterX = Math.round(crispX + crispWidth / 2) + 0.5; // Add 0.5 for crisp 1px lines
    ctx.moveTo(wickCenterX, Math.round(highY));
    ctx.lineTo(wickCenterX, Math.round(lowY));
    ctx.stroke();

    // Draw body (open-close rectangle)
    if (config.chartType === 'candlestick') {
      const bodyHeight = Math.max(1, Math.abs(closeY - openY));
      const bodyY = Math.min(openY, closeY);
      const bodyWidth = Math.max(2, crispWidth - 2);

      // Round all coordinates to pixel boundaries for crispy rendering
      const crispBodyX = Math.round(crispX + 1);
      const crispBodyY = Math.round(bodyY);
      const crispBodyWidth = Math.round(bodyWidth);
      const crispBodyHeight = Math.round(bodyHeight);

      // Fill the body
      ctx.fillStyle = candleColors.body;
      ctx.fillRect(crispBodyX, crispBodyY, crispBodyWidth, crispBodyHeight);

      // Draw body border
      ctx.strokeStyle = candleColors.border;
      ctx.lineWidth = 1;
      ctx.strokeRect(crispBodyX, crispBodyY, crispBodyWidth, crispBodyHeight);
    }
  };

  // Draw price scale on the right
  const drawPriceScale = (
    ctx: CanvasRenderingContext2D,
    width: number,
    height: number,
    minPrice: number,
    maxPrice: number
  ) => {
    ctx.fillStyle = config.axisStyle.yAxis.textColor;
    ctx.font = `bold ${config.axisStyle.yAxis.textSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
    ctx.textAlign = 'left';

    const chartArea = height - 25; // Reserve 25px at bottom for time labels
    const steps = 10;

    for (let i = 0; i <= steps; i++) {
      const ratio = i / steps;
      const price = minPrice + (maxPrice - minPrice) * (1 - ratio);
      const y = 20 + ((chartArea - 40) / steps) * i;

      // Draw price label with more left margin
      ctx.fillText(`$${price.toFixed(2)}`, width - 85, y + 4);

      // Draw tick mark
      ctx.strokeStyle = colors.grid;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(width - 90, y);
      ctx.lineTo(width - 85, y);
      ctx.stroke();
    }

    // Reset styles after drawing Y-axis
    ctx.fillStyle = config.axisStyle.yAxis.textColor;
    ctx.font = `bold ${config.axisStyle.yAxis.textSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
    ctx.textAlign = 'left';
  };

  // Draw time axis at the bottom
  const drawTimeAxis = (
    ctx: CanvasRenderingContext2D,
    width: number,
    height: number,
    visibleData: ChartDataPoint[],
    chartWidth: number,
    visibleCandleCount: number,
    scrollOffset: number,
    allData: ChartDataPoint[]
  ) => {
    // Allow drawing axis even in future space (when visibleData is empty)
    if (visibleData.length === 0 && allData.length === 0) return;

    ctx.fillStyle = config.axisStyle.xAxis.textColor;
    ctx.font = `bold ${config.axisStyle.xAxis.textSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
    ctx.textAlign = 'center';

    // TradingView-style adaptive labeling based on zoom level
    const getOptimalLabelFormat = (timeframe: string, visibleCandleCount: number, timeSpan: number) => {
      const isIntraday = timeframe.includes('m') || timeframe.includes('h');
      const hoursSpan = timeSpan / (1000 * 60 * 60);
      const daysSpan = timeSpan / (1000 * 60 * 60 * 24);
      const monthsSpan = daysSpan / 30;
      const yearsSpan = daysSpan / 365;

      // Very zoomed in (intraday with small time span) - DOUBLED DENSITY
      if (isIntraday && hoursSpan <= 24) {
        return {
          format: 'time',
          spacing: Math.max(1, Math.floor(visibleCandleCount / 12))
        };
      }
      // Intraday but longer span - DOUBLED DENSITY
      else if (isIntraday && hoursSpan <= 168) { // 1 week
        return {
          format: 'datetime',
          spacing: Math.max(1, Math.floor(visibleCandleCount / 16))
        };
      }
      // Daily view, short term - DOUBLED DENSITY
      else if (daysSpan <= 30) {
        return {
          format: 'date',
          spacing: Math.max(1, Math.floor(visibleCandleCount / 12))
        };
      }
      // Medium term (months) - DOUBLED DENSITY
      else if (monthsSpan <= 12) {
        return {
          format: 'monthday',
          spacing: Math.max(1, Math.floor(visibleCandleCount / 16))
        };
      }
      // Long term (years) - DOUBLED DENSITY
      else if (yearsSpan <= 5) {
        return {
          format: 'monthyear',
          spacing: Math.max(1, Math.floor(visibleCandleCount / 20))
        };
      }
      // Very long term - DOUBLED DENSITY
      else {
        return {
          format: 'year',
          spacing: Math.max(1, Math.floor(visibleCandleCount / 24))
        };
      }
    };

    // Calculate time span of visible data
    const timeSpan = visibleData.length > 1 ?
      visibleData[visibleData.length - 1].timestamp - visibleData[0].timestamp :
      visibleData.length === 1 ? 24 * 60 * 60 * 1000 : // 1 day fallback for single candle
        allData.length > 0 ? 24 * 60 * 60 * 1000 : // 1 day fallback when in future space
          24 * 60 * 60 * 1000; // Default 1 day fallback

    const labelConfig = getOptimalLabelFormat(config.timeframe, visibleCandleCount, timeSpan);

    // Format date based on adaptive format
    const formatDateLabel = (timestamp: number, format: string): string => {
      const date = new Date(timestamp);

      switch (format) {
        case 'time':
          return date.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true,
            timeZone: 'America/New_York'
          });
        case 'datetime':
          return date.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            timeZone: 'America/New_York'
          }) + ' ' + date.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true,
            timeZone: 'America/New_York'
          });
        case 'date':
          return date.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            timeZone: 'America/New_York'
          });
        case 'monthday':
          return date.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            timeZone: 'America/New_York'
          });
        case 'monthyear':
          return date.toLocaleDateString('en-US', {
            month: 'short',
            year: 'numeric',
            timeZone: 'America/New_York'
          });
        case 'year':
          return date.toLocaleDateString('en-US', {
            year: 'numeric',
            timeZone: 'America/New_York'
          }).split(',')[0];
        default:
          return date.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            timeZone: 'America/New_York'
          });
      }
    };

    // Calculate how many labels we can fit - enhanced with overlap prevention

    // Track label positions to prevent overlap
    const labelPositions: { x: number; width: number; text: string }[] = [];

    const canPlaceLabel = (x: number, text: string): boolean => {
      const textWidth = ctx.measureText(text).width;
      const labelLeft = x - textWidth / 2;
      const labelRight = x + textWidth / 2;

      // Check if this label would overlap with any existing labels
      for (const existing of labelPositions) {
        const existingLeft = existing.x - existing.width / 2;
        const existingRight = existing.x + existing.width / 2;

        if (!(labelRight < existingLeft - 10 || labelLeft > existingRight + 10)) {
          return false; // Overlap detected
        }
      }

      // Check if label is too close to chart edges
      if (labelLeft < 45 || labelRight > width - 10) {
        return false;
      }

      return true;
    };

    const addLabel = (x: number, text: string, isFuture: boolean = false) => {
      if (canPlaceLabel(x, text)) {
        const textWidth = ctx.measureText(text).width;
        labelPositions.push({ x, width: textWidth, text });

        // Set appropriate color
        ctx.fillStyle = isFuture ? 'rgba(255, 255, 255, 0.6)' : config.axisStyle.xAxis.textColor;

        // Draw the label below volume bars
        ctx.fillText(text, x, height - 10);

        // Draw tick mark
        ctx.strokeStyle = isFuture ? 'rgba(255, 255, 255, 0.3)' : colors.grid;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, height - 27);
        ctx.lineTo(x, height - 22);
        ctx.stroke();
      }
    };

    // Calculate how many labels we can fit (old method as fallback)
    const maxLabels = Math.floor(chartWidth / 80); // One label every 80px
    const labelStep = labelConfig.spacing;

    const candleSpacing = chartWidth / visibleCandleCount;

    // Calculate if we're showing future area
    const startIndex = Math.max(0, Math.floor(scrollOffset));
    const actualDataEnd = Math.min(allData.length, startIndex + visibleCandleCount);
    const showingFutureArea = (startIndex + visibleCandleCount) > allData.length;
    const futurePeriodsShown = showingFutureArea ? (startIndex + visibleCandleCount) - allData.length : 0;

    // Helper function to calculate future timestamp
    const getFutureTimestamp = (baseTimestamp: number, periodsAhead: number): number => {
      const timeframe = config.timeframe;
      let milliseconds = 0;

      switch (timeframe) {
        case '1m': milliseconds = 60 * 1000; break;
        case '5m': milliseconds = 5 * 60 * 1000; break;
        case '15m': milliseconds = 15 * 60 * 1000; break;
        case '30m': milliseconds = 30 * 60 * 1000; break;
        case '1h': milliseconds = 60 * 60 * 1000; break;
        case '4h': milliseconds = 4 * 60 * 60 * 1000; break;
        case '1d': milliseconds = 24 * 60 * 60 * 1000; break;
        case '1w': milliseconds = 7 * 24 * 60 * 60 * 1000; break;
        case '1mo': milliseconds = 30 * 24 * 60 * 60 * 1000; break;
        case '1y': milliseconds = 365 * 24 * 60 * 60 * 1000; break;
        default: milliseconds = 24 * 60 * 60 * 1000; break;
      }

      // Simple linear calculation - just add the time intervals
      return baseTimestamp + (periodsAhead * milliseconds);
    };

    // Draw labels for actual data with overlap prevention
    visibleData.forEach((candle, index) => {
      if (index % labelStep === 0) {
        const x = 40 + (index * candleSpacing) + candleSpacing / 2;
        const timeLabel = formatDateLabel(candle.timestamp, labelConfig.format);
        addLabel(x, timeLabel, false);
      }
    });

    // Always try to add the last visible data point if not already added
    if (visibleData.length > 0) {
      const lastIndex = visibleData.length - 1;
      const x = 40 + (lastIndex * candleSpacing) + candleSpacing / 2;
      const timeLabel = formatDateLabel(visibleData[lastIndex].timestamp, labelConfig.format);
      addLabel(x, timeLabel, false);
    }

    // Draw future labels if we're showing future area - MUCH DENSER SPACING FOR FUTURE
    if (showingFutureArea && futurePeriodsShown > 0 && allData.length > 0) {
      const lastDataTimestamp = allData[allData.length - 1].timestamp;

      // Use much smaller spacing for future area - show way more labels
      const futureSpacing = Math.max(1, Math.floor(labelStep / 3)); // 3x denser than historical

      // Calculate starting index for future labels
      const futureStartOffset = visibleData.length > 0 ? 1 : (startIndex - allData.length + 1);

      for (let i = futureStartOffset; i <= futurePeriodsShown; i++) {
        if (i % futureSpacing === 0 || visibleData.length === 0) {
          const futureIndexOnScreen = visibleData.length > 0 ? (visibleData.length + i - 1) : (i - futureStartOffset);
          const x = 40 + (futureIndexOnScreen * candleSpacing) + candleSpacing / 2;
          const futureTimestamp = getFutureTimestamp(lastDataTimestamp, startIndex - allData.length + i);
          const timeLabel = formatDateLabel(futureTimestamp, labelConfig.format);
          addLabel(x, timeLabel, true);
        }
      }
    }

    // Draw price alerts on the chart
    if (alerts.length > 0) {
      alerts.filter(a => !a.triggered).forEach(alert => {
        const y = priceToScreenForDrawings(alert.price);

        if (y >= 0 && y <= dimensions.height) {
          // Determine alert color based on condition and type
          let alertColor = '#FFD700'; // Default gold
          if (alert.type === 'options') alertColor = '#00BFFF'; // Blue for options
          if (alert.type === 'technical') alertColor = '#32CD32'; // Green for technical

          // Draw dashed horizontal line
          ctx.strokeStyle = alertColor;
          ctx.lineWidth = 2;
          ctx.setLineDash([8, 4]);
          ctx.globalAlpha = 0.8;

          ctx.beginPath();
          ctx.moveTo(40, y);
          ctx.lineTo(dimensions.width - 80, y);
          ctx.stroke();

          ctx.globalAlpha = 1.0;
          ctx.setLineDash([]);

          // Draw bell icon
          ctx.font = '16px Arial';
          ctx.fillStyle = alertColor;
          ctx.fillText('\uD83D\uDD14', 45, y - 5);

          // Draw price label on Y-axis
          const priceText = alert.price.toFixed(2);
          ctx.font = '12px Arial';
          const textWidth = ctx.measureText(priceText).width;
          const textHeight = 16;

          // Background box
          ctx.fillStyle = alertColor;
          ctx.fillRect(dimensions.width - 80, y - textHeight / 2, textWidth + 8, textHeight);

          // Price text
          ctx.fillStyle = '#000000';
          ctx.textAlign = 'left';
          ctx.fillText(priceText, dimensions.width - 76, y + 4);
        }
      });
    }
  };

  // Re-render when data or settings change
  // Call renderChart only when critical dependencies change
  useEffect(() => {
    if (dimensions.width > 0 && dimensions.height > 0 && data.length > 0 && chartLayout === '1x1') {
      renderChart();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dimensions.width, dimensions.height, data.length, scrollOffset, visibleCandleCount, isFlowChartActive, flowChartData.length, flowChartViewMode, flowChartHeight, showIVPanel, showCallIVLine, showPutIVLine, showNetIVLine, showIVRankIndicator, showIVPercentileIndicator, showHVIndicator, ivData.length, hvWindow, chartLayout, manualPriceRange]);

  // TradingView-style interaction handlers

  // Stable helper function to get EXACT same priceChartHeight as renderChart function
  const actualPriceChartHeight = useMemo((): number => {
    const timeAxisHeight = 25;
    const volumeAreaHeight = 80;
    const totalBottomSpace = volumeAreaHeight + timeAxisHeight;
    return dimensions.height - totalBottomSpace;
  }, [dimensions.height]);

  // Coordinate conversion functions (optimized to avoid recreating helper functions)
  const screenToPrice = useCallback((y: number): number => {
    const priceChartHeight = actualPriceChartHeight;

    // Use the ACTUAL rendered price range (same as Expected Range uses)
    const adjustedMin = lastRenderedPriceRangeRef.current.min;
    const adjustedMax = lastRenderedPriceRangeRef.current.max;

    if (adjustedMax === adjustedMin) return 0;

    // Use EXACT same formula as Expected Range and chart rendering
    return adjustedMax - ((y / priceChartHeight) * (adjustedMax - adjustedMin));
  }, [actualPriceChartHeight]);

  // Helper function to get STABLE chart price range (for drawings - doesn't change with scrolling)
  const getStablePriceRange = (): { min: number; max: number } => {
    if (!data || data.length === 0) return { min: 0, max: 100 };

    const allPrices = data.flatMap(d => [d.high, d.low]);
    const minPrice = Math.min(...allPrices);
    const maxPrice = Math.max(...allPrices);
    const padding = (maxPrice - minPrice) * 0.1;
    return {
      min: minPrice - padding,
      max: maxPrice + padding
    };
  };

  const priceToScreen = useCallback((price: number): number => {
    const priceChartHeight = actualPriceChartHeight;

    // Use the ACTUAL rendered price range (same as Expected Range uses)
    const adjustedMin = lastRenderedPriceRangeRef.current.min;
    const adjustedMax = lastRenderedPriceRangeRef.current.max;

    if (adjustedMax === adjustedMin) return priceChartHeight / 2;

    // Use EXACT same formula as Expected Range: chartHeight - ((price - minPrice) / priceRange) * chartHeight
    // This is mathematically equivalent to: ((adjustedMax - price) / (adjustedMax - adjustedMin)) * priceChartHeight
    return ((adjustedMax - price) / (adjustedMax - adjustedMin)) * priceChartHeight;
  }, [actualPriceChartHeight]);

  const timeToScreen = useCallback((timestamp: number): number => {
    const candleWidth = (dimensions.width - 100) / visibleCandleCount;
    const startIndex = Math.max(0, Math.floor(scrollOffset));
    const visibleData = data.slice(startIndex, startIndex + visibleCandleCount);

    // Find the index of the timestamp in visible data
    const dataIndex = visibleData.findIndex(d => d.timestamp >= timestamp);
    const relativeIndex = dataIndex >= 0 ? dataIndex : visibleData.length - 1;

    return 40 + (relativeIndex * candleWidth);
  }, [dimensions.width, visibleCandleCount, scrollOffset, data]);

  // Specialized coordinate functions for drawings that use STABLE price range (not viewport dependent)
  const priceToScreenForDrawings = useCallback((price: number): number => {
    const priceChartHeight = actualPriceChartHeight;

    // Get visible data for current price range calculation
    const startIndex = Math.max(0, scrollOffset);
    const endIndex = Math.min(data.length, scrollOffset + visibleCandleCount);
    const visibleData = data.slice(startIndex, endIndex);

    if (visibleData.length === 0) {
      return priceChartHeight / 2;
    }

    // Use the EXACT same price range calculation that the chart rendering uses
    const currentRange = getCurrentPriceRange(visibleData);

    if (currentRange.min === currentRange.max) {
      // Fallback if range is invalid
      return priceChartHeight / 2;
    }

    const adjustedMin = currentRange.min;
    const adjustedMax = currentRange.max;

    // Convert price to Y coordinate using the current chart range
    return ((adjustedMax - price) / (adjustedMax - adjustedMin)) * priceChartHeight;
  }, [actualPriceChartHeight, scrollOffset, data.length, visibleCandleCount, data, getCurrentPriceRange]);

  // Memoized coordinate conversion with performance optimization
  const screenToTimePriceCoordinates = useCallback((screenX: number, screenY: number): { timestamp: number; price: number } => {
    const canvas = overlayCanvasRef.current;
    if (!canvas || !data.length) return { timestamp: Date.now(), price: 0 };

    // Use EXACT same coordinate system as crosshair calculation for perfect alignment
    const priceChartHeight = actualPriceChartHeight;

    // Convert screen X to actual timestamp - using same logic as crosshair
    const chartWidth = dimensions.width - 100; // Match crosshair calculation
    const candleWidth = chartWidth / visibleCandleCount;
    const relativeX = Math.max(0, screenX - 40); // Account for left margin (match crosshair)
    const visibleCandleIndex = Math.floor(relativeX / candleWidth);

    // Get visible data slice to work with actual visible candles
    const startIndex = Math.max(0, Math.floor(scrollOffset));
    const endIndex = Math.min(data.length, startIndex + visibleCandleCount);
    const visibleData = data.slice(startIndex, endIndex);

    // Handle future dates beyond visible data (for seasonal projection)
    let timestamp: number;
    if (visibleCandleIndex >= visibleData.length) {
      // We're beyond the visible data - calculate future date using proper timeframe
      const lastCandle = data[data.length - 1];
      const periodsIntoFuture = visibleCandleIndex - visibleData.length + 1;

      // Calculate milliseconds per period based on timeframe
      const timeframe = config.timeframe;
      let millisecondsPerPeriod = 0;

      switch (timeframe) {
        case '1m': millisecondsPerPeriod = 60 * 1000; break;
        case '5m': millisecondsPerPeriod = 5 * 60 * 1000; break;
        case '15m': millisecondsPerPeriod = 15 * 60 * 1000; break;
        case '30m': millisecondsPerPeriod = 30 * 60 * 1000; break;
        case '1h': millisecondsPerPeriod = 60 * 60 * 1000; break;
        case '4h': millisecondsPerPeriod = 4 * 60 * 60 * 1000; break;
        case '1d': millisecondsPerPeriod = 24 * 60 * 60 * 1000; break;
        case '1w': millisecondsPerPeriod = 7 * 24 * 60 * 60 * 1000; break;
        case '1mo': millisecondsPerPeriod = 30 * 24 * 60 * 60 * 1000; break;
        case '1y': millisecondsPerPeriod = 365 * 24 * 60 * 60 * 1000; break;
        default: millisecondsPerPeriod = 24 * 60 * 60 * 1000; break;
      }

      // Simple linear calculation - add time intervals based on actual timeframe
      timestamp = lastCandle.timestamp + (periodsIntoFuture * millisecondsPerPeriod);
    } else {
      // Use the actual visible candle's timestamp directly
      const boundedIndex = Math.max(0, Math.min(visibleCandleIndex, visibleData.length - 1));
      timestamp = visibleData[boundedIndex]?.timestamp || Date.now();
    }

    // Convert screen Y to actual price using EXACT same logic as crosshair calculation
    // (visibleData already calculated above)

    if (visibleData.length === 0) return { timestamp, price: 0 };

    // Use current price range (manual or auto) - CRITICAL for correct Y-axis values
    const currentRange = manualPriceRange || getCurrentPriceRange(visibleData);
    const adjustedMin = currentRange.min;
    const adjustedMax = currentRange.max;

    // Use EXACT same formula as crosshair: adjustedMax - ((y / priceChartHeight) * (adjustedMax - adjustedMin))
    // Only consider mouse position within the price chart area (match crosshair behavior)
    const price = screenY <= priceChartHeight ?
      adjustedMax - ((screenY / priceChartHeight) * (adjustedMax - adjustedMin)) :
      adjustedMax - ((screenY / priceChartHeight) * (adjustedMax - adjustedMin));

    return { timestamp, price };
  }, [actualPriceChartHeight, dimensions.width, visibleCandleCount, scrollOffset, data, seasonalProjectionData, manualPriceRange, getCurrentPriceRange]);

  // Unified mouse handler that prioritizes drawing interaction over chart panning
  const handleUnifiedMouseDown = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    if (e.button !== 0) return; // Only left mouse button

    const canvas = e.currentTarget;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Check Y-axis drag to zoom FIRST (before everything else)
    const canvasWidth = canvas.width / window.devicePixelRatio;
    const isOverYAxis = isInYAxisArea(x, canvasWidth);

    if (isOverYAxis) {
      e.preventDefault();
      setIsDraggingYAxisZoom(true);

      // Get current price range
      const startIndex = Math.max(0, Math.floor(scrollOffset));
      const endIndex = Math.min(data.length, startIndex + visibleCandleCount);
      const visibleData = data.slice(startIndex, endIndex);

      if (visibleData.length > 0) {
        const currentRange = manualPriceRange || getCurrentPriceRange(visibleData);
        setYAxisZoomDragStart({ y, priceRange: currentRange });

        // Ensure we have manual range for resizing
        if (!manualPriceRange) {
          setManualPriceRangeAndDisableAuto(currentRange);
        }
      }
      return;
    }

    // Handle alert placement mode FIRST
    if (isAlertPlacementMode) {
      const startIndex = Math.max(0, Math.floor(scrollOffset));
      const endIndex = Math.min(data.length, startIndex + visibleCandleCount);
      const currentVisibleData = data.slice(startIndex, endIndex);

      if (currentVisibleData.length > 0) {
        const timeAxisHeight = 25;
        const volumeAreaHeight = 80;
        const chartHeight = dimensions.height - timeAxisHeight - volumeAreaHeight;
        const minPrice = Math.min(...currentVisibleData.map(d => d.low));
        const maxPrice = Math.max(...currentVisibleData.map(d => d.high));

        // Convert canvas Y to price
        const price = canvasToPrice(y, minPrice, maxPrice, chartHeight);

        // Show alert creation dialog
        setNewAlertPrice(price);
        setShowAlertDialog(true);
        setIsAlertPlacementMode(false);
      }

      return;
    }

    // Default chart panning behavior
    setIsDragging(true);
    setLastMouseX(x);
    setDragStartX(x);
    setDragStartOffset(scrollOffset);
  }, [
    scrollOffset,
    dimensions, data, visibleCandleCount,
    screenToTimePriceCoordinates, screenToPrice, priceToScreenForDrawings,
    isAlertPlacementMode, alerts, newAlertPrice, showAlertDialog,
    isInYAxisArea, getCurrentPriceRange, manualPriceRange, setManualPriceRangeAndDisableAuto
  ]);

  // ? NEW: Advanced Hit Detection System
  const getDrawingHandles = useCallback((drawing: Drawing): Array<{ x: number, y: number, type: string, cursor: string }> => {
    if (!drawing.startTimestamp || !drawing.startPrice) return [];

    const startCoords = timePriceToScreenCoordinates(drawing.startTimestamp, drawing.startPrice);
    const handles = [
      { x: startCoords.x, y: startCoords.y, type: 'start', cursor: 'grab' }
    ];

    if (drawing.endTimestamp && drawing.endPrice) {
      const endCoords = timePriceToScreenCoordinates(drawing.endTimestamp, drawing.endPrice);
      handles.push({ x: endCoords.x, y: endCoords.y, type: 'end', cursor: 'grab' });

      // Add corner handles for rectangles
      if (['rectangle', 'ellipse'].includes(drawing.type)) {
        handles.push(
          { x: startCoords.x, y: endCoords.y, type: 'corner1', cursor: 'nw-resize' },
          { x: endCoords.x, y: startCoords.y, type: 'corner2', cursor: 'ne-resize' }
        );
      }

      // Add midpoint handles for lines
      if (['trend_line', 'extended_line', 'arrow'].includes(drawing.type)) {
        const midX = (startCoords.x + endCoords.x) / 2;
        const midY = (startCoords.y + endCoords.y) / 2;
        handles.push({ x: midX, y: midY, type: 'midpoint', cursor: 'grab' });
      }
    }

    return handles;
  }, []);

  const detectDrawingHit = useCallback((x: number, y: number, drawing: Drawing): { hit: boolean, type: string, handle?: any } => {
    const HANDLE_SIZE = 8;
    const LINE_TOLERANCE = 10;

    // Check handles first
    if (showDrawingHandles && drawing.isSelected) {
      const handles = getDrawingHandles(drawing);
      for (const handle of handles) {
        const distance = Math.sqrt(Math.pow(x - handle.x, 2) + Math.pow(y - handle.y, 2));
        if (distance <= HANDLE_SIZE) {
          return { hit: true, type: 'handle', handle };
        }
      }
    }

    // Check drawing body
    if (!drawing.startTimestamp || !drawing.startPrice) return { hit: false, type: 'none' };

    const startCoords = timePriceToScreenCoordinates(drawing.startTimestamp, drawing.startPrice);

    switch (drawing.type) {
      case 'trend_line':
      case 'extended_line':
      case 'arrow':
        if (drawing.endTimestamp && drawing.endPrice) {
          const endCoords = timePriceToScreenCoordinates(drawing.endTimestamp, drawing.endPrice);
          const distance = distanceToLine(x, y, startCoords.x, startCoords.y, endCoords.x, endCoords.y);
          if (distance <= LINE_TOLERANCE) {
            return { hit: true, type: 'body' };
          }
        }
        break;

      case 'horizontal_line':
        if (Math.abs(y - startCoords.y) <= LINE_TOLERANCE) {
          return { hit: true, type: 'body' };
        }
        break;

      case 'vertical_line':
        if (Math.abs(x - startCoords.x) <= LINE_TOLERANCE) {
          return { hit: true, type: 'body' };
        }
        break;

      case 'rectangle':
      case 'ellipse':
        if (drawing.endTimestamp && drawing.endPrice) {
          const endCoords = timePriceToScreenCoordinates(drawing.endTimestamp, drawing.endPrice);
          const minX = Math.min(startCoords.x, endCoords.x);
          const maxX = Math.max(startCoords.x, endCoords.x);
          const minY = Math.min(startCoords.y, endCoords.y);
          const maxY = Math.max(startCoords.y, endCoords.y);

          if (drawing.type === 'rectangle') {
            // Rectangle border hit test
            const onBorder = (
              (x >= minX && x <= maxX && (Math.abs(y - minY) <= LINE_TOLERANCE || Math.abs(y - maxY) <= LINE_TOLERANCE)) ||
              (y >= minY && y <= maxY && (Math.abs(x - minX) <= LINE_TOLERANCE || Math.abs(x - maxX) <= LINE_TOLERANCE))
            );

            // Interior hit test (if filled)
            const interior = x >= minX && x <= maxX && y >= minY && y <= maxY;

            if (onBorder || (interior && drawing.style?.fillOpacity && drawing.style.fillOpacity > 0)) {
              return { hit: true, type: 'body' };
            }
          } else if (drawing.type === 'ellipse') {
            // Ellipse hit test
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const radiusX = (maxX - minX) / 2;
            const radiusY = (maxY - minY) / 2;

            const normalizedX = (x - centerX) / radiusX;
            const normalizedY = (y - centerY) / radiusY;
            const distance = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);

            if (distance <= 1.1 && distance >= 0.9) { // Border tolerance
              return { hit: true, type: 'body' };
            }
          }
        }
        break;

      case 'text':
      case 'note':
        // Text hit test (approximate)
        const textWidth = (drawing.text?.length || 0) * 8;
        const textHeight = drawing.style?.fontSize || 12;
        if (x >= startCoords.x && x <= startCoords.x + textWidth &&
          y >= startCoords.y - textHeight && y <= startCoords.y) {
          return { hit: true, type: 'body' };
        }
        break;
    }

    return { hit: false, type: 'none' };
  }, [showDrawingHandles, getDrawingHandles]);

  // Helper function for line distance calculation
  const distanceToLine = (px: number, py: number, x1: number, y1: number, x2: number, y2: number): number => {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;

    if (lenSq === 0) return Math.sqrt(A * A + B * B);

    let param = dot / lenSq;
    param = Math.max(0, Math.min(1, param));

    const xx = x1 + param * C;
    const yy = y1 + param * D;

    const dx = px - xx;
    const dy = py - yy;

    return Math.sqrt(dx * dx + dy * dy);
  };

  // ? NEW: Magnet Mode for OHLC Snapping
  const snapToOHLC = useCallback((timestamp: number, price: number): { timestamp: number, price: number } => {
    if (!magnetMode || !data.length) return { timestamp, price };

    // Find nearest candle
    const candleIndex = data.findIndex(candle => candle.timestamp >= timestamp);
    if (candleIndex === -1) return { timestamp, price };

    const candle = data[candleIndex];
    const ohlcValues = [candle.open, candle.high, candle.low, candle.close];

    // Find closest OHLC value
    let closestPrice = price;
    let minDistance = Infinity;

    ohlcValues.forEach(ohlcPrice => {
      const distance = Math.abs(price - ohlcPrice);
      if (distance < minDistance) {
        minDistance = distance;
        closestPrice = ohlcPrice;
      }
    });

    // Only snap if within reasonable distance
    const priceRange = Math.abs(candle.high - candle.low);
    if (minDistance < priceRange * 0.1) { // Within 10% of candle range
      return { timestamp: candle.timestamp, price: closestPrice };
    }

    return { timestamp, price };
  }, [magnetMode, data]);

  // ? NEW: Enhanced Drawing Handle Rendering
  const renderDrawingHandles = useCallback((ctx: CanvasRenderingContext2D, drawing: Drawing) => {
    if (!drawing.isSelected || !showDrawingHandles) return;

    const handles = getDrawingHandles(drawing);

    handles.forEach(handle => {
      // Handle appearance
      ctx.fillStyle = '#2962ff';
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;

      // Draw handle based on type
      if (handle.type === 'start' || handle.type === 'end') {
        // Circle handles for start/end points
        ctx.beginPath();
        ctx.arc(handle.x, handle.y, 6, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
      } else if (handle.type.startsWith('corner')) {
        // Square handles for corners
        ctx.fillRect(handle.x - 4, handle.y - 4, 8, 8);
        ctx.strokeRect(handle.x - 4, handle.y - 4, 8, 8);
      } else if (handle.type === 'midpoint') {
        // Diamond handle for midpoint
        ctx.save();
        ctx.translate(handle.x, handle.y);
        ctx.rotate(Math.PI / 4);
        ctx.fillRect(-4, -4, 8, 8);
        ctx.strokeRect(-4, -4, 8, 8);
        ctx.restore();
      }
    });
  }, [showDrawingHandles, getDrawingHandles]);

  // ? ENHANCED: Mouse handlers with advanced hit detection
  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (e.button === 2) { // Right click
      e.preventDefault();
      const rect = e.currentTarget.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Check if right-clicking on a drawing
      const hitDrawing = drawings.find(drawing => {
        const hitResult = detectDrawingHit(x, y, drawing);
        return hitResult.hit;
      });

      if (hitDrawing) {
        setContextMenuDrawing(hitDrawing);
        setSelectedDrawing(hitDrawing);
        setContextMenuPosition({ x: e.clientX, y: e.clientY });
        setShowContextMenu(true);
      } else {
        setShowContextMenu(false);
      }
      return;
    }

    if (e.button !== 0) return; // Only left mouse button for other actions

    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Close any open menus
    setShowContextMenu(false);
    setShowPropertiesPanel(false);

    // Check Y-axis drag to zoom FIRST (before drawing checks)
    const canvas = e.currentTarget as HTMLCanvasElement;
    const canvasWidth = canvas.width / window.devicePixelRatio;
    const isOverYAxis = isInYAxisArea(x, canvasWidth);

    if (isOverYAxis) {
      console.log('âœ… STARTING Y-AXIS ZOOM DRAG');
      e.preventDefault();
      setIsDraggingYAxisZoom(true);

      // Get current price range
      const startIndex = Math.max(0, Math.floor(scrollOffset));
      const endIndex = Math.min(data.length, startIndex + visibleCandleCount);
      const visibleData = data.slice(startIndex, endIndex);

      if (visibleData.length > 0) {
        const currentRange = manualPriceRange || getCurrentPriceRange(visibleData);
        console.log('ðŸ“ SET DRAG START:', { y, currentRange });
        setYAxisZoomDragStart({ y, priceRange: currentRange });

        // Ensure we have manual range for resizing
        if (!manualPriceRange) {
          setManualPriceRangeAndDisableAuto(currentRange);
        }
      }
      return;
    }

    // Check for box zoom mode (Shift key held)
    if (e.shiftKey && !activeTool) {
      setIsBoxZooming(true);
      setBoxZoomStart({ x, y });
      setBoxZoomEnd({ x, y });
      return;
    }

    // Check for drawing interaction first
    let hitDrawing: Drawing | null = null;
    let hitResult: { hit: boolean, type: string, handle?: any } = { hit: false, type: 'none' };

    // Check drawings in reverse order (front to back)
    for (let i = drawings.length - 1; i >= 0; i--) {
      const drawing = drawings[i];
      if (drawing.isLocked) continue; // Skip locked drawings

      const result = detectDrawingHit(x, y, drawing);
      if (result.hit) {
        hitDrawing = drawing;
        hitResult = result;
        break;
      }
    }

    if (hitDrawing) {
      // Multi-select with Ctrl/Cmd
      const isMultiSelect = e.ctrlKey || e.metaKey;
      handleDrawingSelection(hitDrawing, isMultiSelect);

      if (hitResult.type === 'handle' && hitResult.handle) {
        // Start handle dragging
        setIsDraggingDrawing(true);
        setSelectedDrawing(hitDrawing);
        setOriginalDrawing({ ...hitDrawing });
        // Store which handle is being dragged
        setDragOffset({ x: hitResult.handle.x - x, y: hitResult.handle.y - y });
      } else if (hitResult.type === 'body') {
        // Start drawing dragging
        setIsDraggingDrawing(true);
        setSelectedDrawing(hitDrawing);
        setOriginalDrawing({ ...hitDrawing });

        // Calculate offset from drawing start point to click point
        if (hitDrawing.startTimestamp && hitDrawing.startPrice) {
          const startCoords = timePriceToScreenCoordinates(hitDrawing.startTimestamp, hitDrawing.startPrice);
          setDragOffset({ x: startCoords.x - x, y: startCoords.y - y });
        }
      }

      // Double-click detection for properties panel
      const now = Date.now();
      if (lastClickDrawing?.id === hitDrawing.id && now - lastClickTime < 500) {
        setShowPropertiesPanel(true);
        setPropertiesPanelPosition({ x: e.clientX, y: e.clientY });
      }
      setLastClickDrawing(hitDrawing);
      setLastClickTime(now);

      return; // Don't proceed with chart dragging
    }

    // No drawing hit, proceed with chart navigation
    setSelectedDrawing(null);
    setSelectedDrawings([]);

    // Check if click is within valid chart bounds
    const timeAxisHeight = 25;
    const priceChartHeight = dimensions.height - timeAxisHeight;

    if (y > priceChartHeight) {
      // Click is below the chart (in time axis area) - don't allow dragging
      return;
    }

    // Stop any ongoing momentum animation when starting new interaction
    stopMomentumAnimation();

    // Initialize velocity tracking
    const now = Date.now();
    setLastMouseTimestamp(now);

    // Start X-axis panning only
    setIsDragging(true);
    setLastMouseX(x);
    setLastMouseY(y);
    setDragStartX(x);
    setDragStartOffset(scrollOffset);

    // DON'T set manualPriceRangeRef here - only set it when user actually drags Y

    // Mark this as first frame
    setIsFirstDragFrame(true);
    isFirstDragFrameRef.current = true;

    // DON'T set manualPriceRange here - let it update only when user actually drags vertically

  }, [drawings, detectDrawingHit, handleDrawingSelection, lastClickDrawing, lastClickTime, scrollOffset, data, visibleCandleCount, getCurrentPriceRange, manualPriceRange, stopMomentumAnimation, setManualPriceRangeAndDisableAuto, isOnYAxisBorder, isInYAxisArea]);

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // ALWAYS update crosshair position first
    setCrosshairPosition({ x, y });

    // Handle Y-axis drag to zoom (drag UP = compress, drag DOWN = expand)
    if (isDraggingYAxisZoom && yAxisZoomDragStart) {
      const deltaY = y - yAxisZoomDragStart.y;
      const timeAxisHeight = 25;
      const priceChartHeight = dimensions.height - timeAxisHeight;

      // Drag UP (negative deltaY) = compress (zoom in)
      // Drag DOWN (positive deltaY) = expand (zoom out)
      const zoomFactor = 1 + (deltaY / priceChartHeight) * 2; // Positive for correct direction, 2x sensitivity

      const originalRange = yAxisZoomDragStart.priceRange;
      const center = (originalRange.max + originalRange.min) / 2;
      const originalSpan = originalRange.max - originalRange.min;

      // Clamp zoom factor to prevent flipping (0.1 to 10x range)
      const clampedZoomFactor = Math.max(0.1, Math.min(10, zoomFactor));
      const newSpan = originalSpan * clampedZoomFactor;

      const newRange = {
        min: center - newSpan / 2,
        max: center + newSpan / 2
      };

      setManualPriceRangeAndDisableAuto(newRange);
      return;
    }

    // TradingView: Check if hovering over Y-axis border for resize cursor
    const canvas = e.currentTarget as HTMLCanvasElement;
    const canvasWidth = canvas.width / window.devicePixelRatio;
    const onBorder = isOnYAxisBorder(x, canvasWidth);

    // Update cursor when near Y-axis border
    if (onBorder && !isDragging && !isResizingYAxis) {
      setShowYAxisResizeCursor(true);
      canvas.style.cursor = 'ew-resize';
    } else if (!isDragging && !isResizingYAxis) {
      setShowYAxisResizeCursor(false);
      canvas.style.cursor = config.crosshair ? 'crosshair' : 'default';
    }

    // TradingView: Handle Y-axis resize drag
    if (isResizingYAxis && yAxisResizeStart) {
      const deltaY = y - yAxisResizeStart.y;
      const timeAxisHeight = 25;
      const priceChartHeight = dimensions.height - timeAxisHeight;

      // Calculate zoom based on vertical drag
      // Drag down = zoom out (expand range), drag up = zoom in (contract range)
      const zoomFactor = 1 + (deltaY / priceChartHeight) * 2; // 2x sensitivity

      const originalRange = yAxisResizeStart.priceRange;
      const center = (originalRange.max + originalRange.min) / 2;
      const originalSpan = originalRange.max - originalRange.min;
      const newSpan = originalSpan * zoomFactor;

      const newRange = {
        min: center - newSpan / 2,
        max: center + newSpan / 2
      };

      setManualPriceRangeAndDisableAuto(newRange);
      return;
    }

    // Update crosshair info with price and date/time
    if (data.length > 0) {
      const coords = screenToTimePriceCoordinates(x, y);
      const price = coords.price;
      const timestamp = coords.timestamp;

      // Check if we're in the future (seasonal projection area)
      const lastCandle = data[data.length - 1];
      const isInFuture = timestamp > lastCandle.timestamp;

      // Find the closest candle or seasonal projection point for OHLC data
      let closestCandle = null;
      let seasonalProjectionPrice = null;

      if (isInFuture && seasonalProjectionData && seasonalProjectionData.length > 0) {
        // Find closest seasonal projection point
        const projectionPoint = seasonalProjectionData.find(p => p.date.getTime() >= timestamp) ||
          seasonalProjectionData[seasonalProjectionData.length - 1];
        seasonalProjectionPrice = projectionPoint.price;
      } else {
        // Find the closest historical candle
        const candleIndex = data.findIndex(d => d.timestamp >= timestamp);
        closestCandle = data[Math.max(0, Math.min(candleIndex, data.length - 1))];
      }

      // Format date and time in ET timezone
      const date = new Date(timestamp);
      const dateStr = date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        timeZone: 'America/New_York'
      });
      const timeStr = date.toLocaleTimeString('en-US', {
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'America/New_York'
      });

      setCrosshairInfo({
        price: isInFuture && seasonalProjectionPrice ? `$${seasonalProjectionPrice.toFixed(2)} (Projection)` : `$${price.toFixed(2)}`,
        date: dateStr,
        time: timeStr,
        visible: true,
        ohlc: closestCandle ? {
          open: closestCandle.open,
          high: closestCandle.high,
          low: closestCandle.low,
          close: closestCandle.close,
          change: closestCandle.close - closestCandle.open,
          changePercent: ((closestCandle.close - closestCandle.open) / closestCandle.open) * 100,
          volume: closestCandle.volume
        } : undefined
      });
    }

    // Handle box zoom dragging
    if (isBoxZooming && boxZoomStart) {
      setBoxZoomEnd({ x, y });
      return;
    }

    // Handle drawing dragging
    if (isDraggingDrawing && selectedDrawing) {
      // Convert Y to price using the same calculation as chart rendering
      const timeAxisHeight = 25;
      const priceChartHeight = dimensions.height - timeAxisHeight;

      // Calculate visible data range for accurate price conversion
      const startIndex = Math.max(0, Math.floor(scrollOffset));
      const endIndex = Math.min(data.length, startIndex + visibleCandleCount);
      const visibleData = data.slice(startIndex, endIndex);

      if (visibleData.length > 0) {
        const prices = visibleData.flatMap(d => [d.high, d.low]);
        const minPrice = Math.min(...prices);
        const maxPrice = Math.max(...prices);
        const padding = (maxPrice - minPrice) * 0.1;
        const adjustedMin = minPrice - padding;
        const adjustedMax = maxPrice + padding;

        const newPrice = adjustedMax - ((y / priceChartHeight) * (adjustedMax - adjustedMin));

        setDrawings(prev => prev.map((d: any) =>
          d.id === selectedDrawing.id
            ? { ...d, price: newPrice, y }
            : d
        ));
      }
      return;
    }

    // ============================================================================
    // TRADINGVIEW-STYLE DRAG - X-AXIS ONLY
    // ============================================================================
    if (isDragging) {
      // Skip first frame to avoid jump, but update positions so next frame has correct delta
      if (isFirstDragFrameRef.current) {
        setIsFirstDragFrame(false);
        isFirstDragFrameRef.current = false;
        setLastMouseX(x);
        setLastMouseY(y);
        return;
      }

      // Track velocity for momentum scrolling
      const now = Date.now();
      const deltaTime = now - lastMouseTimestamp;

      // Calculate deltas for both X and Y
      const deltaX = x - lastMouseX;
      const deltaY = y - lastMouseY;

      if (deltaTime > 0 && deltaTime < 100) {
        const frameTime = 16.67;
        const velocityX = (deltaX / deltaTime) * frameTime;
        const velocityY = (deltaY / deltaTime) * frameTime;
        setVelocity({ x: velocityX, y: velocityY });
        setLastMouseTimestamp(now);
      }

      // X-axis dragging (time scroll)
      if (deltaX !== 0) {
        setScrollOffset(currentScrollOffset => {
          const Y_AXIS_WIDTH = 80;
          const chartWidth = dimensions.width - Y_AXIS_WIDTH;
          const pixelsPerCandle = chartWidth / visibleCandleCount;
          const candlesDragged = deltaX / pixelsPerCandle;
          const newOffset = currentScrollOffset - candlesDragged;
          const futurePeriods = getFuturePeriods(visibleCandleCount);
          const maxScrollOffset = data.length - visibleCandleCount + futurePeriods;
          const clampedOffset = Math.max(0, Math.min(maxScrollOffset, newOffset));
          return clampedOffset;
        });
      }

      // Y-axis dragging (price panning) - simple vertical drag
      if (deltaY !== 0 && !isDraggingYAxisZoom) {
        // On first Y drag: get base from ref (if set) OR state OR last rendered range
        const baseRange = manualPriceRangeRef.current || manualPriceRange || lastRenderedPriceRangeRef.current;

        const timeAxisHeight = 25;
        const priceChartHeight = dimensions.height - timeAxisHeight;
        const priceHeight = baseRange.max - baseRange.min;
        const pricePerPixel = priceHeight / priceChartHeight;
        const priceShift = deltaY * pricePerPixel;

        const newRange = {
          min: baseRange.min + priceShift,
          max: baseRange.max + priceShift
        };

        // Update ref immediately for next frame (synchronous)
        manualPriceRangeRef.current = newRange;
        // Update state to trigger re-render
        setManualPriceRange(newRange);
        setIsAutoScale(false);
      }

      setLastMouseX(x);
      setLastMouseY(y);
      return;
    }
  }, [isDragging, isDraggingDrawing, selectedDrawing, lastMouseX, lastMouseY, visibleCandleCount, data, dimensions, priceRange, config.crosshair, isAutoScale, getFuturePeriods, config.timeframe, actualPriceChartHeight, seasonalProjectionData, screenToTimePriceCoordinates, setCrosshairInfo, setCrosshairPosition, isOnYAxisBorder, isResizingYAxis, yAxisResizeStart, isFirstDragFrame, scrollOffset, isDraggingYAxisZoom, yAxisZoomDragStart, setManualPriceRangeAndDisableAuto, getCurrentPriceRange, manualPriceRange, manualPriceRangeRef]);

  const handleMouseUp = useCallback(() => {

    // Handle box zoom completion
    if (isBoxZooming && boxZoomStart && boxZoomEnd) {
      const startX = Math.min(boxZoomStart.x, boxZoomEnd.x);
      const endX = Math.max(boxZoomStart.x, boxZoomEnd.x);
      const startY = Math.min(boxZoomStart.y, boxZoomEnd.y);
      const endY = Math.max(boxZoomStart.y, boxZoomEnd.y);

      // Only proceed if the box is large enough (minimum 20x20 pixels)
      if (Math.abs(endX - startX) > 20 && Math.abs(endY - startY) > 20) {
        // Convert screen coordinates to chart data coordinates
        const chartWidth = dimensions.width - 100; // Account for margins
        const candleWidth = chartWidth / visibleCandleCount;

        // Calculate new time range (X-axis)
        const startCandleIndex = Math.floor((startX - 40) / candleWidth);
        const endCandleIndex = Math.floor((endX - 40) / candleWidth);
        const newVisibleCount = Math.max(20, Math.min(300, endCandleIndex - startCandleIndex));
        const newScrollOffset = Math.max(0, Math.min(
          data.length - newVisibleCount,
          scrollOffset + startCandleIndex
        ));

        // Calculate new price range (Y-axis)
        const timeAxisHeight = 25;
        const priceChartHeight = dimensions.height - timeAxisHeight;

        // Get current price range for conversion
        const startIndex = Math.max(0, Math.floor(scrollOffset));
        const endIndex = Math.min(data.length, startIndex + visibleCandleCount);
        const visibleData = data.slice(startIndex, endIndex);
        const currentRange = getCurrentPriceRange(visibleData);

        // Convert Y coordinates to prices
        const maxPrice = currentRange.max - ((startY / priceChartHeight) * (currentRange.max - currentRange.min));
        const minPrice = currentRange.max - ((endY / priceChartHeight) * (currentRange.max - currentRange.min));

        // Apply zoom
        setVisibleCandleCount(newVisibleCount);
        setScrollOffset(newScrollOffset);
        setManualPriceRangeAndDisableAuto({ min: minPrice, max: maxPrice });
      }

      // Reset box zoom state
      setIsBoxZooming(false);
      setBoxZoomStart(null);
      setBoxZoomEnd(null);
      return;
    }

    // ============================================================================
    // TRADINGVIEW-STYLE MOMENTUM - Start if velocity is significant
    // ============================================================================
    if (isDragging) {
      const minMomentumVelocity = 0.5; // Minimum velocity to trigger momentum
      if (Math.abs(velocity.x) > minMomentumVelocity || Math.abs(velocity.y) > minMomentumVelocity) {
        console.log('ðŸš€ Starting momentum animation:', velocity);
        startMomentumAnimation();
      }
    }


    setIsDragging(false);
    setIsDraggingDrawing(false);
    setIsBoxZooming(false);
    setBoxZoomStart(null);
    setBoxZoomEnd(null);

    // Stop Y-axis drag to zoom
    setIsDraggingYAxisZoom(false);
    setYAxisZoomDragStart(null);

    // TradingView: Stop Y-axis resize
    setIsResizingYAxis(false);
    setYAxisResizeStart(null);

    // Handle parallel channel editing cleanup
    setIsEditingChannel(false);
    setChannelDragStart(null);

    // DON'T clear selectedDrawing here - it closes the Property Editor!
    // setSelectedDrawing(null);
  }, [isBoxZooming, boxZoomStart, boxZoomEnd, dimensions, visibleCandleCount, scrollOffset, data.length, getCurrentPriceRange, setManualPriceRangeAndDisableAuto, isDragging, velocity, startMomentumAnimation]);

  // Simple drawing rendering effect - COMPLETELY DISABLED to prevent conflicts with main TradingView drawing system
  useEffect(() => {
    // This system is completely disabled because it conflicts with the main comprehensive drawing system
    // The main drawing system is in the drawStoredDrawings function
    return;
  }, [drawings]);

  const handleMouseLeave = useCallback(() => {
    // Hide crosshair info when mouse leaves chart area
    setCrosshairInfo(prev => ({ ...prev, visible: false }));
  }, []);

  const handleDoubleClick = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    console.log('?? DOUBLE CLICK EVENT FIRED!');

    const canvas = e.currentTarget;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Check if double-clicking on Y-axis area for auto-fit
    const canvasWidth = canvas.width / window.devicePixelRatio;
    const isOverYAxis = isInYAxisArea(x, canvasWidth);

    if (isOverYAxis) {
      // Double-click on Y-axis: reset to auto-scale
      resetToAutoScale();
      console.log('?? Y-axis double-click: Reset to auto-scale');
      return;
    }

    // Check if we're double-clicking on a drawing
    if (!activeTool) {
      const clickedDrawing = findDrawingAtPoint({ x, y });
      console.log('?? Double-click found drawing:', clickedDrawing);

      if (clickedDrawing) {
        // Open property editor on double-click on drawing
        setSelectedDrawing(clickedDrawing);

        // Property editor removed - drawing tools were removed as requested

        console.log('?? Property editor removed - drawing tools were removed');

        // PREVENT the editor from being closed immediately
        // Add a flag to prevent auto-closing for a few seconds
        setTimeout(() => {
          console.log('? Property editor protection timeout ended');
        }, 3000);

        return;
      }
    }

    // Double-click on empty space removed - no action
  }, [data.length, activeTool, isInYAxisArea, resetToAutoScale]);

  // Handle timeframe change - SIMPLE DIRECT FETCH (no broken cache)
  const handleTimeframeChange = (timeframe: string) => {
    console.log(`ðŸ”„ TIMEFRAME CHANGE: ${symbol} -> ${timeframe}`);
    console.log(`ðŸ“Š Current data length before change: ${data.length}`);
    console.log(`â³ Current loading state: ${loading}`);

    // If in multichart mode, update the active chart instance
    if (chartLayout !== '1x1' && activeChartId) {
      console.log(`ðŸ“Š MULTICHART: Changing timeframe for active chart ${activeChartId}`);
      const updatedInstances = chartInstances.map(inst =>
        inst.id === activeChartId ? { ...inst, timeframe } : inst
      );
      setChartInstances(updatedInstances);
      // Let MultiChartView handle the data fetch for this chart
      return;
    }

    // Single chart mode - ALWAYS fetch fresh data
    console.log(`ðŸ”„ FRESH FETCH: Getting live ${timeframe} data for ${symbol}`);
    fetchData(symbol, timeframe);

    // Update config
    setConfig(prev => ({ ...prev, timeframe }));
    onTimeframeChange?.(timeframe);
  };

  // Handle chart type change
  const handleChartTypeChange = (chartType: ChartConfig['chartType']) => {
    setConfig(prev => ({ ...prev, chartType }));
  };

  // Handle symbol change with instant preloading
  const handleSymbolChange = (newSymbol: string) => {
    // If in multichart mode, update only the active chart instance
    if (chartLayout !== '1x1' && activeChartId) {
      console.log(`ðŸ“Š MULTICHART: Changing symbol for active chart ${activeChartId} to ${newSymbol}`);
      const updatedInstances = chartInstances.map(inst =>
        inst.id === activeChartId ? { ...inst, symbol: newSymbol } : inst
      );
      setChartInstances(updatedInstances);
      // Let MultiChartView handle the data fetch for this chart
      return;
    }

    // Single chart mode
    setConfig(prev => ({ ...prev, symbol: newSymbol }));
    onSymbolChange?.(newSymbol);
  };

  // Drawing Tools Functions
  const selectDrawingTool = (toolValue: string) => {
    console.log(`?? Activating drawing tool: ${toolValue}`);
    console.log(`?? Previous activeTool: ${activeTool}`);
    setActiveTool(toolValue);
    console.log(`?? Set activeTool to: ${toolValue}`);
    setShowToolsDropdown(false);

    // Reset any ongoing drawing
    setIsDrawing(false);
    setDrawingStartPoint(null);
  };

  const clearActiveTool = () => {
    console.log(`?? Deactivating drawing tool: ${activeTool}`);
    setActiveTool(null);
    setIsDrawing(false);
    setDrawingStartPoint(null);
  };

  const clearAllDrawings = () => {
    setDrawings([]);
    setConfig(prev => ({ ...prev, drawings: [] }));
  };

  // Helper functions for coordinate conversion
  const canvasToPrice = (canvasY: number, minPrice: number, maxPrice: number, chartHeight: number): number => {
    const padding = (maxPrice - minPrice) * 0.1;
    const adjustedMin = minPrice - padding;
    const adjustedMax = maxPrice + padding;
    const priceRange = adjustedMax - adjustedMin;
    return adjustedMax - (canvasY / chartHeight) * priceRange;
  };

  const priceToCanvas = (price: number, minPrice: number, maxPrice: number, chartHeight: number): number => {
    const padding = (maxPrice - minPrice) * 0.1;
    const adjustedMin = minPrice - padding;
    const adjustedMax = maxPrice + padding;
    const priceRange = adjustedMax - adjustedMin;
    return ((adjustedMax - price) / priceRange) * chartHeight;
  };

  const canvasToTime = (canvasX: number, chartWidth: number, visibleDataLength: number, startIndex: number): number => {
    const index = Math.floor((canvasX / chartWidth) * visibleDataLength) + startIndex;
    return Math.max(0, Math.min(data.length - 1, index));
  };

  const timeToCanvas = (timeIndex: number, chartWidth: number, visibleDataLength: number, startIndex: number): number => {
    const relativeIndex = timeIndex - startIndex;
    return (relativeIndex / visibleDataLength) * chartWidth;
  };

  // Enhanced Canvas Drawing Interaction Handlers
  const handleCanvasMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    return;
  };

  // Helper function to get current chart price range (for chart rendering - changes with scrolling)
  const getCurrentChartPriceRange = useCallback((): { min: number; max: number } => {
    // PRIORITY: Use manualPriceRangeRef for real-time drag updates
    const currentManualRange = manualPriceRangeRef.current || manualPriceRange;

    if (currentManualRange) {
      return currentManualRange;
    }

    if (!data || data.length === 0) return { min: 0, max: 100 };

    // Get visible data range
    const startIndex = Math.max(0, scrollOffset);
    const endIndex = Math.min(data.length, scrollOffset + visibleCandleCount);
    const visibleData = data.slice(startIndex, endIndex);

    if (visibleData.length === 0) return { min: 0, max: 100 };

    // Use the new Y-axis scaling logic
    return getCurrentPriceRange(visibleData);
  }, [manualPriceRange, data, scrollOffset, visibleCandleCount, getCurrentPriceRange]);

  // TradingView-style coordinate conversion: Time/Price â†’ Screen
  const timePriceToScreenCoordinates = (timestamp: number, price: number, useStableRange: boolean = false): { x: number; y: number } => {
    const canvas = overlayCanvasRef.current;
    if (!canvas || !data.length) return { x: 0, y: 0 };

    const rect = canvas.getBoundingClientRect();
    const chartWidth = rect.width - 80; // Account for margins

    // Find the candle index for this timestamp
    let candleIndex = data.findIndex(candle => candle.timestamp >= timestamp);
    if (candleIndex === -1) candleIndex = data.length - 1; // If not found, use last candle

    // MATCH the timeToScreenX logic exactly for consistency
    const candleWidth = chartWidth / visibleCandleCount;
    const visibleStartIndex = scrollOffset;
    const visibleEndIndex = scrollOffset + visibleCandleCount;

    let x: number;
    if (candleIndex < visibleStartIndex || candleIndex >= visibleEndIndex) {
      // Drawing is outside visible range - position it off-screen but proportionally
      const relativePosition = candleIndex - scrollOffset;
      x = relativePosition * candleWidth + candleWidth / 2 + 40;
    } else {
      // Drawing is in visible range - position it correctly
      const positionInVisibleRange = candleIndex - visibleStartIndex;
      x = positionInVisibleRange * candleWidth + candleWidth / 2 + 40;
    }

    // Convert price to screen Y - use current range for all drawings to match chart
    const priceChartHeight = rect.height * 0.7;
    const currentPriceRange = getCurrentChartPriceRange();
    const relativePrice = (price - currentPriceRange.min) / (currentPriceRange.max - currentPriceRange.min);
    const y = priceChartHeight - (relativePrice * priceChartHeight);

    return { x, y };
  };

  // Legacy helper functions for backward compatibility
  const getPriceAtY = (y: number): number => {
    return screenToTimePriceCoordinates(0, y).price;
  };

  const screenToDataCoordinates = (screenX: number, screenY: number): { candleIndex: number; price: number } => {
    const timePrice = screenToTimePriceCoordinates(screenX, screenY);
    // Find candle index for the timestamp
    const candleIndex = data.findIndex(candle => candle.timestamp >= timePrice.timestamp);
    return {
      candleIndex: candleIndex === -1 ? data.length - 1 : candleIndex,
      price: timePrice.price
    };
  };

  const dataToScreenCoordinates = (candleIndex: number, price: number): { x: number; y: number } => {
    if (candleIndex >= data.length) return { x: 0, y: 0 };
    const timestamp = data[candleIndex]?.timestamp || Date.now();
    return timePriceToScreenCoordinates(timestamp, price);
  };

  // Helper function to calculate drawing metadata
  const calculateDrawingMetadata = (toolType: string, start: { x: number, y: number }, end: { x: number, y: number }) => {
    const metadata: DrawingMetadata = {};

    switch (toolType) {
      case 'ruler':
        metadata.distance = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
        metadata.angle = Math.atan2(end.y - start.y, end.x - start.x) * 180 / Math.PI;
        metadata.priceDistance = Math.abs(getPriceAtY(end.y) - getPriceAtY(start.y));
        break;
      case 'regression':
        metadata.slope = (end.y - start.y) / (end.x - start.x);
        break;
    }

    return metadata;
  };

  // Helper function to get tool-specific metadata
  const getToolMetadata = (toolType: string, points: { x: number, y: number }[]) => {
    const metadata: DrawingMetadata = {};

    switch (toolType) {
      // Pattern-specific metadata removed
    }

    return metadata;
  };

  // Handle text input submission
  const handleTextSubmit = () => {
    if (textInputPosition && drawingText) {
      const newDrawing = {
        id: Date.now(),
        type: activeTool || 'unknown',
        startPoint: textInputPosition,
        endPoint: textInputPosition,
        timestamp: Date.now(),
        style: drawingStyle,
        text: drawingText
      };

      setDrawings(prev => [...prev, newDrawing]);
      setShowTextInput(false);
      setDrawingText('');
      setTextInputPosition(null);
      setActiveTool(null);
    }
  };

  // Helper function to test if a point is near a drawing (hit testing)
  const isPointNearDrawing = (point: { x: number; y: number }, drawing: Drawing, tolerance = 8): boolean => {
    const { x, y } = point;

    // Get current screen coordinates for the drawing
    let startPoint = drawing.startPoint;
    let endPoint = drawing.endPoint;
    let points = drawing.points;

    // If data coordinates exist, convert them to current screen coordinates
    if (drawing.startDataPoint) {
      const screenCoords = dataToScreenCoordinates(drawing.startDataPoint.candleIndex, drawing.startDataPoint.price);
      startPoint = screenCoords;
    }
    if (drawing.endDataPoint) {
      const screenCoords = dataToScreenCoordinates(drawing.endDataPoint.candleIndex, drawing.endDataPoint.price);
      endPoint = screenCoords;
    }
    if (drawing.dataPoints && drawing.dataPoints.length > 0) {
      points = drawing.dataPoints.map(dataPoint =>
        dataToScreenCoordinates(dataPoint.candleIndex, dataPoint.price)
      );
    }

    switch (drawing.type) {
      case 'trend_line':
      case 'extended_line':
        return startPoint && endPoint ?
          isPointNearLine(x, y, startPoint, endPoint, tolerance) : false;

      case 'horizontal_line':
        return startPoint ? Math.abs(y - startPoint.y) <= tolerance : false;

      case 'vertical_line':
        return startPoint ? Math.abs(x - startPoint.x) <= tolerance : false;

      case 'rectangle':
        return startPoint && endPoint ?
          isPointInRectangle(x, y, startPoint, endPoint, tolerance) : false;

      case 'ellipse':
      case 'circle':
        return startPoint && endPoint ?
          isPointNearEllipse(x, y, startPoint, endPoint, tolerance) : false;

      case 'text':
      case 'note':
      case 'callout':
        return startPoint ?
          isPointInTextBox(x, y, startPoint, drawing.text || '', tolerance) : false;

      default:
        return startPoint && endPoint ?
          isPointNearLine(x, y, startPoint, endPoint, tolerance) : false;
    }
  };

  // Utility functions for hit testing
  const isPointNearLine = (x: number, y: number, start: { x: number; y: number }, end: { x: number; y: number }, tolerance: number): boolean => {
    const A = x - start.x;
    const B = y - start.y;
    const C = end.x - start.x;
    const D = end.y - start.y;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;

    if (lenSq === 0) return Math.sqrt(A * A + B * B) <= tolerance;

    const param = dot / lenSq;

    let xx, yy;
    if (param < 0) {
      xx = start.x;
      yy = start.y;
    } else if (param > 1) {
      xx = end.x;
      yy = end.y;
    } else {
      xx = start.x + param * C;
      yy = start.y + param * D;
    }

    const dx = x - xx;
    const dy = y - yy;
    return Math.sqrt(dx * dx + dy * dy) <= tolerance;
  };

  const isPointInRectangle = (x: number, y: number, start: { x: number; y: number }, end: { x: number; y: number }, tolerance: number): boolean => {
    const minX = Math.min(start.x, end.x) - tolerance;
    const maxX = Math.max(start.x, end.x) + tolerance;
    const minY = Math.min(start.y, end.y) - tolerance;
    const maxY = Math.max(start.y, end.y) + tolerance;

    return x >= minX && x <= maxX && y >= minY && y <= maxY;
  };

  const isPointNearEllipse = (x: number, y: number, start: { x: number; y: number }, end: { x: number; y: number }, tolerance: number): boolean => {
    const centerX = (start.x + end.x) / 2;
    const centerY = (start.y + end.y) / 2;
    const radiusX = Math.abs(end.x - start.x) / 2;
    const radiusY = Math.abs(end.y - start.y) / 2;

    const dx = x - centerX;
    const dy = y - centerY;
    const distance = Math.sqrt((dx * dx) / (radiusX * radiusX) + (dy * dy) / (radiusY * radiusY));

    return Math.abs(distance - 1) <= tolerance / Math.min(radiusX, radiusY);
  };

  const isPointInTextBox = (x: number, y: number, position: { x: number; y: number }, text: string, tolerance: number): boolean => {
    const textWidth = text.length * 8; // Approximate
    const textHeight = 16;

    return x >= position.x - tolerance &&
      x <= position.x + textWidth + tolerance &&
      y >= position.y - textHeight - tolerance &&
      y <= position.y + tolerance;
  };

  // Function to find drawing at point
  const findDrawingAtPoint = (point: { x: number; y: number }): Drawing | null => {
    for (let i = drawings.length - 1; i >= 0; i--) {
      if (isPointNearDrawing(point, drawings[i])) {
        return drawings[i];
      }
    }
    return null;
  };

  // Function to move a drawing to absolute position based on original drawing
  const moveDrawingToPosition = (drawingId: number, deltaX: number, deltaY: number, originalDrawing: any) => {
    setDrawings(prev => prev.map(drawing => {
      if (drawing.id === drawingId) {
        const updatedDrawing = { ...originalDrawing }; // Start with the original drawing

        // Move data coordinates (TradingView-style absolute coordinates)
        if (originalDrawing.startDataPoint) {
          const originalScreenCoords = dataToScreenCoordinates(originalDrawing.startDataPoint.candleIndex, originalDrawing.startDataPoint.price);
          const newScreenCoords = { x: originalScreenCoords.x + deltaX, y: originalScreenCoords.y + deltaY };
          const newDataCoords = screenToDataCoordinates(newScreenCoords.x, newScreenCoords.y);
          updatedDrawing.startDataPoint = newDataCoords;
        }

        if (originalDrawing.endDataPoint) {
          const originalScreenCoords = dataToScreenCoordinates(originalDrawing.endDataPoint.candleIndex, originalDrawing.endDataPoint.price);
          const newScreenCoords = { x: originalScreenCoords.x + deltaX, y: originalScreenCoords.y + deltaY };
          const newDataCoords = screenToDataCoordinates(newScreenCoords.x, newScreenCoords.y);
          updatedDrawing.endDataPoint = newDataCoords;
        }

        if (originalDrawing.dataPoints && originalDrawing.dataPoints.length > 0) {
          updatedDrawing.dataPoints = originalDrawing.dataPoints.map((dataPoint: any) => {
            const originalScreenCoords = dataToScreenCoordinates(dataPoint.candleIndex, dataPoint.price);
            const newScreenCoords = { x: originalScreenCoords.x + deltaX, y: originalScreenCoords.y + deltaY };
            return screenToDataCoordinates(newScreenCoords.x, newScreenCoords.y);
          });
        }

        // Also update screen coordinates for immediate visual feedback (these get recalculated on render anyway)
        if (originalDrawing.startPoint) {
          updatedDrawing.startPoint = {
            x: originalDrawing.startPoint.x + deltaX,
            y: originalDrawing.startPoint.y + deltaY
          };
        }

        if (originalDrawing.endPoint) {
          updatedDrawing.endPoint = {
            x: originalDrawing.endPoint.x + deltaX,
            y: originalDrawing.endPoint.y + deltaY
          };
        }

        if (originalDrawing.points) {
          updatedDrawing.points = originalDrawing.points.map((point: { x: number; y: number }) => ({
            x: point.x + deltaX,
            y: point.y + deltaY
          }));
        }

        return updatedDrawing;
      }
      return drawing;
    }));
  };

  // Function to move a drawing
  const moveDrawing = (drawingId: number, deltaX: number, deltaY: number) => {
    setDrawings(prev => prev.map(drawing => {
      if (drawing.id === drawingId) {
        const updatedDrawing = { ...drawing };

        // Move data coordinates (TradingView-style absolute coordinates)
        if (drawing.startDataPoint) {
          const currentScreenCoords = dataToScreenCoordinates(drawing.startDataPoint.candleIndex, drawing.startDataPoint.price);
          const newScreenCoords = { x: currentScreenCoords.x + deltaX, y: currentScreenCoords.y + deltaY };
          const newDataCoords = screenToDataCoordinates(newScreenCoords.x, newScreenCoords.y);
          updatedDrawing.startDataPoint = newDataCoords;
        }

        if (drawing.endDataPoint) {
          const currentScreenCoords = dataToScreenCoordinates(drawing.endDataPoint.candleIndex, drawing.endDataPoint.price);
          const newScreenCoords = { x: currentScreenCoords.x + deltaX, y: currentScreenCoords.y + deltaY };
          const newDataCoords = screenToDataCoordinates(newScreenCoords.x, newScreenCoords.y);
          updatedDrawing.endDataPoint = newDataCoords;
        }

        if (drawing.dataPoints && drawing.dataPoints.length > 0) {
          updatedDrawing.dataPoints = drawing.dataPoints.map(dataPoint => {
            const currentScreenCoords = dataToScreenCoordinates(dataPoint.candleIndex, dataPoint.price);
            const newScreenCoords = { x: currentScreenCoords.x + deltaX, y: currentScreenCoords.y + deltaY };
            return screenToDataCoordinates(newScreenCoords.x, newScreenCoords.y);
          });
        }

        // Also update screen coordinates for immediate visual feedback (these get recalculated on render anyway)
        if (drawing.startPoint) {
          updatedDrawing.startPoint = {
            x: drawing.startPoint.x + deltaX,
            y: drawing.startPoint.y + deltaY
          };
        }

        if (drawing.endPoint) {
          updatedDrawing.endPoint = {
            x: drawing.endPoint.x + deltaX,
            y: drawing.endPoint.y + deltaY
          };
        }

        if (drawing.points) {
          updatedDrawing.points = drawing.points.map((point: { x: number; y: number }) => ({
            x: point.x + deltaX,
            y: point.y + deltaY
          }));
        }

        return updatedDrawing;
      }
      return drawing;
    }));
  };

  const handleCanvasMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = e.currentTarget;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Update crosshair position - these coordinates should match exactly with drawing coordinates
    setCrosshairPosition({ x, y });

    // Set cursor for horizontal ray mode to precise crosshair for better alignment
    canvas.style.cursor = 'default';
  };

  const handleCanvasMouseUp = (e: React.MouseEvent<HTMLCanvasElement>) => {
  };

  // Helper function to draw arrow heads
  const drawArrowHead = (ctx: CanvasRenderingContext2D, fromX: number, fromY: number, toX: number, toY: number) => {
    const headlen = 15; // length of head in pixels
    const angle = Math.atan2(toY - fromY, toX - fromX);

    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
  };

  // TradingView-style drawing renderer: converts time+price coordinates to screen position
  const drawStoredDrawings = (ctx: CanvasRenderingContext2D) => {
    const currentDrawings = drawingsRef.current;

    if (currentDrawings.length === 0) {
      return;
    }

    // TradingView coordinate conversion: time+price â†’ screen coordinates
    const timeToScreenX = (timestamp: number): number => {
      if (!data || data.length === 0) return 0;

      const canvas = overlayCanvasRef.current;
      if (!canvas) return 0;

      const rect = canvas.getBoundingClientRect();
      const chartWidth = rect.width - 80; // Account for margins
      const candleWidth = chartWidth / visibleCandleCount;

      // Find the candle index for this timestamp
      let candleIndex = data.findIndex((candle: any) => candle.timestamp >= timestamp);

      // Handle future timestamps beyond the last data candle
      if (candleIndex === -1) {
        const lastCandle = data[data.length - 1];
        if (timestamp > lastCandle.timestamp) {
          // Calculate future candle index based on timeframe
          const timeframe = config.timeframe;
          let millisecondsPerPeriod = 0;

          switch (timeframe) {
            case '1m': millisecondsPerPeriod = 60 * 1000; break;
            case '5m': millisecondsPerPeriod = 5 * 60 * 1000; break;
            case '15m': millisecondsPerPeriod = 15 * 60 * 1000; break;
            case '30m': millisecondsPerPeriod = 30 * 60 * 1000; break;
            case '1h': millisecondsPerPeriod = 60 * 60 * 1000; break;
            case '4h': millisecondsPerPeriod = 4 * 60 * 60 * 1000; break;
            case '1d': millisecondsPerPeriod = 24 * 60 * 60 * 1000; break;
            case '1w': millisecondsPerPeriod = 7 * 24 * 60 * 60 * 1000; break;
            case '1mo': millisecondsPerPeriod = 30 * 24 * 60 * 60 * 1000; break;
            case '1y': millisecondsPerPeriod = 365 * 24 * 60 * 60 * 1000; break;
            default: millisecondsPerPeriod = 24 * 60 * 60 * 1000; break;
          }

          const periodsIntoFuture = Math.round((timestamp - lastCandle.timestamp) / millisecondsPerPeriod);
          candleIndex = data.length - 1 + periodsIntoFuture;
        } else {
          return ctx.canvas.width; // Timestamp before all data
        }
      }

      // CRITICAL INSIGHT: The drawing should stay at the SAME TIMESTAMP position
      // When we scroll, we see different timestamps, so the drawing should move accordingly

      // Calculate where this timestamp appears on the current screen
      // If the timestamp is outside the visible range, it should be off-screen
      const visibleStartIndex = scrollOffset;
      const visibleEndIndex = scrollOffset + visibleCandleCount;

      if (candleIndex < visibleStartIndex || candleIndex >= visibleEndIndex) {
        // Drawing is outside visible range - position it off-screen but proportionally
        const relativePosition = candleIndex - scrollOffset;
        return relativePosition * candleWidth + candleWidth / 2 + 40;
      }

      // Drawing is in visible range - position it correctly
      const positionInVisibleRange = candleIndex - visibleStartIndex;
      const x = positionInVisibleRange * candleWidth + candleWidth / 2 + 40;

      return x;
    };

    const priceToScreenY = (price: number): number => {
      // Use STABLE price range for drawing positioning (doesn't change with scrolling)
      const stablePriceRange = getStablePriceRange();
      const { min: low, max: high } = stablePriceRange;
      const priceHeight = high - low;
      if (priceHeight === 0) return ctx.canvas.height / 2;

      // Convert price to screen Y coordinate (inverted: high price = low Y)
      const canvas = overlayCanvasRef.current;
      if (!canvas) return ctx.canvas.height / 2;

      const rect = canvas.getBoundingClientRect();
      const priceChartHeight = rect.height * 0.7; // 70% for price chart
      const normalizedPrice = (price - low) / priceHeight;
      return priceChartHeight - (normalizedPrice * priceChartHeight);
    };

    // Helper function to convert TradingView coordinates to screen coordinates
    const getScreenCoordinates = (drawing: Drawing) => {
      let startPoint: DrawingPoint | null = null;
      let endPoint: DrawingPoint | null = null;
      let points: DrawingPoint[] | null = null;

      console.log('?? Converting TradingView coordinates to screen:', drawing);

      // PRIORITY 1: New TradingView time/price coordinate system
      // Single point drawings (ray, vertical_line, horizontal_line)
      if (drawing.time && drawing.price !== undefined) {
        console.log('?? Converting single TIME/PRICE coordinates:', { time: drawing.time, price: drawing.price });

        // For rays: use the exact stored pixel coordinates - NO CALCULATIONS
        if ((drawing.type === 'ray' || drawing.type === 'horizontal_line') && drawing.absoluteScreenY !== undefined) {
          // SIMPLE: Use exact stored click coordinates
          const xCoord = drawing.clickX || 40; // Use stored X or default
          const yCoord = drawing.absoluteScreenY; // Use exact stored Y pixel

          startPoint = {
            x: xCoord,
            y: yCoord
          };

          console.log('?? RAY USING EXACT STORED PIXELS:', {
            storedX: drawing.clickX,
            storedY: drawing.absoluteScreenY,
            finalPoint: startPoint,
            drawingId: drawing.id
          });
        } else {
          // Normal coordinate conversion for other drawings
          startPoint = timePriceToScreenCoordinates(drawing.time, drawing.price);
          console.log('?? USING CALCULATED COORDINATES:', startPoint);
        }
      }

      // Two point drawings (trend_line, etc.)
      if (drawing.time1 && drawing.price1 !== undefined) {
        console.log('?? Converting START TIME/PRICE coordinates:', { time: drawing.time1, price: drawing.price1 });
        // Use current range for trend lines to match chart scaling
        const useStableRange = false; // Trend lines should follow chart scaling
        startPoint = timePriceToScreenCoordinates(drawing.time1, drawing.price1, useStableRange);
        console.log('?? Start point screen coordinates:', startPoint);
      }

      if (drawing.time2 && drawing.price2 !== undefined) {
        console.log('?? Converting END TIME/PRICE coordinates:', { time: drawing.time2, price: drawing.price2 });
        // Use current range for trend lines to match chart scaling
        const useStableRange = false; // Trend lines should follow chart scaling
        endPoint = timePriceToScreenCoordinates(drawing.time2, drawing.price2, useStableRange);
        console.log('?? End point screen coordinates:', endPoint);
      }

      // Multi-point drawings (general patterns, etc.)
      if (drawing.points && drawing.points.length > 0 && drawing.points[0].timestamp && drawing.points[0].price !== undefined) {
        console.log('?? Converting MULTI TIME/PRICE coordinates:', drawing.points.length, 'points');
        points = drawing.points.map((point, index) => {
          const screenCoords = timePriceToScreenCoordinates(point.timestamp!, point.price!);
          console.log(`?? Point ${index + 1} screen coordinates:`, screenCoords);
          return screenCoords;
        });
      }

      // FALLBACK 1: Legacy coordinate handling - already in correct format above

      // FALLBACK 2: Legacy TradingView coordinate system (no changes needed - handled above)

      // FALLBACK 2: Data coordinate system (legacy)
      if (!startPoint && drawing.startDataPoint) {
        console.log('?? Fallback to data coordinates for start point');
        const screenCoords = dataToScreenCoordinates(drawing.startDataPoint.candleIndex, drawing.startDataPoint.price);
        startPoint = screenCoords;
      }
      if (!endPoint && drawing.endDataPoint) {
        console.log('?? Fallback to data coordinates for end point');
        const screenCoords = dataToScreenCoordinates(drawing.endDataPoint.candleIndex, drawing.endDataPoint.price);
        endPoint = screenCoords;
      }
      if (!points && drawing.dataPoints && drawing.dataPoints.length > 0) {
        console.log('?? Fallback to data coordinates for multi points');
        points = drawing.dataPoints.map(dataPoint =>
          dataToScreenCoordinates(dataPoint.candleIndex, dataPoint.price)
        );
      }

      // FALLBACK 3: Raw screen coordinates (legacy - will move with chart!)
      if (!startPoint && drawing.startPoint) {
        console.log('?? Using raw screen coordinates for start point (WILL MOVE WITH CHART!)');
        startPoint = drawing.startPoint;
      }
      if (!endPoint && drawing.endPoint) {
        console.log('?? Using raw screen coordinates for end point (WILL MOVE WITH CHART!)');
        endPoint = drawing.endPoint;
      }
      if (!points && drawing.points) {
        console.log('?? Using raw screen coordinates for multi points (WILL MOVE WITH CHART!)');
        points = drawing.points;
      }

      console.log('? Final screen coordinates:', { startPoint, endPoint, points });
      return { startPoint, endPoint, points };
    };

    // Drawing rendering has been removed as requested
    // Only core chart functionality remains
  };

  // Property Editor has been removed - drawing tools were removed as requested

  // Handle sidebar button clicks
  const handleSidebarClick = (id: string) => {
    console.log('Sidebar button clicked:', id, 'Current panel:', activeSidebarPanel);
    setActiveSidebarPanel(activeSidebarPanel === id ? null : id);
  };

  // Watchlist Panel Component - Bloomberg Terminal Style with 4-Column Performance
  const WatchlistPanel = ({ activeTab, setActiveTab }: { activeTab: string, setActiveTab: (tab: string) => void }) => {

    // Ref to preserve scroll position during re-renders
    const watchlistScrollRef = useRef<HTMLDivElement>(null);
    const scrollPositionRef = useRef<number>(0);
    const lastDataHashRef = useRef<string>('');

    // Restore scroll position immediately after render (synchronous)
    useLayoutEffect(() => {
      const scrollContainer = watchlistScrollRef.current;
      if (scrollContainer && scrollPositionRef.current > 0) {
        scrollContainer.scrollTop = scrollPositionRef.current;
      }
    });

    // Save scroll position on scroll (use callback for stability)
    const handleScroll = useCallback(() => {
      if (watchlistScrollRef.current) {
        scrollPositionRef.current = watchlistScrollRef.current.scrollTop;
      }
    }, []);

    // Fetch data when tab, timeframe, or symbols change - stable reference
    const stableSymbols = useMemo(() => [...pdSelectedSymbols].sort().join(','), [pdSelectedSymbols]);

    useEffect(() => {
      if (activeTab === 'Performance Dashboard' && pdSelectedSymbols.length > 0) {
        const currentSymbolsKey = `${stableSymbols}_${pdTimeframe}`;
        if (currentSymbolsKey !== pdLastFetchedSymbolsRef.current) {
          pdLastFetchedSymbolsRef.current = currentSymbolsKey;
          console.log('ðŸš€ Triggering Performance Dashboard fetch:', {
            symbols: pdSelectedSymbols,
            timeframe: pdTimeframe,
            count: pdSelectedSymbols.length
          });
          fetchPdPerformanceData();
        }
      }
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [activeTab, pdTimeframe, stableSymbols]);

    // Fetch data for Tracking tab
    useEffect(() => {
      if (activeTab === 'Tracking' && !trackingFetchedRef.current && !trackingLoading) {
        trackingFetchedRef.current = true;
        setTrackingLoading(true);

        const POLYGON_API_KEY = 'kjZ4aLJbqHsEhWGOjWMBthMvwDLKd4wf';

        const categories = {
          Markets: ['SPY', 'QQQ', 'IWM', 'DIA', 'GLD', 'TLT'],
          'Large Caps': ['NVDA', 'TSM', 'AVGO', 'AAPL', 'MSFT', 'AMZN', 'GOOGL', 'META', 'TSLA'],
          Value: ['JPM', 'BA', 'FCX', 'XOM', 'NKE', 'FDX', 'CAT', 'BAC', 'MS', 'DAL', 'UNH', 'LMT', 'MCD', 'WMT', 'DHI', 'HD', 'PANW', 'NFLX'],
          'High Beta': ['OKLO', 'CRWV', 'IONQ', 'QUBT', 'IREN', 'NBIS', 'HOOD', 'PLTR', 'HIMS', 'UPST', 'AFRM', 'TEM', 'CRCL', 'MSTR', 'COIN', 'XYZ', 'ARM', 'SHOP', 'DASH', 'UBER', 'ABNB', 'AMD', 'ROKU', 'RBLX'],
          China: ['PDD', 'FXI', 'JD', 'FUTU', 'BILI', 'BABA', 'NTES', 'KWEB', 'BIDU'],
          '11 Sectors': ['XLK', 'XLY', 'XLC', 'XLE', 'XLI', 'XLB', 'XLF', 'XLU', 'XLP', 'XLRE', 'XLV'],
          Industries: ['OIH', 'XME', 'GDX', 'JETS', 'PBW', 'KRE', 'KIE', 'FDN', 'IGV', 'XRT', 'SMH', 'ITB', 'XHB', 'IBB', 'XBI', 'TAN', 'XOP', 'ARKK']
        };

        const allSymbols = Object.values(categories).flat();

        const fetchAllData = async () => {
          try {
            // Get local date in YYYY-MM-DD format (same as PowerShell test)
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

            const startDate = new Date(today);
            startDate.setDate(startDate.getDate() - 10);
            const startDateStr = `${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}-${String(startDate.getDate()).padStart(2, '0')}`;

            const results: any = {};
            const BATCH_SIZE = 5; // Process 5 symbols at a time
            const DELAY_MS = 200; // 200ms delay between batches

            // Helper to delay execution
            const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

            // Helper to fetch single symbol
            const fetchSymbol = async (symbol: string) => {
              try {
                // 1D - Fetch last trading day's intraday data
                if (trackingTimeframe === '1D') {
                  // First get the last 3 daily bars to find the most recent trading day
                  const dailyUrl = `https://api.polygon.io/v2/aggs/ticker/${symbol}/range/1/day/${startDateStr}/${todayStr}?adjusted=true&sort=desc&limit=3&apiKey=${POLYGON_API_KEY}`;
                  const dailyResponse = await fetch(dailyUrl);
                  const dailyData = await dailyResponse.json();

                  if (!dailyData.results || dailyData.results.length < 2) {
                    return null;
                  }

                  // Most recent trading day is results[0], previous day is results[1]
                  const lastTradingDayTimestamp = dailyData.results[0].t;
                  const lastTradingDay = new Date(lastTradingDayTimestamp);
                  const lastTradingDayStr = `${lastTradingDay.getFullYear()}-${String(lastTradingDay.getMonth() + 1).padStart(2, '0')}-${String(lastTradingDay.getDate()).padStart(2, '0')}`;

                  // Fetch intraday data for the last trading day
                  const intradayUrl = `https://api.polygon.io/v2/aggs/ticker/${symbol}/range/1/minute/${lastTradingDayStr}/${lastTradingDayStr}?adjusted=true&sort=asc&limit=50000&apiKey=${POLYGON_API_KEY}`;
                  const intradayResponse = await fetch(intradayUrl);
                  const intradayData = await intradayResponse.json();

                  if (!intradayData.results || intradayData.results.length === 0) {
                    return null;
                  }

                  const intradayResults = intradayData.results;
                  const currentPrice = intradayResults[intradayResults.length - 1].c;
                  const previousDayClose = dailyData.results[1].c;
                  const changePercent = ((currentPrice - previousDayClose) / previousDayClose) * 100;

                  const sparklineData = intradayResults.map((bar: any) => ({
                    time: bar.t,
                    price: bar.c
                  }));

                  console.log(`âœ“ ${symbol}: Loaded ${sparklineData.length} 1-minute bars`);

                  return {
                    symbol,
                    data: {
                      symbol,
                      price: currentPrice,
                      change: changePercent,
                      sparklineData,
                      previousDayClose
                    }
                  };
                } else {
                  // 5D, 1M, 3M, 6M, 1Y - Use daily/hourly bars
                  let daysBack = 5;
                  let multiplier = 1;
                  let timespan = 'hour';

                  switch (trackingTimeframe) {
                    case '5D':
                      daysBack = 5;
                      multiplier = 30;
                      timespan = 'minute';
                      break;
                    case '1M':
                      daysBack = 30;
                      multiplier = 1;
                      timespan = 'hour';
                      break;
                    case '3M':
                      daysBack = 90;
                      multiplier = 1;
                      timespan = 'day';
                      break;
                    case '6M':
                      daysBack = 180;
                      multiplier = 1;
                      timespan = 'day';
                      break;
                    case '1Y':
                      daysBack = 365;
                      multiplier = 1;
                      timespan = 'day';
                      break;
                  }

                  const rangeStartDate = new Date(today);
                  rangeStartDate.setDate(rangeStartDate.getDate() - daysBack);
                  const rangeStartStr = `${rangeStartDate.getFullYear()}-${String(rangeStartDate.getMonth() + 1).padStart(2, '0')}-${String(rangeStartDate.getDate()).padStart(2, '0')}`;

                  const dataUrl = `https://api.polygon.io/v2/aggs/ticker/${symbol}/range/${multiplier}/${timespan}/${rangeStartStr}/${todayStr}?adjusted=true&sort=asc&limit=50000&apiKey=${POLYGON_API_KEY}`;

                  const dataResponse = await fetch(dataUrl);
                  const data = await dataResponse.json();

                  if (!data.results || data.results.length === 0) {
                    return null;
                  }

                  const results = data.results;
                  const currentPrice = results[results.length - 1].c;
                  const startPrice = results[0].c;
                  const changePercent = ((currentPrice - startPrice) / startPrice) * 100;

                  const sparklineData = results.map((bar: any) => ({
                    time: bar.t,
                    price: bar.c
                  }));

                  console.log(`âœ“ ${symbol}: Loaded ${sparklineData.length} ${timespan} bars for ${trackingTimeframe}`);

                  return {
                    symbol,
                    data: {
                      symbol,
                      price: currentPrice,
                      change: changePercent,
                      sparklineData,
                      previousDayClose: startPrice
                    }
                  };
                }
              } catch (error) {
                console.error(`Error fetching ${symbol}:`, error);
              }
              return null;
            };

            // Process symbols in batches
            for (let i = 0; i < allSymbols.length; i += BATCH_SIZE) {
              const batch = allSymbols.slice(i, i + BATCH_SIZE);
              const batchResults = await Promise.all(batch.map(fetchSymbol));

              // Add successful results to state
              batchResults.forEach(result => {
                if (result) {
                  results[result.symbol] = result.data;
                }
              });

              // Save scroll position before update
              const scrollPos = trackingScrollRef.current?.scrollTop || 0;

              // Update state with current batch
              setTrackingData(prev => ({ ...prev, ...results }));

              // Restore scroll position after React updates
              requestAnimationFrame(() => {
                if (trackingScrollRef.current) {
                  trackingScrollRef.current.scrollTop = scrollPos;
                }
              });

              // Delay before next batch (except for last batch)
              if (i + BATCH_SIZE < allSymbols.length) {
                await delay(DELAY_MS);
              }
            }

          } catch (error) {
            console.error('Error fetching tracking data:', error);
          } finally {
            setTrackingLoading(false);
          }
        };

        fetchAllData();
      }
    }, [activeTab, trackingLoading, trackingTimeframe]);

    // For Watchlist tab, show Markets symbols; otherwise use activeTab
    const symbolKey = activeTab === 'Watchlist' ? 'Markets' : activeTab;
    const currentSymbols = marketSymbols[symbolKey as keyof typeof marketSymbols] || [];

    // Create a unified symbol list with ALL symbols in ONE place for easy styling
    // MEMOIZE this to prevent re-creating the array on every render (which causes scroll jump)
    const allSymbols = useMemo(() => [
      ...currentSymbols.map((symbol, idx) => ({ symbol, section: 'markets', uniqueId: `markets-${idx}` })),
      { type: 'separator', label: 'INDUSTRIES', color: 'blue' },
      ...marketSymbols.Industries.map((symbol, idx) => ({ symbol, section: 'industries', uniqueId: `industries-${idx}` })),
      { type: 'separator', label: 'SPECIAL', color: 'purple' },
      ...marketSymbols.Special.map((symbol, idx) => ({ symbol, section: 'special', uniqueId: `special-${idx}` }))
    ], [currentSymbols, marketSymbols.Industries, marketSymbols.Special]);

    // Check if watchlist data is still loading
    const hasWatchlistData = Object.keys(watchlistData).length > 0;

    if (watchlistLoading || !hasWatchlistData) {
      // Show loading state instead of error
      return (
        <div className="bg-gray-900 border border-gray-700 rounded-lg p-4 h-96">
          <div className="flex items-center justify-center h-full">
            <div className="text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-400 mx-auto mb-2"></div>
              <p className="text-gray-400 text-sm">Loading market data...</p>

            </div>
          </div>
        </div>
      );
    }

    // Calculate regime score (0-100) based on strength and consistency
    const calculateRegimeScore = (regime: string, period: string) => {
      if (regime === 'MIXED') return 0;

      const periods = ['1d', '5d', '13d', '21d', '50d', 'ytd'];
      const growthSectors = ['XLY', 'XLK', 'XLC'];
      const defensiveSectors = ['XLP', 'XLU', 'XLRE', 'XLV'];
      const valueSectors = ['XLB', 'XLI', 'XLF', 'XLE'];

      const getChange = (symbol: string, per: string) => {
        const data = watchlistData[symbol];
        if (!data) return 0;
        if (per === '1d') return data.change1d;
        if (per === '5d') return data.change5d;
        if (per === '13d') return data.change13d;
        if (per === '21d') return data.change21d;
        if (per === '50d') return data.change50d;
        if (per === 'ytd') return data.changeYTD;
        return 0;
      };

      const spyChange = getChange('SPY', period);

      // Base score: 50 points for active regime
      let score = 50;

      // Calculate sector group averages
      const growthAvg = growthSectors.reduce((sum, s) => sum + getChange(s, period), 0) / growthSectors.length;
      const defensiveAvg = defensiveSectors.reduce((sum, s) => sum + getChange(s, period), 0) / defensiveSectors.length;
      const valueAvg = valueSectors.reduce((sum, s) => sum + getChange(s, period), 0) / valueSectors.length;

      const growthRelative = growthAvg - spyChange;
      const defensiveRelative = defensiveAvg - spyChange;
      const valueRelative = valueAvg - spyChange;

      // Divergence score (10 points): Strength of rotation
      let divergence = 0;
      if (regime === 'RISK ON') {
        divergence = Math.abs(growthRelative - defensiveRelative);
      } else if (regime === 'DEFENSIVE') {
        divergence = Math.abs(defensiveRelative - growthRelative);
      } else if (regime === 'VALUE') {
        divergence = (Math.abs(valueRelative - growthRelative) + Math.abs(valueRelative - defensiveRelative)) / 2;
      }
      score += Math.min((divergence / 2) * 10, 10);

      // Multi-timeframe score (20 points): How many periods show this regime
      const activeCount = periods.filter(per => getMarketRegimeForHeader(per) === regime).length;
      if (activeCount >= 4) score += 20;
      else if (activeCount === 3) score += 15;
      else if (activeCount === 2) score += 10;
      else if (activeCount === 1) score += 5;

      // Holdings consistency (20 points): Check individual sector strength
      let consistencyScore = 0;
      if (regime === 'RISK ON') {
        const growthStrength = growthSectors.filter(s => (getChange(s, period) - spyChange) > 0).length;
        consistencyScore = (growthStrength / 3) * 20;
      } else if (regime === 'DEFENSIVE') {
        const defensiveStrength = defensiveSectors.filter(s => (getChange(s, period) - spyChange) > 0).length;
        consistencyScore = (defensiveStrength / 4) * 20;
      } else if (regime === 'VALUE') {
        const valueStrength = valueSectors.filter(s => (getChange(s, period) - spyChange) > 0).length;
        consistencyScore = (valueStrength / 4) * 20;
      }
      score += consistencyScore;

      return Math.round(Math.min(score, 100));
    };

    // Helper function to get performance status for a specific time period
    const getPerformanceStatus = (symbolChange: number, spyChange: number, symbol: string, period: string) => {
      if (symbol === 'SPY') return { status: 'NEUTRAL', color: 'text-yellow-400' };

      // Calculate relative performance: ticker vs SPY from period start to today
      const relativePerformance = symbolChange - spyChange;

      // Determine status based on relative performance vs SPY
      if (period === '50d') {
        if (relativePerformance > 0) {
          return { status: 'SWEET', color: 'text-pink-400 font-bold glow-pink' }; // Outperformed SPY over 50 days
        } else {
          return { status: 'SOUR', color: 'text-purple-500 font-bold glow-purple' }; // Underperformed SPY over 50 days
        }
      } else if (period === '21d') {
        if (relativePerformance > 0) {
          return { status: 'KING', color: 'text-yellow-400 font-bold glow-yellow' }; // Outperformed SPY over 21 days
        } else {
          return { status: 'FALLEN', color: 'text-red-400 font-bold glow-red' }; // Underperformed SPY over 21 days
        }
      } else if (period === '13d') {
        if (relativePerformance > 0) {
          return { status: 'LEADER', color: 'text-green-400 font-bold glow-green' }; // Outperformed SPY over 13 days
        } else {
          return { status: 'LAGGARD', color: 'text-red-400 font-bold glow-red' }; // Underperformed SPY over 13 days
        }
      } else if (period === '5d') {
        if (relativePerformance > 0) {
          return { status: 'STRONG', color: 'text-green-400 font-bold' }; // Outperformed SPY over 5 days
        } else {
          return { status: 'WEAK', color: 'text-red-400 font-bold' }; // Underperformed SPY over 5 days
        }
      } else if (period === '1d') {
        if (relativePerformance > 0) {
          return { status: 'RISING', color: 'text-lime-400 font-bold' }; // Outperformed SPY today
        } else {
          return { status: 'FALLING', color: 'text-red-300 font-bold' }; // Underperformed SPY today
        }
      } else if (period === 'ytd') {
        if (relativePerformance > 0) {
          return { status: 'WINNER', color: 'text-emerald-500 font-bold' }; // Outperformed SPY YTD
        } else {
          return { status: 'LOSER', color: 'text-rose-500 font-bold' }; // Underperformed SPY YTD
        }
      }

      return { status: 'NEUTRAL', color: 'text-gray-400' };
    };

    // Helper function to calculate market regime for column headers only
    const getMarketRegimeForHeader = (period: string) => {
      // Growth sectors: XLY (Consumer Discretionary), XLK (Technology), XLC (Communication)
      const growthSectors = ['XLY', 'XLK', 'XLC'];
      // Defensive sectors: XLP (Consumer Staples), XLU (Utilities), XLRE (Real Estate), XLV (Healthcare)
      const defensiveSectors = ['XLP', 'XLU', 'XLRE', 'XLV'];

      // Get performance data for each sector vs SPY
      const growthPerformance = growthSectors.map(symbol => {
        const data = watchlistData[symbol];
        const spyData = watchlistData['SPY'];
        if (!data || !spyData) return null;

        let change = 0;
        let spyChange = 0;

        if (period === '1d') {
          change = data.change1d;
          spyChange = spyData.change1d;
        } else if (period === '5d') {
          change = data.change5d;
          spyChange = spyData.change5d;
        } else if (period === '13d') {
          change = data.change13d;
          spyChange = spyData.change13d;
        } else if (period === '21d') {
          change = data.change21d;
          spyChange = spyData.change21d;
        } else if (period === '50d') {
          change = data.change50d;
          spyChange = spyData.change50d;
        } else if (period === 'ytd') {
          change = data.changeYTD;
          spyChange = spyData.changeYTD;
        }

        return (change - spyChange) > 0; // true if outperforming SPY (rising relative to SPY)
      }).filter(result => result !== null);

      const defensivePerformance = defensiveSectors.map(symbol => {
        const data = watchlistData[symbol];
        const spyData = watchlistData['SPY'];
        if (!data || !spyData) return null;

        let change = 0;
        let spyChange = 0;

        if (period === '1d') {
          change = data.change1d;
          spyChange = spyData.change1d;
        } else if (period === '5d') {
          change = data.change5d;
          spyChange = spyData.change5d;
        } else if (period === '13d') {
          change = data.change13d;
          spyChange = spyData.change13d;
        } else if (period === '21d') {
          change = data.change21d;
          spyChange = spyData.change21d;
        } else if (period === '50d') {
          change = data.change50d;
          spyChange = spyData.change50d;
        } else if (period === 'ytd') {
          change = data.changeYTD;
          spyChange = spyData.changeYTD;
        }

        return (change - spyChange) > 0; // true if outperforming SPY (rising relative to SPY)
      }).filter(result => result !== null);

      // Count how many are rising
      const growthRising = growthPerformance.filter(Boolean).length;
      const defensiveFalling = defensivePerformance.filter(perf => !perf).length; // Count falling (underperforming)

      // RISK ON: All growth sectors rising AND most defensives falling
      if (growthRising === growthPerformance.length && defensiveFalling >= 3) {
        return 'RISK ON';
      }

      // DEFENSIVE: Growth sectors falling AND most defensives rising 
      const growthFalling = growthPerformance.filter(perf => !perf).length;
      const defensiveRising = defensivePerformance.filter(Boolean).length;

      if (growthFalling === growthPerformance.length && defensiveRising >= 3) {
        return 'DEFENSIVE';
      }

      // VALUE: All value sectors outperforming SPY (XLB, XLI, XLF, XLE)
      const valueSectors = ['XLB', 'XLI', 'XLF', 'XLE'];
      const valuePerformance = valueSectors.map(symbol => {
        const data = watchlistData[symbol];
        const spyData = watchlistData['SPY'];
        if (!data || !spyData) return null;

        let change = 0;
        let spyChange = 0;

        if (period === '1d') {
          change = data.change1d;
          spyChange = spyData.change1d;
        } else if (period === '5d') {
          change = data.change5d;
          spyChange = spyData.change5d;
        } else if (period === '13d') {
          change = data.change13d;
          spyChange = spyData.change13d;
        } else if (period === '21d') {
          change = data.change21d;
          spyChange = spyData.change21d;
        } else if (period === '50d') {
          change = data.change50d;
          spyChange = spyData.change50d;
        } else if (period === 'ytd') {
          change = data.changeYTD;
          spyChange = spyData.changeYTD;
        }

        return (change - spyChange) > 0;
      }).filter(result => result !== null);

      const valueRising = valuePerformance.filter(Boolean).length;

      if (valueRising === valuePerformance.length && valuePerformance.length === 4) {
        return 'VALUE';
      }

      // MIXED: Everything else
      return 'MIXED';
    };

    // Helper function to get group border styling
    const getGroupBorderStyle = (symbols: string[], startIndex: number, endIndex: number) => {
      if (startIndex === 0) {
        // Main indices group
        return 'border border-gray-300 rounded-md mb-2 p-1';
      } else if (startIndex === 4) {
        // Growth sectors group 
        return 'border border-green-600 rounded-md mb-2 p-1';
      } else if (startIndex === 7) {
        // Defensive sectors group
        return 'border border-red-600 rounded-md mb-2 p-1';
      } else if (startIndex === 11) {
        // Other sectors group
        return 'border border-blue-600 rounded-md mb-2 p-1';
      }
      return '';
    };

    return (
      <div className="h-full flex flex-col bg-black text-white">
        {/* Bloomberg-style Header */}
        <div className="p-3 border-b border-yellow-500 bg-black relative">
          {/* Close button - mobile and desktop */}
          <button
            onClick={() => setActiveSidebarPanel(null)}
            className="absolute top-3 right-3 text-gray-400 hover:text-white transition-colors z-50"
            aria-label="Close panel"
          >
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
          {/* Tab Navigation */}
          <div className="flex border-2 border-yellow-500/30 rounded-md overflow-hidden shadow-lg">
            {['Watchlist', 'Tracking', 'Options Trades'].map(tab => (
              <button
                key={tab}
                onClick={() => setActiveTab(tab)}
                className="md:text-[20px] text-[12px]"
                style={{
                  flex: 1,
                  padding: '12px 24px',
                  fontWeight: '900',
                  fontFamily: 'monospace',
                  letterSpacing: '1px',
                  textTransform: 'uppercase',
                  border: 'none',
                  borderRight: activeTab === tab ? 'none' : '1px solid #333',
                  cursor: 'pointer',
                  transition: 'all 0.3s',
                  background: 'linear-gradient(135deg, #1a1a1a 0%, #000000 50%, #1a1a1a 100%)',
                  color: activeTab === tab ? '#ff8844' : '#ffffff',
                  boxShadow: 'inset 0 2px 4px rgba(255, 255, 255, 0.1), inset 0 -2px 4px rgba(0, 0, 0, 0.5)',
                  opacity: 1,
                  filter: 'contrast(1.1) brightness(1.1)'
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.background = 'linear-gradient(135deg, #252525 0%, #0a0a0a 50%, #252525 100%)';
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.background = 'linear-gradient(135deg, #1a1a1a 0%, #000000 50%, #1a1a1a 100%)';
                }}
              >
                {tab}
              </button>
            ))}
          </div>
        </div>

        {/* Watchlist Tab Content */}
        {activeTab === 'Watchlist' && (
          <>
            {/* Enhanced Market Regime Display */}
            {Object.keys(regimeAnalysis).length > 0 && (
              <div style={{
                padding: '12px 16px',
                background: 'linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 10, 0.98) 100%)',
                borderBottom: '2px solid rgba(255, 102, 0, 0.3)',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                position: 'relative',
                zIndex: 100,
                overflow: 'hidden'
              }}>
                <EnhancedRegimeDisplay regimeAnalysis={regimeAnalysis} selectedPeriod="1d" watchlistData={watchlistData} />
              </div>
            )}

            {/* Bloomberg-style Column Headers - 9 Columns */}
            <div className="grid gap-0 border-b border-gray-700 bg-black md:text-sm text-[8px] font-bold uppercase shadow-inner" style={{ gridTemplateColumns: '1fr 1fr 0.8fr 1.2fr 1.2fr 1.2fr 1.2fr 1.2fr 1.2fr' }}>
              <div className="md:p-3 p-2 border-r border-gray-700 bg-black shadow-inner border-l-2 border-l-gray-600 border-t-2 border-t-gray-600 text-center">
                <span className="drop-shadow-lg text-shadow-carved text-orange-500 md:text-sm text-[10px]">Symbol</span>
              </div>
              <div className="md:p-3 p-2 border-r border-gray-700 bg-black shadow-inner border-t-2 border-t-gray-600 text-center">
                <span className="drop-shadow-lg text-shadow-carved text-orange-500 md:text-sm text-[10px]">Price</span>
              </div>
              <div className="md:p-3 p-2 border-r border-gray-700 bg-black shadow-inner border-t-2 border-t-gray-600 text-center">
                <span className="drop-shadow-lg text-shadow-carved text-orange-500 md:text-sm text-[10px]">Change</span>
              </div>
              <div className="md:p-3 p-2 border-r border-gray-700 text-center bg-black shadow-inner border-t-2 border-t-gray-600">
                <span className="text-white font-bold text-xs">TODAY</span>
              </div>
              <div className="p-3 border-r border-gray-700 text-center bg-black shadow-inner border-t-2 border-t-gray-600">
                <span className="text-white font-bold text-xs">WEEK</span>
              </div>
              <div className="p-3 border-r border-gray-700 text-center bg-black shadow-inner border-t-2 border-t-gray-600">
                <span className="text-white font-bold text-xs">13D</span>
              </div>
              <div className="p-3 border-r border-gray-700 text-center bg-black shadow-inner border-t-2 border-t-gray-600">
                <span className="text-white font-bold md:text-xs text-[10.8px]">MONTH</span>
              </div>
              <div className="p-3 border-r border-gray-700 text-center bg-black shadow-inner border-t-2 border-t-gray-600">
                <span className="text-white font-bold md:text-xs text-[9.7px]">QUARTER</span>
              </div>
              <div className="p-3 text-center bg-black shadow-inner border-t-2 border-t-gray-600 border-r-2 border-r-gray-600">
                <span className="text-white font-bold text-xs">YTD</span>
              </div>
            </div>

            {/* Bloomberg-style Content */}
            <div
              ref={watchlistScrollRef}
              onScroll={handleScroll}
              className="flex-1 overflow-y-auto bg-black"
              style={{
                overflowAnchor: 'none',
                scrollBehavior: 'auto',
                contain: 'layout'
              }}
            >
              {allSymbols.length === 0 ? (
                <div className="flex flex-col items-center justify-center h-full text-gray-500">
                  <div className="text-lg font-bold mb-2">NO DATA</div>
                  <div className="text-sm">No symbols available</div>
                </div>
              ) : (
                <div className="divide-y divide-gray-800">
                  {allSymbols.map((item, index) => {
                    // Handle separator rows
                    if (typeof item === 'object' && 'type' in item && item.type === 'separator') {
                      const colorMap = {
                        blue: { via: 'via-blue-500', text: 'text-blue-400', shadow: 'rgba(59, 130, 246, 0.6)' },
                        purple: { via: 'via-purple-500', text: 'text-purple-400', shadow: 'rgba(168, 85, 247, 0.6)' }
                      };
                      const colors = colorMap[item.color as keyof typeof colorMap];

                      return (
                        <div key={`separator-${item.label}`} className="my-4 px-2">
                          <div className="relative h-12 bg-gradient-to-r from-transparent via-[#FF6600]/20 to-transparent border-y border-[#FF6600]/40">
                            <div className="absolute inset-0 flex items-center justify-center">
                              <span className={`px-8 py-2 bg-black/95 ${colors.text} text-base font-black tracking-[0.3em] uppercase border border-[#FF6600]/50 rounded shadow-[0_0_20px_rgba(255,102,0,0.4)]`}>
                                â˜… {item.label}
                              </span>
                            </div>
                          </div>
                        </div>
                      );
                    }

                    // Handle symbol rows
                    const symbol = 'symbol' in item ? item.symbol : '';
                    const section = 'section' in item ? item.section : '';
                    const uniqueId = 'uniqueId' in item ? item.uniqueId : `${section}-${symbol}`;
                    const data = watchlistData[symbol];
                    const spyData = watchlistData['SPY'];
                    const isLoading = !data;

                    // Add separator rows between categories (for currentSymbols only)
                    const separatorRows = [];

                    // Add category separators with professional styling
                    if (symbol === 'XLK') {
                      separatorRows.push(
                        <div key="growth-separator" className="h-2 bg-gradient-to-r from-transparent via-emerald-500/30 to-transparent my-3 rounded-full"></div>
                      );
                    }

                    if (symbol === 'XLRE') {
                      separatorRows.push(
                        <div key="defensive-separator" className="h-2 bg-gradient-to-r from-transparent via-rose-500/30 to-transparent my-3 rounded-full"></div>
                      );
                    }

                    if (symbol === 'XLB') {
                      separatorRows.push(
                        <div key="other-separator" className="h-2 bg-gradient-to-r from-transparent via-blue-500/30 to-transparent my-3 rounded-full"></div>
                      );
                    } if (isLoading) {
                      return (
                        <div key={uniqueId}>
                          {separatorRows}
                          <div className="grid grid-cols-9 gap-px bg-gradient-to-r from-gray-900 via-black to-gray-900">
                            <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] p-3 border-b border-gray-900/50">
                              <span className="font-mono font-bold text-white text-sm">{symbol}</span>
                            </div>
                            <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] p-3 border-b border-gray-900/50">
                              <div className="h-4 w-16 bg-gray-800/50 rounded animate-pulse"></div>
                            </div>
                            <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] p-3 border-b border-gray-900/50">
                              <div className="h-4 w-12 bg-gray-800/50 rounded animate-pulse"></div>
                            </div>
                            <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] p-3 text-center border-b border-gray-900/50">
                              <div className="h-4 w-20 bg-gray-800/50 rounded animate-pulse mx-auto"></div>
                            </div>
                            <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] p-3 text-center border-b border-gray-900/50">
                              <div className="h-4 w-20 bg-gray-800/50 rounded animate-pulse mx-auto"></div>
                            </div>
                            <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] p-3 text-center border-b border-gray-900/50">
                              <div className="h-4 w-20 bg-gray-800/50 rounded animate-pulse mx-auto"></div>
                            </div>
                            <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] p-3 text-center border-b border-gray-900/50">
                              <div className="h-4 w-20 bg-gray-800/50 rounded animate-pulse mx-auto"></div>
                            </div>
                            <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] p-3 text-center border-b border-gray-900/50">
                              <div className="h-4 w-20 bg-gray-800/50 rounded animate-pulse mx-auto"></div>
                            </div>
                            <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] p-3 text-center border-b border-gray-900/50">
                              <div className="h-4 w-20 bg-gray-800/50 rounded animate-pulse mx-auto"></div>
                            </div>
                          </div>
                        </div>
                      );
                    } const changeColor = data.change1d >= 0 ? 'text-emerald-400' : 'text-rose-400';
                    const changeSign = data.change1d >= 0 ? '+' : '';

                    // Get performance status for each time period vs SPY
                    const perf1d = spyData ? getPerformanceStatus(data.change1d, spyData.change1d, symbol, '1d') : { status: '--', color: 'text-gray-400' };
                    const perf5d = spyData ? getPerformanceStatus(data.change5d, spyData.change5d, symbol, '5d') : { status: '--', color: 'text-gray-400' };
                    const perf13d = spyData ? getPerformanceStatus(data.change13d, spyData.change13d, symbol, '13d') : { status: '--', color: 'text-gray-400' };
                    const perf21d = spyData ? getPerformanceStatus(data.change21d, spyData.change21d, symbol, '21d') : { status: '--', color: 'text-gray-400' };
                    const perf50d = spyData ? getPerformanceStatus(data.change50d, spyData.change50d, symbol, '50d') : { status: '--', color: 'text-gray-400' };
                    const perfYTD = spyData ? getPerformanceStatus(data.changeYTD, spyData.changeYTD, symbol, 'ytd') : { status: '--', color: 'text-gray-400' };

                    return (
                      <div key={uniqueId}>
                        {separatorRows}
                        <div
                          className="grid gap-px bg-gradient-to-r from-gray-900 via-black to-gray-900 hover:bg-[#FF6600]/5 transition-all duration-200 cursor-pointer group"
                          style={{ gridTemplateColumns: '1fr 1fr 0.8fr 1.2fr 1.2fr 1.2fr 1.2fr 1.2fr 1.2fr' }}
                          title={(() => {
                            const excludedSymbols = ['SPY', 'IWM', 'QQQ', 'DIA'];
                            const isClickableETF = !excludedSymbols.includes(symbol);
                            if (isClickableETF) {
                              return `Click to view ${symbol} holdings â€¢ Ctrl+Click to switch chart`;
                            }
                            return `Click to switch chart to ${symbol}`;
                          })()}
                          onClick={(e) => {
                            // Exclude SPY, IWM, QQQ, DIA from ETF holdings modal
                            const excludedSymbols = ['SPY', 'IWM', 'QQQ', 'DIA'];
                            const isClickableETF = !excludedSymbols.includes(symbol);

                            // If Ctrl/Cmd key is pressed or it's an excluded symbol, switch chart
                            if (e.ctrlKey || e.metaKey || !isClickableETF) {
                              if (onSymbolChange) {
                                onSymbolChange(symbol);
                              }
                              setConfig(prev => ({ ...prev, symbol }));
                            } else {
                              // Show ETF holdings modal
                              const name = tickerNames[symbol] || symbol;
                              setSelectedETF({ symbol, name });
                            }
                          }}
                        >
                          {/* Symbol */}
                          <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] p-2 md:p-3 border-b border-gray-900/50 group-hover:bg-gradient-to-br group-hover:from-[#1a1a1a] group-hover:to-[#0a0a0a] transition-all">
                            <div className="flex flex-col items-center">
                              <span className="font-mono font-bold text-[#FF6600] md:text-base text-[14px] tracking-wide">{symbol}</span>
                              <span className="font-sans text-white md:text-xs text-[10px] mt-0.5 md:block hidden">{tickerNames[symbol] || symbol}</span>
                            </div>
                          </div>

                          {/* Price */}
                          <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] p-2 md:p-3 border-b border-gray-900/50 group-hover:bg-gradient-to-br group-hover:from-[#1a1a1a] group-hover:to-[#0a0a0a] transition-all text-center">
                            <div className="font-mono text-white font-bold md:text-base text-[12px]">
                              ${data.price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                            </div>
                          </div>

                          {/* Change */}
                          <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] p-2 md:p-3 border-b border-gray-900/50 group-hover:bg-gradient-to-br group-hover:from-[#1a1a1a] group-hover:to-[#0a0a0a] transition-all text-center">
                            <div className={`font-mono font-bold md:text-base text-[12px] ${changeColor}`}>
                              {changeSign}{data.change1d.toFixed(2)}%
                            </div>
                          </div>

                          {/* 1D Performance */}
                          <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] md:p-3 p-2 flex items-center justify-center gap-1 border-b border-gray-900/50 group-hover:bg-gradient-to-br group-hover:from-[#1a1a1a] group-hover:to-[#0a0a0a] transition-all" style={{ whiteSpace: 'nowrap' }}>
                            <span className={`font-bold md:text-base text-[8px] uppercase tracking-widest ${perf1d.color}`}>
                              {perf1d.status}
                            </span>
                          </div>

                          {/* 5D Performance */}
                          <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] md:p-3 p-2 flex items-center justify-center gap-1 border-b border-gray-900/50 group-hover:bg-gradient-to-br group-hover:from-[#1a1a1a] group-hover:to-[#0a0a0a] transition-all" style={{ whiteSpace: 'nowrap' }}>
                            <span className={`font-bold md:text-base text-[8px] uppercase tracking-widest ${perf5d.color}`}>
                              {perf5d.status}
                            </span>
                          </div>

                          {/* 13D Performance */}
                          <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] md:p-3 p-2 flex items-center justify-center gap-1 border-b border-gray-900/50 group-hover:bg-gradient-to-br group-hover:from-[#1a1a1a] group-hover:to-[#0a0a0a] transition-all" style={{ whiteSpace: 'nowrap' }}>
                            <span className={`font-bold md:text-base text-[8px] uppercase tracking-widest ${perf13d.color}`}>
                              {perf13d.status}
                            </span>
                          </div>

                          {/* 21D Performance */}
                          <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] md:p-3 p-2 flex items-center justify-center gap-1 border-b border-gray-900/50 group-hover:bg-gradient-to-br group-hover:from-[#1a1a1a] group-hover:to-[#0a0a0a] transition-all" style={{ whiteSpace: 'nowrap' }}>
                            <span className={`font-bold md:text-base text-[8px] uppercase tracking-widest ${perf21d.color}`}>
                              {perf21d.status}
                            </span>
                          </div>

                          {/* 50D Performance */}
                          <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] md:p-3 p-2 flex items-center justify-center gap-1 border-b border-gray-900/50 group-hover:bg-gradient-to-br group-hover:from-[#1a1a1a] group-hover:to-[#0a0a0a] transition-all" style={{ whiteSpace: 'nowrap' }}>
                            <span className={`font-bold md:text-base text-[8px] uppercase tracking-widest ${perf50d.color}`}>
                              {perf50d.status}
                            </span>
                          </div>

                          {/* YTD Performance */}
                          <div className="bg-gradient-to-br from-[#0d0d0d] to-[#050505] md:p-3 p-2 flex items-center justify-center gap-1 border-b border-gray-900/50 group-hover:bg-gradient-to-br group-hover:from-[#1a1a1a] group-hover:to-[#0a0a0a] transition-all" style={{ whiteSpace: 'nowrap' }}>
                            <span className={`font-bold md:text-base text-[8px] uppercase tracking-widest ${perfYTD.color}`}>
                              {perfYTD.status}
                            </span>
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          </>
        )}

        {/* Tracking Tab Content */}
        {activeTab === 'Tracking' && (
          <div className="flex-1 flex flex-col overflow-hidden bg-black">
            {/* Timeframe Selector */}
            <div className="px-6 pt-6 pb-4 border-b border-gray-800">
              <div className="flex items-center gap-2">
                {(['1D', '5D', '1M', '3M', '6M', '1Y'] as const).map((tf) => (
                  <button
                    key={tf}
                    onClick={() => {
                      setTrackingTimeframe(tf);
                      trackingFetchedRef.current = false;
                      setTrackingData({});
                    }}
                    className={`px-5 py-2.5 text-sm font-bold rounded-md transition-all border ${trackingTimeframe === tf
                      ? 'bg-[#0a0e1a] text-[#FF6600] border-[#FF6600] shadow-lg shadow-[#FF6600]/20'
                      : 'bg-[#0a0e1a] text-white border-gray-700 hover:border-gray-500 hover:shadow-md'
                      }`}
                  >
                    {tf}
                  </button>
                ))}
              </div>
            </div>

            {trackingLoading ? (
              <div className="flex items-center justify-center h-64">
                <div className="text-center">
                  <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-[#FF6600] mx-auto mb-4"></div>
                  <p className="text-gray-400 text-sm">Loading market data...</p>
                </div>
              </div>
            ) : (
              <div
                ref={trackingScrollRef}
                className="flex-1 overflow-y-scroll p-6 space-y-8"
                style={{
                  overflowAnchor: 'none',
                  scrollbarWidth: 'thin',
                  scrollbarColor: '#FF6600 #1a1a1a'
                }}
              >
                {trackingCategories.map((category) => (
                  <div key={category.title} className="relative">
                    {/* Category Header - Goldman Sachs Style */}
                    <div
                      className="mb-4 pb-3 border-b-2 relative overflow-hidden"
                      style={{
                        borderColor: category.color,
                        background: `linear-gradient(90deg, ${category.color}30 0%, ${category.color}10 50%, ${category.color}30 100%)`
                      }}
                    >
                      <div className="flex items-center justify-center gap-3 py-2">
                        <div className="flex-1 h-px bg-gradient-to-r from-transparent to-gray-700" />
                        <div
                          className="w-1 h-6 rounded-full"
                          style={{ background: category.color }}
                        />
                        <h2
                          className="text-xl font-black uppercase tracking-wider px-4"
                          style={{
                            color: '#ffffff',
                            textShadow: `0 0 20px ${category.color}80, 2px 2px 4px rgba(0,0,0,0.8)`,
                            fontFamily: 'system-ui, -apple-system, sans-serif'
                          }}
                        >
                          {category.title}
                        </h2>
                        <div
                          className="w-1 h-6 rounded-full"
                          style={{ background: category.color }}
                        />
                        <div className="flex-1 h-px bg-gradient-to-l from-transparent to-gray-700" />
                        <span className="text-xs text-gray-500 font-mono">
                          {category.symbols.length} {category.symbols.length === 1 ? 'Symbol' : 'Symbols'}
                        </span>
                      </div>
                    </div>

                    {/* Cards Grid */}
                    <div className="grid md:grid-cols-2 lg:grid-cols-3 grid-cols-3 gap-2">
                      {category.symbols.map((symbol) => {
                        const data = trackingData[symbol];
                        if (!data) return null;

                        return (
                          <div
                            key={symbol}
                            className="group relative overflow-hidden rounded-lg transition-all duration-300 hover:scale-[1.02] cursor-pointer"
                            style={{
                              background: 'linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%)',
                              border: `1px solid ${category.color}40`,
                              boxShadow: `0 4px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.03)`
                            }}
                            onClick={() => {
                              if (onSymbolChange) {
                                onSymbolChange(data.symbol);
                              }
                              setConfig(prev => ({ ...prev, symbol: data.symbol }));
                            }}
                          >
                            {/* Hover glow effect */}
                            <div
                              className="absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none"
                              style={{
                                background: `radial-gradient(circle at center, ${category.color}20 0%, transparent 70%)`
                              }}
                            />

                            <div className="relative md:p-6 p-2">
                              <div className="md:flex md:items-center md:justify-between md:gap-4">
                                {/* Left: Ticker and Price (all horizontal on mobile) */}
                                <div className="md:flex-shrink-0 md:w-20">
                                  {/* Desktop layout */}
                                  <div className="hidden md:block font-black text-white text-base tracking-tight">
                                    {data.symbol}
                                  </div>
                                  {/* Mobile layout - all in one row */}
                                  <div className="md:hidden flex flex-col items-start gap-0.5">
                                    <div className="font-black text-white text-[10px] tracking-tight">
                                      {data.symbol}
                                    </div>
                                    <div className="font-bold text-white text-[9px]">
                                      ${data.price.toFixed(2)}
                                    </div>
                                    <div className={`text-[8px] font-bold ${data.change >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                      {data.change >= 0 ? '+' : ''}{data.change.toFixed(2)}%
                                    </div>
                                  </div>
                                </div>

                                {/* Center: Sparkline */}
                                <div className="md:flex-1 flex flex-col mt-2 md:mt-0">
                                  <svg
                                    viewBox="0 0 200 50"
                                    preserveAspectRatio="none"
                                    className="w-full md:h-16 h-8"
                                  >
                                    {data.sparklineData.length > 1 && (() => {
                                      const prices = data.sparklineData.map(p => p.price);
                                      const minPrice = Math.min(...prices);
                                      const maxPrice = Math.max(...prices);
                                      const priceRange = maxPrice - minPrice || 1;
                                      const padding = 8;
                                      const chartHeight = 50 - (padding * 2);

                                      const points = data.sparklineData.map((point, i) => {
                                        const x = (i / (data.sparklineData.length - 1)) * 200;
                                        const y = padding + ((maxPrice - point.price) / priceRange) * chartHeight;
                                        return `${x.toFixed(1)},${y.toFixed(1)}`;
                                      }).join(' ');

                                      const prevDayY = data.previousDayClose
                                        ? padding + ((maxPrice - data.previousDayClose) / priceRange) * chartHeight
                                        : null;

                                      return (
                                        <>
                                          {/* Previous day close line */}
                                          {prevDayY !== null && (
                                            <line
                                              x1="0"
                                              y1={prevDayY.toFixed(1)}
                                              x2="200"
                                              y2={prevDayY.toFixed(1)}
                                              stroke="#444444"
                                              strokeWidth="1"
                                              strokeDasharray="3,2"
                                              opacity="0.4"
                                              vectorEffect="non-scaling-stroke"
                                            />
                                          )}

                                          {/* Price line */}
                                          <polyline
                                            fill="none"
                                            stroke={data.change >= 0 ? '#00ff00' : '#ff0000'}
                                            strokeWidth="1.5"
                                            points={points}
                                            strokeLinecap="round"
                                            strokeLinejoin="round"
                                            vectorEffect="non-scaling-stroke"
                                          />
                                        </>
                                      );
                                    })()}
                                  </svg>

                                  {/* X-Axis Time Labels */}
                                  <div className="flex justify-between mt-2 px-1">
                                    {data.sparklineData.length > 0 && (() => {
                                      const firstPoint = data.sparklineData[0];
                                      const lastPoint = data.sparklineData[data.sparklineData.length - 1];

                                      if (trackingTimeframe === '1D') {
                                        const formatTime = (timestamp: number) => {
                                          const date = new Date(timestamp);
                                          return date.toLocaleTimeString('en-US', {
                                            hour: 'numeric',
                                            minute: '2-digit',
                                            hour12: true,
                                            timeZone: 'America/New_York'
                                          });
                                        };

                                        return (
                                          <>
                                            <span className="md:text-[10px] text-[8px] text-yellow-400 font-mono font-semibold">{formatTime(firstPoint.time)}</span>
                                            <span className="md:text-[10px] text-[8px] text-yellow-400 font-mono font-semibold">{formatTime(lastPoint.time)}</span>
                                          </>
                                        );
                                      } else {
                                        const formatDate = (timestamp: number) => {
                                          const date = new Date(timestamp);
                                          return date.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', timeZone: 'America/New_York' });
                                        };

                                        return (
                                          <>
                                            <span className="md:text-[10px] text-[8px] text-yellow-400 font-mono font-semibold">{formatDate(firstPoint.time)}</span>
                                            <span className="md:text-[10px] text-[8px] text-yellow-400 font-mono font-semibold">{formatDate(lastPoint.time)}</span>
                                          </>
                                        );
                                      }
                                    })()}
                                  </div>
                                </div>

                                {/* Right: Price and Change - desktop only */}
                                <div className="hidden md:block flex-shrink-0 text-right w-20">
                                  <div className="font-bold text-white text-sm">
                                    ${data.price.toFixed(2)}
                                  </div>
                                  <div className={`text-xs font-bold ${data.change >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                    {data.change >= 0 ? '+' : ''}{data.change.toFixed(2)}%
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

        {/* Options Trades Tab Content */}
        {activeTab === 'Options Trades' && (
          <div className="flex-1 overflow-y-auto bg-black p-6" style={{ display: 'block' }}>
            {(() => {
              const saved = localStorage.getItem('optionsWatchlist');
              const optionsWatchlist: any[] = saved ? JSON.parse(saved) : [];

              if (optionsWatchlist.length === 0) {
                return (
                  <div className="flex items-center justify-center h-64">
                    <div className="text-center">
                      <div className="text-gray-500 text-lg mb-2">No Options Tracked</div>
                      <div className="text-gray-600 text-sm">Add options from the Options Chain panel</div>
                    </div>
                  </div>
                );
              }

              return (
                <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '16px', width: '100%' }}>
                  {optionsWatchlist.map((option) => {
                    // Use live quotes if available, otherwise fall back to stored bid/ask
                    const liveQuote = liveOptionQuotes[option.id];
                    const currentBid = liveQuote?.bid ?? option.bid;
                    const currentAsk = liveQuote?.ask ?? option.ask;
                    const currentPrice = (currentBid + currentAsk) / 2;
                    const entryPrice = option.entryPrice || currentPrice;
                    const pnlPercent = ((currentPrice - entryPrice) / entryPrice) * 100;
                    const pnlDollars = (currentPrice - entryPrice) * 100; // Per contract

                    // Use live Greeks from Polygon API
                    const liveGreeks = {
                      delta: liveQuote?.delta ?? option.delta ?? 0,
                      gamma: liveQuote?.gamma ?? 0,
                      theta: liveQuote?.theta ?? 0,
                      vega: liveQuote?.vega ?? 0
                    };

                    // Use live IV from Polygon API only (no fallback to saved value)
                    const impliedVolatility = liveQuote?.implied_volatility ?? 0;

                    // Get premium data for this option
                    const optionPremiumData = optionsPremiumData[option.id] || [];
                    const stockData = stockChartData[option.id] || [];

                    // Calculate 80% and 90% probability targets using Black-Scholes
                    const expiryDate = new Date(option.expiration);
                    const now = new Date();
                    const daysToExpiry = Math.max(1, Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));
                    const T = daysToExpiry / 365;
                    const r = 0.0387; // Risk-free rate
                    const sigma = impliedVolatility;
                    let stockPrice = option.stockPrice || 0;
                    if (!stockPrice || stockPrice === 0) {
                      stockPrice = option.strike;
                    }

                    const isCall = option.type === 'call';
                    const intrinsicValue = Math.max(0, isCall ? stockPrice - option.strike : option.strike - stockPrice);
                    const extrinsicValue = currentPrice - intrinsicValue;

                    // Black-Scholes helpers
                    const normalCDF = (x: number): number => {
                      const erf = (x: number): number => {
                        const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
                        const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
                        const sign = x >= 0 ? 1 : -1;
                        x = Math.abs(x);
                        const t = 1.0 / (1.0 + p * x);
                        const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
                        return sign * y;
                      };
                      return 0.5 * (1 + erf(x / Math.sqrt(2)));
                    };

                    const calculateBSPrice = (S: number, K: number, T: number, r: number, sigma: number, isCall: boolean): number => {
                      if (T <= 0) return isCall ? Math.max(0, S - K) : Math.max(0, K - S);
                      const d1 = (Math.log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
                      const d2 = d1 - sigma * Math.sqrt(T);
                      if (isCall) {
                        return S * normalCDF(d1) - K * Math.exp(-r * T) * normalCDF(d2);
                      } else {
                        return K * Math.exp(-r * T) * normalCDF(-d2) - S * normalCDF(-d1);
                      }
                    };

                    // Calculate stock price targets (expected move based)
                    let target80StockPrice = 0;
                    let target90StockPrice = 0;

                    if (isCall) {
                      // For calls: calculate upside targets
                      const expectedMove1SD = stockPrice * sigma * Math.sqrt(T);
                      target80StockPrice = stockPrice + (expectedMove1SD * 0.84); // ~80% probability
                      target90StockPrice = stockPrice + (expectedMove1SD * 1.28); // ~90% probability
                    } else {
                      // For puts: calculate downside targets  
                      const expectedMove1SD = stockPrice * sigma * Math.sqrt(T);
                      target80StockPrice = stockPrice - (expectedMove1SD * 0.84); // ~80% probability
                      target90StockPrice = stockPrice - (expectedMove1SD * 1.28); // ~90% probability
                    }

                    // Calculate what the option will be worth at those stock prices
                    const target80OptionValue = T > 0 && sigma > 0
                      ? calculateBSPrice(target80StockPrice, option.strike, T, r, sigma, isCall)
                      : 0;
                    const target90OptionValue = T > 0 && sigma > 0
                      ? calculateBSPrice(target90StockPrice, option.strike, T, r, sigma, isCall)
                      : 0;

                    // Dynamic trailing stop loss calculation
                    const calculateDynamicStopLoss = () => {
                      const delta = Math.abs(liveGreeks.delta);
                      const iv = impliedVolatility || 0.5;

                      // 1. Base stop distance from delta (moneyness)
                      // This is the % below current price to place the stop
                      let baseStopPercent = 0.30; // Default 30% from current
                      if (delta > 0.70) {
                        baseStopPercent = 0.15; // Deep ITM: tighter 15% stop
                      } else if (delta >= 0.60) {
                        baseStopPercent = 0.20; // ITM: 20% stop
                      } else if (delta >= 0.40) {
                        baseStopPercent = 0.25; // ATM: 25% stop
                      } else if (delta >= 0.25) {
                        baseStopPercent = 0.35; // OTM: 35% stop
                      } else {
                        baseStopPercent = 0.40; // Deep OTM: 40% stop
                      }

                      // 2. Adjust for time decay (tighter stops near expiration)
                      if (daysToExpiry < 7) {
                        baseStopPercent = Math.max(0.10, baseStopPercent - 0.10); // Tighten significantly
                      } else if (daysToExpiry < 14) {
                        baseStopPercent = Math.max(0.15, baseStopPercent - 0.05); // Tighten moderately
                      }

                      // 3. Adjust for volatility (ATR and IV)
                      const atr = stockATR[option.symbol];
                      if (atr && stockPrice > 0) {
                        const atrPercent = (atr / stockPrice) * 100;
                        if (atrPercent > 5) {
                          baseStopPercent += 0.05; // High volatility: wider stop
                        } else if (atrPercent < 2) {
                          baseStopPercent -= 0.05; // Low volatility: tighter stop
                        }
                      }

                      // Adjust for IV rank (high IV = wider stops)
                      if (iv > 0.8) {
                        baseStopPercent += 0.05; // Very high IV: wider stop
                      } else if (iv < 0.3) {
                        baseStopPercent -= 0.03; // Low IV: tighter stop
                      }

                      // Cap the stop percent between 10% and 45%
                      baseStopPercent = Math.max(0.10, Math.min(0.45, baseStopPercent));

                      // Calculate stop from CURRENT price
                      const stopFromCurrent = currentPrice * (1 - baseStopPercent);

                      // If we're in profit, use trailing logic to lock in gains
                      if (currentPrice > entryPrice) {
                        // Get peak price
                        const peakPrice = optionPeakPrices[option.id] || currentPrice;

                        // Trail from peak, but never go below entry (protect profits)
                        const trailedStop = peakPrice * (1 - baseStopPercent);
                        const protectedStop = Math.max(entryPrice * 0.95, trailedStop);

                        // Use the higher of: stop from current OR protected trailing stop
                        return Math.max(stopFromCurrent, protectedStop);
                      }

                      // If at or below entry, just use calculated stop from current
                      return Math.max(0.05, stopFromCurrent);
                    };

                    const stopLoss = calculateDynamicStopLoss();

                    // Theta decay per day (use live Greeks)
                    const thetaDecay = Math.abs(liveGreeks.theta || 0);
                    const dailyDecay = (thetaDecay / currentPrice) * 100;

                    return (
                      <div
                        key={option.id}
                        className="relative overflow-hidden rounded border"
                        style={{
                          background: '#000000',
                          borderColor: pnlPercent >= 0 ? '#22c55e30' : '#ef444430',
                          boxShadow: 'inset 0 1px 0 rgba(255,255,255,0.03), 0 2px 8px rgba(0,0,0,0.7)',
                          width: '100%'
                        }}
                      >
                        {/* Remove Trade Button */}
                        <button
                          onClick={() => {
                            const saved = localStorage.getItem('optionsWatchlist');
                            const optionsWatchlist: any[] = saved ? JSON.parse(saved) : [];
                            const updated = optionsWatchlist.filter(opt => opt.id !== option.id);
                            localStorage.setItem('optionsWatchlist', JSON.stringify(updated));
                            setOptionsWatchlistUpdate(prev => prev + 1);
                          }}
                          className="absolute top-2 right-2 z-10 w-6 h-6 flex items-center justify-center rounded bg-red-500/20 hover:bg-red-500 text-red-500 hover:text-white transition-all"
                          style={{ fontSize: '14px', fontWeight: 'bold' }}
                        >
                          Ã—
                        </button>
                        {/* Main layout: Left content + Right charts */}
                        <div className="md:flex md:gap-3 md:p-2 p-2">
                          {/* Mobile: Info + Trade Management side by side */}
                          <div className="md:hidden grid grid-cols-2 gap-2 mb-3">
                            {/* Left column: Info on mobile */}
                            <div className="flex flex-col" style={{ background: '#000000' }}>
                              {/* Header - Ticker & Status */}
                              <div style={{ background: '#000000', borderBottom: '1px solid #1a1a1a' }} className="px-2 py-1.5">
                                <div className="flex flex-col gap-1">
                                  <div className="flex items-center justify-between">
                                    <div className="flex items-center gap-1.5">
                                      <div className="text-lg font-bold tracking-tight" style={{ color: '#fff', fontFamily: 'monospace' }}>{option.symbol}</div>
                                      <div className={`px-1 py-0.5 text-[8px] font-bold tracking-wider ${option.type === 'call' ? 'bg-green-500 text-black' : 'bg-red-500 text-white'}`} style={{ fontFamily: 'monospace' }}>
                                        {option.type.toUpperCase()}
                                      </div>
                                    </div>
                                    <button
                                      onClick={() => setOptionChartsVisible(prev => ({ ...prev, [option.id]: !prev[option.id] }))}
                                      className="px-1.5 py-0.5 text-[9px] font-bold tracking-wider rounded"
                                      style={{
                                        background: optionChartsVisible[option.id] ? '#1a4d2e' : '#1a1a1a',
                                        color: optionChartsVisible[option.id] ? '#00ff88' : '#666',
                                        border: `1px solid ${optionChartsVisible[option.id] ? '#00ff88' : '#333'}`,
                                        fontFamily: 'monospace'
                                      }}
                                    >
                                      {optionChartsVisible[option.id] ? 'ðŸ“Š' : 'ðŸ“ˆ'}
                                    </button>
                                  </div>
                                  <div className="flex items-baseline gap-1.5">
                                    <span className="text-[8px] tracking-wider" style={{ color: '#ff9500', fontFamily: 'monospace' }}>MARK</span>
                                    <span className="text-sm font-bold" style={{ color: '#fff', fontFamily: 'monospace' }}>${currentPrice.toFixed(2)}</span>
                                    <span className={`text-[10px] font-bold ${pnlPercent >= 0 ? 'text-green-400' : 'text-red-400'}`} style={{ fontFamily: 'monospace' }}>
                                      {pnlPercent >= 0 ? '+' : ''}{pnlPercent.toFixed(1)}% {pnlPercent >= 0 ? 'â–²' : 'â–¼'}
                                    </span>
                                  </div>
                                </div>
                                <div className="flex items-center gap-2 text-[9px] mt-1" style={{ fontFamily: 'monospace' }}>
                                  <span style={{ color: '#ff9500' }}>STRIKE</span>
                                  <span style={{ color: '#fff', fontWeight: 'bold' }}>${option.strike}</span>
                                  <span style={{ color: '#444' }}>|</span>
                                  <span style={{ color: '#ff9500' }}>EXP</span>
                                  <span style={{ color: '#fff', fontWeight: 'bold' }}>
                                    {(() => {
                                      const [year, month, day] = option.expiration.split('-').map(Number);
                                      const date = new Date(year, month - 1, day);
                                      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: '2-digit' });
                                    })()}
                                  </span>
                                </div>
                              </div>

                              {/* Greeks Panel */}
                              <div style={{ background: '#000000', borderBottom: '1px solid #1a1a1a' }} className="px-2 py-1.5">
                                <div className="grid grid-cols-2 gap-2">
                                  <div>
                                    <div className="text-[8px] tracking-wider" style={{ color: '#00ff88', fontFamily: 'monospace' }}>DELTA</div>
                                    <div className="text-[10px] font-bold" style={{ color: '#fff', fontFamily: 'monospace' }}>{liveGreeks.delta?.toFixed(3) || '-'}</div>
                                  </div>
                                  <div>
                                    <div className="text-[8px] tracking-wider" style={{ color: '#ff4444', fontFamily: 'monospace' }}>THETA</div>
                                    <div className="text-[10px] font-bold" style={{ color: '#ff4444', fontFamily: 'monospace' }}>-{thetaDecay.toFixed(3)}</div>
                                  </div>
                                  <div>
                                    <div className="text-[8px] tracking-wider" style={{ color: '#bb86fc', fontFamily: 'monospace' }}>IV</div>
                                    <div className="text-[10px] font-bold" style={{ color: '#bb86fc', fontFamily: 'monospace' }}>{impliedVolatility ? (impliedVolatility * 100).toFixed(1) + '%' : 'N/A'}</div>
                                  </div>
                                  <div>
                                    <div className="text-[8px] tracking-wider" style={{ color: '#ff9500', fontFamily: 'monospace' }}>DTE</div>
                                    <div className="text-[10px] font-bold" style={{ color: daysToExpiry < 7 ? '#ff4444' : daysToExpiry < 14 ? '#ffaa00' : '#00ff88', fontFamily: 'monospace' }}>{daysToExpiry}</div>
                                  </div>
                                </div>
                              </div>

                              {/* Position Details */}
                              <div style={{ background: '#000000', borderBottom: '1px solid #1a1a1a' }} className="px-2 py-1.5">
                                <div className="text-[9px] tracking-widest mb-1 text-center font-bold" style={{ color: '#ff9500', fontFamily: 'monospace' }}>POSITION</div>
                                <div className="grid grid-cols-2 gap-x-2 gap-y-1 text-[9px]" style={{ fontFamily: 'monospace' }}>
                                  <div className="flex justify-between">
                                    <span style={{ color: '#ff9500' }}>Entry</span>
                                    <span style={{ color: '#00ccff', fontWeight: 'bold' }}>${entryPrice.toFixed(2)}</span>
                                  </div>
                                  <div className="flex justify-between">
                                    <span style={{ color: '#ff9500' }}>P/L</span>
                                    <span style={{ color: pnlPercent >= 0 ? '#00ff88' : '#ff4444', fontWeight: 'bold' }}>${pnlDollars >= 0 ? '+' : ''}{pnlDollars.toFixed(0)}</span>
                                  </div>
                                  <div className="flex justify-between">
                                    <span style={{ color: '#ff9500' }}>Intrn</span>
                                    <span style={{ color: '#bb86fc', fontWeight: 'bold' }}>${intrinsicValue.toFixed(2)}</span>
                                  </div>
                                  <div className="flex justify-between">
                                    <span style={{ color: '#ff9500' }}>Extrn</span>
                                    <span style={{ color: '#fff', fontWeight: 'bold' }}>${extrinsicValue.toFixed(2)}</span>
                                  </div>
                                </div>
                              </div>
                            </div>

                            {/* Right column: Trade Management on mobile */}
                            <div className="p-1.5 flex flex-col" style={{ background: '#000000' }}>
                              <div className="text-[10px] tracking-widest mb-2 text-center font-bold pb-1.5" style={{ color: '#ff9500', borderBottom: '1px solid #ff950030', fontFamily: 'monospace' }}>TRADE MANAGEMENT</div>

                              {/* Target 1 - Full width */}
                              <div style={{ background: 'linear-gradient(135deg, rgba(13, 40, 24, 0.4) 0%, rgba(13, 40, 24, 0.2) 100%)', border: '1px solid #1a4d2e', borderRadius: '4px' }} className="p-1.5 mb-1.5 relative overflow-hidden">
                                <div className="absolute top-1 right-1">
                                  {currentPrice >= target80OptionValue && (
                                    <span className="text-green-400 text-xs">âœ“</span>
                                  )}
                                </div>
                                <div className="flex items-center justify-between">
                                  <div className="flex-1">
                                    <div className="text-[10px] tracking-wider mb-0.5" style={{ color: '#4ade80', fontFamily: 'monospace' }}>Profit Target 1</div>
                                    <div className="text-lg font-black" style={{ color: '#00ff88', fontFamily: 'monospace', lineHeight: '1' }}>${target80StockPrice.toFixed(2)}</div>
                                  </div>
                                  <div className="text-right">
                                    <div className="text-[11px] font-bold px-1.5 py-0.5 rounded" style={{ color: '#4ade80', background: 'rgba(74, 222, 128, 0.15)' }}>+{((target80OptionValue - entryPrice) / entryPrice * 100).toFixed(0)}%</div>
                                  </div>
                                </div>
                              </div>

                              {/* Target 2 - Full width */}
                              <div style={{ background: 'linear-gradient(135deg, rgba(13, 40, 24, 0.4) 0%, rgba(13, 40, 24, 0.2) 100%)', border: '1px solid #1a4d2e', borderRadius: '4px' }} className="p-1.5 mb-1.5 relative overflow-hidden">
                                <div className="absolute top-1 right-1">
                                  {currentPrice >= target90OptionValue && (
                                    <span className="text-green-400 text-xs">âœ“</span>
                                  )}
                                </div>
                                <div className="flex items-center justify-between">
                                  <div className="flex-1">
                                    <div className="text-[10px] tracking-wider mb-0.5" style={{ color: '#4ade80', fontFamily: 'monospace' }}>Profit Target 2</div>
                                    <div className="text-lg font-black" style={{ color: '#00ff88', fontFamily: 'monospace', lineHeight: '1' }}>${target90StockPrice.toFixed(2)}</div>
                                  </div>
                                  <div className="text-right">
                                    <div className="text-[11px] font-bold px-1.5 py-0.5 rounded" style={{ color: '#4ade80', background: 'rgba(74, 222, 128, 0.15)' }}>+{((target90OptionValue - entryPrice) / entryPrice * 100).toFixed(0)}%</div>
                                  </div>
                                </div>
                              </div>

                              {/* Stop Loss and Daily Decay - Half width side by side */}
                              <div className="grid grid-cols-2 gap-1.5">
                                <div style={{ background: 'linear-gradient(135deg, rgba(45, 13, 13, 0.4) 0%, rgba(45, 13, 13, 0.2) 100%)', border: '1px solid #4d1a1a', borderRadius: '4px' }} className="p-1.5">
                                  <div className="text-[8px] tracking-wider mb-0.5" style={{ color: '#f87171', fontFamily: 'monospace' }}>STOP</div>
                                  <div className="text-sm font-black" style={{ color: '#ff4444', fontFamily: 'monospace', lineHeight: '1' }}>${stopLoss.toFixed(2)}</div>
                                  <div className="text-[9px] mt-0.5" style={{ color: '#f87171' }}>-{((currentPrice - stopLoss) / currentPrice * 100).toFixed(0)}%</div>
                                </div>

                                <div style={{ background: 'linear-gradient(135deg, rgba(45, 31, 13, 0.4) 0%, rgba(45, 31, 13, 0.2) 100%)', border: '1px solid #4d3d1a', borderRadius: '4px' }} className="p-1.5">
                                  <div className="text-[8px] tracking-wider mb-0.5" style={{ color: '#fbbf24', fontFamily: 'monospace' }}>DECAY</div>
                                  <div className="text-sm font-black" style={{ color: '#ffaa00', fontFamily: 'monospace', lineHeight: '1' }}>${(thetaDecay * 100).toFixed(0)}</div>
                                  <div className="text-[9px] mt-0.5" style={{ color: '#fbbf24' }}>{dailyDecay.toFixed(2)}%/d</div>
                                </div>
                              </div>
                            </div>
                          </div>

                          {/* Desktop: Left side info panel */}
                          <div className="hidden md:flex flex-col md:w-[380px]" style={{ background: '#000000' }}>

                            {/* Header - Ticker & Status */}
                            <div style={{ background: '#000000', borderBottom: '1px solid #1a1a1a' }} className="px-3 py-2">
                              <div className="flex items-center justify-between">
                                <div className="flex items-center gap-2">
                                  <div className="text-2xl font-bold tracking-tight" style={{ color: '#fff', fontFamily: 'monospace' }}>{option.symbol}</div>
                                  <div className={`px-1.5 py-0.5 text-[10px] font-bold tracking-wider ${option.type === 'call' ? 'bg-green-500 text-black' : 'bg-red-500 text-white'}`} style={{ fontFamily: 'monospace' }}>
                                    {option.type.toUpperCase()}
                                  </div>
                                </div>
                                <div className="text-right">
                                  <div className="flex items-baseline gap-2">
                                    <span className="text-[10px] tracking-wider" style={{ color: '#ff9500', fontFamily: 'monospace' }}>MARK</span>
                                    <span className="text-xl font-bold" style={{ color: '#fff', fontFamily: 'monospace' }}>${currentPrice.toFixed(2)}</span>
                                    <span className={`text-sm font-bold ${pnlPercent >= 0 ? 'text-green-400' : 'text-red-400'}`} style={{ fontFamily: 'monospace' }}>
                                      {pnlPercent >= 0 ? '+' : ''}{pnlPercent.toFixed(1)}% {pnlPercent >= 0 ? 'â–²' : 'â–¼'}
                                    </span>
                                  </div>
                                </div>
                              </div>
                              <div className="flex items-center gap-3 text-xs mt-1.5" style={{ fontFamily: 'monospace' }}>
                                <span style={{ color: '#ff9500' }}>STRIKE</span>
                                <span style={{ color: '#fff', fontWeight: 'bold' }}>${option.strike}</span>
                                <span style={{ color: '#444' }}>|</span>
                                <span style={{ color: '#ff9500' }}>EXP</span>
                                <span style={{ color: '#fff', fontWeight: 'bold' }}>
                                  {(() => {
                                    const [year, month, day] = option.expiration.split('-').map(Number);
                                    const date = new Date(year, month - 1, day);
                                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: '2-digit' });
                                  })()}
                                </span>
                              </div>
                            </div>

                            {/* Greeks Panel */}
                            <div style={{ background: '#000000', borderBottom: '1px solid #1a1a1a' }} className="px-3 py-2">
                              <div className="grid grid-cols-4 gap-3">
                                <div>
                                  <div className="text-[9px] tracking-wider" style={{ color: '#00ff88', fontFamily: 'monospace' }}>DELTA</div>
                                  <div className="text-sm font-bold" style={{ color: '#fff', fontFamily: 'monospace' }}>{liveGreeks.delta?.toFixed(3) || '-'}</div>
                                </div>
                                <div>
                                  <div className="text-[9px] tracking-wider" style={{ color: '#ff4444', fontFamily: 'monospace' }}>THETA</div>
                                  <div className="text-sm font-bold" style={{ color: '#ff4444', fontFamily: 'monospace' }}>-{thetaDecay.toFixed(3)}</div>
                                </div>
                                <div>
                                  <div className="text-[9px] tracking-wider" style={{ color: '#bb86fc', fontFamily: 'monospace' }}>IV</div>
                                  <div className="text-sm font-bold" style={{ color: '#bb86fc', fontFamily: 'monospace' }}>{impliedVolatility ? (impliedVolatility * 100).toFixed(1) + '%' : 'N/A'}</div>
                                </div>
                                <div>
                                  <div className="text-[9px] tracking-wider" style={{ color: '#ff9500', fontFamily: 'monospace' }}>DTE</div>
                                  <div className="text-sm font-bold" style={{ color: daysToExpiry < 7 ? '#ff4444' : daysToExpiry < 14 ? '#ffaa00' : '#00ff88', fontFamily: 'monospace' }}>{daysToExpiry}</div>
                                </div>
                              </div>
                            </div>

                            {/* Position Details */}
                            <div style={{ background: '#000000', borderBottom: '1px solid #1a1a1a' }} className="px-3 py-2">
                              <div className="text-xs tracking-widest mb-2 text-center font-bold" style={{ color: '#ff9500', fontFamily: 'monospace' }}>POSITION</div>
                              <div className="grid grid-cols-2 gap-x-4 gap-y-1.5 text-xs" style={{ fontFamily: 'monospace' }}>
                                <div className="flex justify-between">
                                  <span style={{ color: '#ff9500' }}>Entry</span>
                                  <span style={{ color: '#00ccff', fontWeight: 'bold' }}>${entryPrice.toFixed(2)}</span>
                                </div>
                                <div className="flex justify-between">
                                  <span style={{ color: '#ff9500' }}>P/L</span>
                                  <span style={{ color: pnlPercent >= 0 ? '#00ff88' : '#ff4444', fontWeight: 'bold' }}>${pnlDollars >= 0 ? '+' : ''}{pnlDollars.toFixed(0)}</span>
                                </div>
                                <div className="flex justify-between">
                                  <span style={{ color: '#ff9500' }}>Intrinsic</span>
                                  <span style={{ color: '#bb86fc', fontWeight: 'bold' }}>${Math.max(0, option.type === 'call'
                                    ? (option.stockPrice || 0) - option.strike
                                    : option.strike - (option.stockPrice || 0)
                                  ).toFixed(2)}</span>
                                </div>
                                <div className="flex justify-between">
                                  <span style={{ color: '#ff9500' }}>Extrinsic</span>
                                  <span style={{ color: '#fff', fontWeight: 'bold' }}>${(currentPrice - Math.max(0, option.type === 'call'
                                    ? (option.stockPrice || 0) - option.strike
                                    : option.strike - (option.stockPrice || 0)
                                  )).toFixed(2)}</span>
                                </div>
                              </div>
                            </div>

                            {/* Trade Management */}
                            <div className="md:flex-1 md:p-2 hidden md:block" style={{ background: '#000000' }}>
                              <div className="text-base tracking-widest mb-2 text-center font-bold" style={{ color: '#ff9500', opacity: 1, fontFamily: 'monospace' }}>TRADE MANAGEMENT</div>
                              <div className="grid grid-cols-2 gap-2">
                                <div style={{ background: 'rgba(13, 40, 24, 0.3)', border: '1px solid #1a4d2e' }} className="p-2 relative">
                                  <div className="text-[14px] tracking-wider mb-0.5 flex items-center justify-between" style={{ fontFamily: 'monospace' }}>
                                    <span style={{ color: '#4ade80', opacity: 1 }}>TARGET 1</span>
                                    {currentPrice >= target80OptionValue && (
                                      <span className="text-green-400 text-lg">âœ“</span>
                                    )}
                                  </div>
                                  <div className="text-xl font-bold" style={{ color: '#00ff88', opacity: 1, fontFamily: 'monospace' }}>${target80StockPrice.toFixed(2)}</div>
                                  <div className="text-[12px]" style={{ color: '#4ade80', opacity: 1, fontFamily: 'monospace' }}>+{((target80OptionValue - entryPrice) / entryPrice * 100).toFixed(0)}%</div>
                                </div>
                                <div style={{ background: 'rgba(13, 40, 24, 0.3)', border: '1px solid #1a4d2e' }} className="p-2 relative">
                                  <div className="text-[14px] tracking-wider mb-0.5 flex items-center justify-between" style={{ fontFamily: 'monospace' }}>
                                    <span style={{ color: '#4ade80', opacity: 1 }}>TARGET 2</span>
                                    {currentPrice >= target90OptionValue && (
                                      <span className="text-green-400 text-lg">âœ“</span>
                                    )}
                                  </div>
                                  <div className="text-xl font-bold" style={{ color: '#00ff88', opacity: 1, fontFamily: 'monospace' }}>${target90StockPrice.toFixed(2)}</div>
                                  <div className="text-[12px]" style={{ color: '#4ade80', opacity: 1, fontFamily: 'monospace' }}>+{((target90OptionValue - entryPrice) / entryPrice * 100).toFixed(0)}%</div>
                                </div>
                                <div style={{ background: 'rgba(45, 13, 13, 0.3)', border: '1px solid #4d1a1a' }} className="p-2">
                                  <div className="text-[14px] tracking-wider mb-0.5" style={{ color: '#f87171', opacity: 1, fontFamily: 'monospace' }}>STOP LOSS</div>
                                  <div className="text-xl font-bold" style={{ color: '#ff4444', opacity: 1, fontFamily: 'monospace' }}>${stopLoss.toFixed(2)} <span className="text-[12px]" style={{ color: '#f87171', opacity: 1 }}>-{((currentPrice - stopLoss) / currentPrice * 100).toFixed(0)}%</span></div>
                                </div>
                                <div style={{ background: 'rgba(45, 31, 13, 0.3)', border: '1px solid #4d3d1a' }} className="p-2">
                                  <div className="text-[14px] tracking-wider mb-0.5" style={{ color: '#fbbf24', opacity: 1, fontFamily: 'monospace' }}>DAILY DECAY</div>
                                  <div className="text-xl font-bold" style={{ color: '#ffaa00', opacity: 1, fontFamily: 'monospace' }}>${(thetaDecay * 100).toFixed(0)} <span className="text-[12px]" style={{ color: '#fbbf24', opacity: 1 }}>{dailyDecay.toFixed(2)}%/day</span></div>
                                </div>
                              </div>
                            </div>
                          </div>

                          {/* Mobile charts - conditional rendering (default hidden) */}
                          {optionChartsVisible[option.id] && (
                            <div className="md:hidden">
                              <div className="md:flex md:gap-4 space-y-3 md:space-y-0">
                                {(['1D', '5D', '1M'] as const).map(tf => {
                                  const currentTimeframe = optionsTradesTimeframes[option.id] || '1D';
                                  return (
                                    <button
                                      key={tf}
                                      onClick={() => setOptionsTradesTimeframes(prev => ({ ...prev, [option.id]: tf }))}
                                      className="px-4 py-1 rounded text-xs font-bold uppercase transition-all"
                                      style={{
                                        background: currentTimeframe === tf ? '#ff9500' : '#1a1a1a',
                                        color: currentTimeframe === tf ? '#000000' : '#ffffff',
                                        border: `1px solid ${currentTimeframe === tf ? '#ff9500' : '#333'}`,
                                        fontFamily: 'monospace'
                                      }}
                                    >
                                      {tf}
                                    </button>
                                  );
                                })}
                              </div>

                              <div className="md:flex md:gap-4 space-y-3 md:space-y-0">{/* Options Premium Chart */}
                                <div className="md:border-l border-gray-800/30 md:pl-4">
                                  <div className="text-xs text-white font-bold uppercase mb-1 text-center" style={{ color: '#00d4ff' }}>Premium</div>
                                  <div className="md:w-[450px] w-full md:h-[280px] h-[200px] rounded-lg" style={{
                                    background: 'linear-gradient(to bottom, #030508 0%, #010203 100%)',
                                    border: '1px solid rgba(0, 212, 255, 0.2)',
                                    boxShadow: '0 0 20px rgba(0, 212, 255, 0.1)'
                                  }}>
                                    {optionPremiumData.length > 0 ? (
                                      <svg width="100%" height="100%" viewBox="0 0 900 560" preserveAspectRatio="xMidYMid meet" className="overflow-visible" style={{ shapeRendering: 'geometricPrecision' }}>
                                        {(() => {
                                          const prices = optionPremiumData.map(d => d.price);
                                          const minPrice = Math.min(...prices);
                                          const maxPrice = Math.max(...prices);
                                          const priceRange = maxPrice - minPrice || 1;
                                          const midPrice = (minPrice + maxPrice) / 2;

                                          // Add margins: 20px on left, 90px on right, 20px top, 40px bottom (doubled for 2x resolution)
                                          const chartWidth = 900;
                                          const chartHeight = 560;
                                          const marginLeft = 20;
                                          const marginRight = 80;
                                          const marginTop = 20;
                                          const marginBottom = 50;
                                          const plotWidth = chartWidth - marginLeft - marginRight;
                                          const plotHeight = chartHeight - marginTop - marginBottom;

                                          const points = optionPremiumData.map((d, i) => {
                                            const x = marginLeft + (i / (optionPremiumData.length - 1)) * plotWidth;
                                            const y = marginTop + (plotHeight - ((d.price - minPrice) / priceRange * plotHeight));
                                            return `${x},${y}`;
                                          }).join(' ');

                                          const isPositive = optionPremiumData[optionPremiumData.length - 1].price >= optionPremiumData[0].price;
                                          const lineColor = isPositive ? '#00ff88' : '#ff4466';
                                          const areaColor = isPositive ? 'rgba(0, 255, 136, 0.15)' : 'rgba(255, 68, 102, 0.15)';

                                          // Options only trade during market hours - create full area path
                                          const areaPath = `M ${marginLeft},${marginTop + plotHeight} L ${points.split(' ').map(p => `${p}`).join(' L ')} L ${marginLeft + plotWidth},${marginTop + plotHeight} Z`;

                                          // X-axis labels
                                          const firstTime = new Date(optionPremiumData[0].timestamp);
                                          const midTime = new Date(optionPremiumData[Math.floor(optionPremiumData.length / 2)].timestamp);
                                          const lastTime = new Date(optionPremiumData[optionPremiumData.length - 1].timestamp);

                                          const formatTime = (date: Date) => {
                                            const currentTimeframe = optionsTradesTimeframes[option.id] || '1D';
                                            if (currentTimeframe === '1D') {
                                              return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/New_York' });
                                            } else if (currentTimeframe === '5D') {
                                              return date.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', timeZone: 'America/New_York' });
                                            } else {
                                              return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'America/New_York' });
                                            }
                                          };

                                          return (
                                            <>
                                              {/* Grid lines */}
                                              <line x1={marginLeft} y1={marginTop} x2={marginLeft + plotWidth} y2={marginTop} stroke="rgba(255,255,255,0.05)" strokeWidth="2" />
                                              <line x1={marginLeft} y1={marginTop + plotHeight / 2} x2={marginLeft + plotWidth} y2={marginTop + plotHeight / 2} stroke="rgba(255,255,255,0.05)" strokeWidth="2" />
                                              <line x1={marginLeft} y1={marginTop + plotHeight} x2={marginLeft + plotWidth} y2={marginTop + plotHeight} stroke="rgba(255,255,255,0.1)" strokeWidth="2" />

                                              {/* Area fill */}
                                              <path d={areaPath} fill={areaColor} />

                                              {/* Main line - crisp and bold */}
                                              <polyline
                                                points={points}
                                                fill="none"
                                                stroke={lineColor}
                                                strokeWidth="5"
                                                strokeLinecap="round"
                                                strokeLinejoin="round"
                                              />

                                              {/* Data points */}
                                              {optionPremiumData.filter((_, i) => i % Math.max(1, Math.floor(optionPremiumData.length / 20)) === 0).map((d, i) => {
                                                const idx = i * Math.max(1, Math.floor(optionPremiumData.length / 20));
                                                const x = marginLeft + (idx / (optionPremiumData.length - 1)) * plotWidth;
                                                const y = marginTop + (plotHeight - ((d.price - minPrice) / priceRange * plotHeight));
                                                return (
                                                  <circle
                                                    key={i}
                                                    cx={x}
                                                    cy={y}
                                                    r="6"
                                                    fill={lineColor}
                                                    opacity="0.8"
                                                  />
                                                );
                                              })}

                                              {/* Y-axis labels */}
                                              <text x={chartWidth - 5} y={marginTop + 15} fill="#00d4ff" fontSize="18" fontWeight="600" textAnchor="end">${maxPrice.toFixed(2)}</text>
                                              <text x={chartWidth - 5} y={marginTop + plotHeight / 2 + 7} fill="white" fontSize="18" textAnchor="end">${midPrice.toFixed(2)}</text>
                                              <text x={chartWidth - 5} y={marginTop + plotHeight - 8} fill="white" fontSize="18" textAnchor="end">${minPrice.toFixed(2)}</text>
                                              {/* X-axis labels */}
                                              <text x={marginLeft} y={chartHeight - 15} fill="white" fontSize="18" textAnchor="start">{formatTime(firstTime)}</text>
                                              <text x={marginLeft + plotWidth / 2} y={chartHeight - 15} fill="white" fontSize="18" textAnchor="middle">{formatTime(midTime)}</text>
                                              <text x={marginLeft + plotWidth} y={chartHeight - 15} fill="white" fontSize="18" textAnchor="end">{formatTime(lastTime)}</text>
                                            </>
                                          );
                                        })()}
                                      </svg>
                                    ) : (
                                      <div className="flex items-center justify-center h-full text-gray-600 text-xs">
                                        Loading...
                                      </div>
                                    )}
                                  </div>
                                </div>

                                {/* Stock Chart */}
                                <div className="md:border-l border-gray-800/30 md:pl-4">
                                  <div className="text-xs text-white font-bold uppercase mb-1 text-center" style={{ color: '#ff9500' }}>Stock Price</div>
                                  <div className="md:w-[450px] w-full md:h-[280px] h-[200px] rounded-lg" style={{
                                    background: 'linear-gradient(to bottom, #030508 0%, #010203 100%)',
                                    border: '1px solid rgba(255, 149, 0, 0.2)',
                                    boxShadow: '0 0 20px rgba(255, 149, 0, 0.1)'
                                  }}>
                                    {stockData.length > 0 ? (
                                      <svg width="100%" height="100%" viewBox="0 0 900 560" preserveAspectRatio="xMidYMid meet" className="overflow-visible" style={{ shapeRendering: 'geometricPrecision' }}>
                                        {(() => {
                                          const prices = stockData.map(d => d.price);
                                          const minPrice = Math.min(...prices);
                                          const maxPrice = Math.max(...prices);
                                          const priceRange = maxPrice - minPrice || 1;
                                          const midPrice = (minPrice + maxPrice) / 2;

                                          // Add margins: 20px on left, 90px on right, 20px top, 40px bottom (doubled for 2x resolution)
                                          const chartWidth = 900;
                                          const chartHeight = 560;
                                          const marginLeft = 20;
                                          const marginRight = 80;
                                          const marginTop = 20;
                                          const marginBottom = 50;
                                          const plotWidth = chartWidth - marginLeft - marginRight;
                                          const plotHeight = chartHeight - marginTop - marginBottom;

                                          const points = stockData.map((d, i) => {
                                            const x = marginLeft + (i / (stockData.length - 1)) * plotWidth;
                                            const y = marginTop + (plotHeight - ((d.price - minPrice) / priceRange * plotHeight));
                                            return `${x},${y}`;
                                          }).join(' ');

                                          const isPositive = stockData[stockData.length - 1].price >= stockData[0].price;
                                          const lineColor = isPositive ? '#00ff88' : '#ff4466';
                                          const areaColor = isPositive ? 'rgba(0, 255, 136, 0.15)' : 'rgba(255, 68, 102, 0.15)';

                                          // Session backgrounds for pre-market and after-hours (stocks trade extended hours)
                                          const sessionBackgrounds: Array<{ x: number; width: number; color: string }> = [];
                                          const currentTimeframe = optionsTradesTimeframes[option.id] || '1D';
                                          if (currentTimeframe === '1D') {
                                            let lastBgColor: string | null = null;
                                            for (let i = 0; i < stockData.length; i++) {
                                              const time = new Date(stockData[i].timestamp);
                                              const etTime = time.toLocaleString('en-US', { timeZone: 'America/New_York' });
                                              const etDate = new Date(etTime);
                                              const hour = etDate.getHours();
                                              const minute = etDate.getMinutes();
                                              const totalMinutes = hour * 60 + minute;

                                              let bgColor: string | null = null;
                                              if (totalMinutes >= 4 * 60 && totalMinutes < 9 * 60 + 30) { // Pre-market: 4 AM - 9:30 AM ET
                                                bgColor = 'rgba(255, 140, 0, 0.12)'; // Orange
                                              } else if (totalMinutes >= 16 * 60 && totalMinutes < 20 * 60) { // After-hours: 4 PM - 8 PM ET
                                                bgColor = 'rgba(25, 50, 100, 0.15)'; // Navy blue
                                              }

                                              if (bgColor && bgColor !== lastBgColor) {
                                                const x = marginLeft + (i / (stockData.length - 1)) * plotWidth;
                                                const nextIndex = stockData.slice(i + 1).findIndex((d, idx) => {
                                                  const t = new Date(d.timestamp);
                                                  const tEt = t.toLocaleString('en-US', { timeZone: 'America/New_York' });
                                                  const tEtDate = new Date(tEt);
                                                  const h = tEtDate.getHours();
                                                  const m = tEtDate.getMinutes();
                                                  const tm = h * 60 + m;
                                                  let nextBgColor: string | null = null;
                                                  if (tm >= 4 * 60 && tm < 9 * 60 + 30) nextBgColor = 'rgba(255, 140, 0, 0.12)'; // Orange
                                                  else if (tm >= 16 * 60 && tm < 20 * 60) nextBgColor = 'rgba(25, 50, 100, 0.15)'; // Navy blue
                                                  return nextBgColor !== bgColor;
                                                });

                                                const endIndex = nextIndex === -1 ? stockData.length - 1 : nextIndex + i + 1;
                                                const x2 = marginLeft + (endIndex / (stockData.length - 1)) * plotWidth;
                                                const width = x2 - x;

                                                sessionBackgrounds.push({
                                                  x,
                                                  width,
                                                  color: bgColor
                                                });
                                              }
                                              lastBgColor = bgColor;
                                            }
                                          }

                                          // Create area path segments only for market hours
                                          const marketHoursSegments: string[] = [];
                                          if (currentTimeframe === '1D') {
                                            let segmentPoints: string[] = [];
                                            for (let i = 0; i < stockData.length; i++) {
                                              const time = new Date(stockData[i].timestamp);
                                              const etTime = time.toLocaleString('en-US', { timeZone: 'America/New_York' });
                                              const etDate = new Date(etTime);
                                              const hour = etDate.getHours();
                                              const minute = etDate.getMinutes();
                                              const totalMinutes = hour * 60 + minute;
                                              const isMarketHours = totalMinutes >= 9 * 60 + 30 && totalMinutes < 16 * 60;

                                              if (isMarketHours) {
                                                const x = marginLeft + (i / (stockData.length - 1)) * plotWidth;
                                                const y = marginTop + (plotHeight - ((stockData[i].price - minPrice) / priceRange * plotHeight));
                                                segmentPoints.push(`${x},${y}`);
                                              } else if (segmentPoints.length > 0) {
                                                // End of market hours segment
                                                const firstPoint = segmentPoints[0];
                                                const lastPoint = segmentPoints[segmentPoints.length - 1];
                                                const [lastX] = lastPoint.split(',');
                                                const [firstX] = firstPoint.split(',');
                                                const segmentPath = `M ${firstX},${marginTop + plotHeight} L ${segmentPoints.join(' L ')} L ${lastX},${marginTop + plotHeight} Z`;
                                                marketHoursSegments.push(segmentPath);
                                                segmentPoints = [];
                                              }
                                            }
                                            // Handle last segment if it ends during market hours
                                            if (segmentPoints.length > 0) {
                                              const firstPoint = segmentPoints[0];
                                              const lastPoint = segmentPoints[segmentPoints.length - 1];
                                              const [lastX] = lastPoint.split(',');
                                              const [firstX] = firstPoint.split(',');
                                              const segmentPath = `M ${firstX},${marginTop + plotHeight} L ${segmentPoints.join(' L ')} L ${lastX},${marginTop + plotHeight} Z`;
                                              marketHoursSegments.push(segmentPath);
                                            }
                                          } else {
                                            // For non-1D timeframes, show full area
                                            const areaPath = `M ${marginLeft},${marginTop + plotHeight} L ${points.split(' ').map(p => `${p}`).join(' L ')} L ${marginLeft + plotWidth},${marginTop + plotHeight} Z`;
                                            marketHoursSegments.push(areaPath);
                                          }

                                          // X-axis labels
                                          const firstTime = new Date(stockData[0].timestamp);
                                          const midTime = new Date(stockData[Math.floor(stockData.length / 2)].timestamp);
                                          const lastTime = new Date(stockData[stockData.length - 1].timestamp);

                                          const formatTime = (date: Date) => {
                                            const currentTimeframe = optionsTradesTimeframes[option.id] || '1D';
                                            if (currentTimeframe === '1D') {
                                              return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/New_York' });
                                            } else if (currentTimeframe === '5D') {
                                              return date.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', timeZone: 'America/New_York' });
                                            } else {
                                              return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'America/New_York' });
                                            }
                                          };

                                          return (
                                            <>
                                              {/* Session backgrounds */}
                                              {sessionBackgrounds.map((bg, i) => (
                                                <rect
                                                  key={i}
                                                  x={bg.x}
                                                  y={marginTop}
                                                  width={bg.width}
                                                  height={plotHeight}
                                                  fill={bg.color}
                                                />
                                              ))}

                                              {/* Grid lines */}
                                              <line x1={marginLeft} y1={marginTop} x2={marginLeft + plotWidth} y2={marginTop} stroke="rgba(255,255,255,0.05)" strokeWidth="2" />
                                              <line x1={marginLeft} y1={marginTop + plotHeight / 2} x2={marginLeft + plotWidth} y2={marginTop + plotHeight / 2} stroke="rgba(255,255,255,0.05)" strokeWidth="2" />
                                              <line x1={marginLeft} y1={marginTop + plotHeight} x2={marginLeft + plotWidth} y2={marginTop + plotHeight} stroke="rgba(255,255,255,0.1)" strokeWidth="2" />

                                              {/* Area fill - only during market hours */}
                                              {marketHoursSegments.map((path, i) => (
                                                <path key={i} d={path} fill={areaColor} />
                                              ))}

                                              {/* Main line - crisp and bold */}
                                              <polyline
                                                points={points}
                                                fill="none"
                                                stroke={lineColor}
                                                strokeWidth="5"
                                                strokeLinecap="round"
                                                strokeLinejoin="round"
                                              />

                                              {/* Data points - show fewer for cleaner look */}
                                              {stockData.filter((_, i) => i % Math.max(1, Math.floor(stockData.length / 20)) === 0).map((d, i) => {
                                                const idx = i * Math.max(1, Math.floor(stockData.length / 20));
                                                const x = marginLeft + (idx / (stockData.length - 1)) * plotWidth;
                                                const y = marginTop + (plotHeight - ((d.price - minPrice) / priceRange * plotHeight));
                                                return (
                                                  <circle
                                                    key={i}
                                                    cx={x}
                                                    cy={y}
                                                    r="6"
                                                    fill={lineColor}
                                                    opacity="0.8"
                                                  />
                                                );
                                              })}

                                              {/* Y-axis labels */}
                                              <text x={chartWidth - 5} y={marginTop + 15} fill="#ff9500" fontSize="18" fontWeight="600" textAnchor="end">${maxPrice.toFixed(2)}</text>
                                              <text x={chartWidth - 5} y={marginTop + plotHeight / 2 + 7} fill="white" fontSize="18" textAnchor="end">${midPrice.toFixed(2)}</text>
                                              <text x={chartWidth - 5} y={marginTop + plotHeight - 8} fill="white" fontSize="18" textAnchor="end">${minPrice.toFixed(2)}</text>
                                              {/* X-axis labels */}
                                              <text x={marginLeft} y={chartHeight - 15} fill="white" fontSize="18" textAnchor="start">{formatTime(firstTime)}</text>
                                              <text x={marginLeft + plotWidth / 2} y={chartHeight - 15} fill="white" fontSize="18" textAnchor="middle">{formatTime(midTime)}</text>
                                              <text x={marginLeft + plotWidth} y={chartHeight - 15} fill="white" fontSize="18" textAnchor="end">{formatTime(lastTime)}</text>
                                            </>
                                          );
                                        })()}
                                      </svg>
                                    ) : (
                                      <div className="flex items-center justify-center h-full text-gray-600 text-xs">
                                        Loading...
                                      </div>
                                    )}
                                  </div>
                                </div>
                              </div>
                            </div>
                          )}

                          {/* Desktop Right side: Charts spanning full height */}
                          <div className="hidden md:block md:flex-1">
                            {/* Timeframe Selector */}
                            <div className="flex justify-center gap-2 mb-3">
                              {(['1D', '5D', '1M'] as const).map(tf => {
                                const currentTimeframe = optionsTradesTimeframes[option.id] || '1D';
                                return (
                                  <button
                                    key={tf}
                                    onClick={() => setOptionsTradesTimeframes(prev => ({ ...prev, [option.id]: tf }))}
                                    className="px-4 py-1 rounded text-xs font-bold uppercase transition-all"
                                    style={{
                                      background: currentTimeframe === tf ? '#ff9500' : '#1a1a1a',
                                      color: currentTimeframe === tf ? '#000000' : '#ffffff',
                                      border: `1px solid ${currentTimeframe === tf ? '#ff9500' : '#333'}`,
                                      fontFamily: 'monospace'
                                    }}
                                  >
                                    {tf}
                                  </button>
                                );
                              })}
                            </div>

                            <div className="space-y-4">
                              {/* Premium Chart */}
                              <div>
                                <div className="text-sm text-white font-bold uppercase mb-2 text-center" style={{ color: '#00d4ff' }}>Premium</div>
                                <div className="w-full h-[265px] rounded-lg" style={{
                                  background: 'linear-gradient(to bottom, #030508 0%, #010203 100%)',
                                  border: '1px solid rgba(0, 212, 255, 0.2)',
                                  boxShadow: '0 0 20px rgba(0, 212, 255, 0.1)'
                                }}>
                                  {optionPremiumData.length > 0 ? (
                                    <svg width="100%" height="100%" viewBox="0 0 450 265" preserveAspectRatio="xMidYMid meet" style={{ display: 'block' }}>
                                      {(() => {
                                        const prices = optionPremiumData.map(d => d.price);
                                        const minPrice = Math.min(...prices);
                                        const maxPrice = Math.max(...prices);
                                        const priceRange = maxPrice - minPrice || 1;
                                        const midPrice = (minPrice + maxPrice) / 2;

                                        const width = 450;
                                        const height = 265;
                                        const margin = { top: 15, right: 60, bottom: 25, left: 10 };
                                        const chartWidth = width - margin.left - margin.right;
                                        const chartHeight = height - margin.top - margin.bottom;

                                        const xScale = (i: number) => margin.left + (i / Math.max(1, optionPremiumData.length - 1)) * chartWidth;
                                        const yScale = (price: number) => margin.top + chartHeight - ((price - minPrice) / priceRange * chartHeight);

                                        const points = optionPremiumData.map((d, i) => `${xScale(i)},${yScale(d.price)}`).join(' ');

                                        const isPositive = optionPremiumData[optionPremiumData.length - 1].price >= optionPremiumData[0].price;
                                        const lineColor = isPositive ? '#00ff88' : '#ff4466';
                                        const areaColor = isPositive ? 'rgba(0, 255, 136, 0.15)' : 'rgba(255, 68, 102, 0.15)';

                                        const areaPoints = optionPremiumData.map((d, i) => `${xScale(i)},${yScale(d.price)}`);
                                        const areaPath = `M ${margin.left},${margin.top + chartHeight} L ${areaPoints.join(' L ')} L ${margin.left + chartWidth},${margin.top + chartHeight} Z`;

                                        const formatTime = (date: Date, position: 'start' | 'mid' | 'end') => {
                                          const currentTimeframe = optionsTradesTimeframes[option.id] || '1D';
                                          if (currentTimeframe === '1D') {
                                            const etTime = new Date(date.toLocaleString('en-US', { timeZone: 'America/New_York' }));
                                            const totalMinutes = etTime.getHours() * 60 + etTime.getMinutes();

                                            if (position === 'start' && totalMinutes < 570) return 'Pre-Market';
                                            if (position === 'start' && totalMinutes >= 570) return '9:30 AM';
                                            if (position === 'end') return '4:00 PM';
                                            return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/New_York' });
                                          } else if (currentTimeframe === '5D') {
                                            return date.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', timeZone: 'America/New_York' });
                                          } else {
                                            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'America/New_York' });
                                          }
                                        };

                                        const firstTime = new Date(optionPremiumData[0].timestamp);
                                        const midTime = new Date(optionPremiumData[Math.floor(optionPremiumData.length / 2)].timestamp);
                                        const lastTime = new Date(optionPremiumData[optionPremiumData.length - 1].timestamp);

                                        return (
                                          <g>
                                            <line x1={margin.left} y1={margin.top} x2={margin.left + chartWidth} y2={margin.top} stroke="rgba(255,255,255,0.05)" strokeWidth="0.5" />
                                            <line x1={margin.left} y1={margin.top + chartHeight / 2} x2={margin.left + chartWidth} y2={margin.top + chartHeight / 2} stroke="rgba(255,255,255,0.05)" strokeWidth="0.5" />
                                            <line x1={margin.left} y1={margin.top + chartHeight} x2={margin.left + chartWidth} y2={margin.top + chartHeight} stroke="rgba(255,255,255,0.1)" strokeWidth="0.5" />

                                            <path d={areaPath} fill={areaColor} vectorEffect="non-scaling-stroke" />
                                            <polyline points={points} fill="none" stroke={lineColor} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" vectorEffect="non-scaling-stroke" />

                                            {optionPremiumData.filter((_, i) => i % Math.max(1, Math.floor(optionPremiumData.length / 30)) === 0).map((d, i) => {
                                              const idx = i * Math.max(1, Math.floor(optionPremiumData.length / 30));
                                              return <circle key={i} cx={xScale(idx)} cy={yScale(d.price)} r="2" fill={lineColor} opacity="0.8" vectorEffect="non-scaling-stroke" />;
                                            })}

                                            <text x={width - 3} y={margin.top + 10} fill="#00d4ff" fontSize="13" fontWeight="600" textAnchor="end">${maxPrice.toFixed(2)}</text>
                                            <text x={width - 3} y={margin.top + chartHeight / 2 + 3} fill="white" fontSize="12" textAnchor="end">${midPrice.toFixed(2)}</text>
                                            <text x={width - 3} y={margin.top + chartHeight - 3} fill="white" fontSize="12" textAnchor="end">${minPrice.toFixed(2)}</text>

                                            <text x={margin.left} y={height - 5} fill="white" fontSize="13" textAnchor="start">{formatTime(firstTime, 'start')}</text>
                                            <text x={margin.left + chartWidth / 2} y={height - 5} fill="white" fontSize="13" textAnchor="middle">{formatTime(midTime, 'mid')}</text>
                                            <text x={margin.left + chartWidth} y={height - 5} fill="white" fontSize="13" textAnchor="end">{formatTime(lastTime, 'end')}</text>
                                          </g>
                                        );
                                      })()}
                                    </svg>
                                  ) : (
                                    <div className="flex items-center justify-center h-full text-gray-600 text-sm">Loading...</div>
                                  )}
                                </div>
                              </div>

                              {/* Stock Chart */}
                              <div>
                                <div className="text-sm text-white font-bold uppercase mb-2 text-center" style={{ color: '#ff9500' }}>Stock Price</div>
                                <div className="w-full h-[265px] rounded-lg" style={{
                                  background: 'linear-gradient(to bottom, #030508 0%, #010203 100%)',
                                  border: '1px solid rgba(255, 149, 0, 0.2)',
                                  boxShadow: '0 0 20px rgba(255, 149, 0, 0.1)'
                                }}>
                                  {stockData.length > 0 ? (
                                    <svg width="100%" height="100%" viewBox="0 0 450 265" preserveAspectRatio="xMidYMid meet" style={{ display: 'block' }}>
                                      {(() => {
                                        const prices = stockData.map(d => d.price);
                                        const minPrice = Math.min(...prices);
                                        const maxPrice = Math.max(...prices);
                                        const priceRange = maxPrice - minPrice || 1;
                                        const midPrice = (minPrice + maxPrice) / 2;

                                        const width = 450;
                                        const height = 265;
                                        const margin = { top: 15, right: 60, bottom: 25, left: 10 };
                                        const chartWidth = width - margin.left - margin.right;
                                        const chartHeight = height - margin.top - margin.bottom;

                                        const xScale = (i: number) => margin.left + (i / Math.max(1, stockData.length - 1)) * chartWidth;
                                        const yScale = (price: number) => margin.top + chartHeight - ((price - minPrice) / priceRange * chartHeight);

                                        const points = stockData.map((d, i) => `${xScale(i)},${yScale(d.price)}`).join(' ');

                                        const isPositive = stockData[stockData.length - 1].price >= stockData[0].price;
                                        const lineColor = isPositive ? '#00ff88' : '#ff4466';
                                        const areaColor = isPositive ? 'rgba(0, 255, 136, 0.15)' : 'rgba(255, 68, 102, 0.15)';

                                        const currentTimeframe = optionsTradesTimeframes[option.id] || '1D';

                                        // Session backgrounds
                                        const sessionBgs: Array<{ x: number; width: number; color: string }> = [];
                                        if (currentTimeframe === '1D') {
                                          let lastBg: string | null = null;
                                          let startIdx = -1;

                                          for (let i = 0; i < stockData.length; i++) {
                                            const time = new Date(stockData[i].timestamp);
                                            const etTime = new Date(time.toLocaleString('en-US', { timeZone: 'America/New_York' }));
                                            const totalMinutes = etTime.getHours() * 60 + etTime.getMinutes();

                                            let bg: string | null = null;
                                            if (totalMinutes >= 240 && totalMinutes < 570) bg = 'rgba(255, 140, 0, 0.12)';
                                            else if (totalMinutes >= 960 && totalMinutes < 1200) bg = 'rgba(25, 50, 100, 0.15)';

                                            if (bg !== lastBg) {
                                              if (lastBg && startIdx >= 0) {
                                                sessionBgs.push({ x: xScale(startIdx), width: xScale(i - 1) - xScale(startIdx), color: lastBg });
                                              }
                                              startIdx = i;
                                              lastBg = bg;
                                            }
                                          }
                                          if (lastBg && startIdx >= 0) {
                                            sessionBgs.push({ x: xScale(startIdx), width: xScale(stockData.length - 1) - xScale(startIdx), color: lastBg });
                                          }
                                        }

                                        // Market hours area
                                        const marketSegments: string[] = [];
                                        if (currentTimeframe === '1D') {
                                          let segmentPoints: string[] = [];
                                          for (let i = 0; i < stockData.length; i++) {
                                            const time = new Date(stockData[i].timestamp);
                                            const etTime = new Date(time.toLocaleString('en-US', { timeZone: 'America/New_York' }));
                                            const totalMinutes = etTime.getHours() * 60 + etTime.getMinutes();
                                            const isMarketHours = totalMinutes >= 570 && totalMinutes < 960;

                                            if (isMarketHours) {
                                              segmentPoints.push(`${xScale(i)},${yScale(stockData[i].price)}`);
                                            } else if (segmentPoints.length > 0) {
                                              const firstPoint = segmentPoints[0].split(',');
                                              const lastPoint = segmentPoints[segmentPoints.length - 1].split(',');
                                              marketSegments.push(`M ${firstPoint[0]},${margin.top + chartHeight} L ${segmentPoints.join(' L ')} L ${lastPoint[0]},${margin.top + chartHeight} Z`);
                                              segmentPoints = [];
                                            }
                                          }
                                          if (segmentPoints.length > 0) {
                                            const firstPoint = segmentPoints[0].split(',');
                                            const lastPoint = segmentPoints[segmentPoints.length - 1].split(',');
                                            marketSegments.push(`M ${firstPoint[0]},${margin.top + chartHeight} L ${segmentPoints.join(' L ')} L ${lastPoint[0]},${margin.top + chartHeight} Z`);
                                          }
                                        } else {
                                          const areaPoints = stockData.map((d, i) => `${xScale(i)},${yScale(d.price)}`);
                                          marketSegments.push(`M ${margin.left},${margin.top + chartHeight} L ${areaPoints.join(' L ')} L ${margin.left + chartWidth},${margin.top + chartHeight} Z`);
                                        }

                                        const formatTime = (date: Date, position: 'start' | 'mid' | 'end') => {
                                          if (currentTimeframe === '1D') {
                                            const etTime = new Date(date.toLocaleString('en-US', { timeZone: 'America/New_York' }));
                                            const totalMinutes = etTime.getHours() * 60 + etTime.getMinutes();

                                            if (position === 'start' && totalMinutes < 570) return 'Pre-Market';
                                            if (position === 'start' && totalMinutes >= 570) return '9:30 AM';
                                            if (position === 'end') return '4:00 PM';
                                            return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/New_York' });
                                          } else if (currentTimeframe === '5D') {
                                            return date.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', timeZone: 'America/New_York' });
                                          } else {
                                            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'America/New_York' });
                                          }
                                        };

                                        const firstTime = new Date(stockData[0].timestamp);
                                        const midTime = new Date(stockData[Math.floor(stockData.length / 2)].timestamp);
                                        const lastTime = new Date(stockData[stockData.length - 1].timestamp);

                                        return (
                                          <g>
                                            {sessionBgs.map((bg, i) => (
                                              <rect key={i} x={bg.x} y={margin.top} width={bg.width} height={chartHeight} fill={bg.color} />
                                            ))}

                                            <line x1={margin.left} y1={margin.top} x2={margin.left + chartWidth} y2={margin.top} stroke="rgba(255,255,255,0.05)" strokeWidth="0.5" />
                                            <line x1={margin.left} y1={margin.top + chartHeight / 2} x2={margin.left + chartWidth} y2={margin.top + chartHeight / 2} stroke="rgba(255,255,255,0.05)" strokeWidth="0.5" />
                                            <line x1={margin.left} y1={margin.top + chartHeight} x2={margin.left + chartWidth} y2={margin.top + chartHeight} stroke="rgba(255,255,255,0.1)" strokeWidth="0.5" />

                                            {marketSegments.map((path, i) => (
                                              <path key={i} d={path} fill={areaColor} vectorEffect="non-scaling-stroke" />
                                            ))}

                                            <polyline points={points} fill="none" stroke={lineColor} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" vectorEffect="non-scaling-stroke" />

                                            {stockData.filter((_, i) => i % Math.max(1, Math.floor(stockData.length / 30)) === 0).map((d, i) => {
                                              const idx = i * Math.max(1, Math.floor(stockData.length / 30));
                                              return <circle key={i} cx={xScale(idx)} cy={yScale(d.price)} r="2" fill={lineColor} opacity="0.8" vectorEffect="non-scaling-stroke" />;
                                            })}

                                            <text x={width - 3} y={margin.top + 10} fill="#ff9500" fontSize="13" fontWeight="600" textAnchor="end">${maxPrice.toFixed(2)}</text>
                                            <text x={width - 3} y={margin.top + chartHeight / 2 + 3} fill="white" fontSize="12" textAnchor="end">${midPrice.toFixed(2)}</text>
                                            <text x={width - 3} y={margin.top + chartHeight - 3} fill="white" fontSize="12" textAnchor="end">${minPrice.toFixed(2)}</text>

                                            <text x={margin.left} y={height - 5} fill="white" fontSize="13" textAnchor="start">{formatTime(firstTime, 'start')}</text>
                                            <text x={margin.left + chartWidth / 2} y={height - 5} fill="white" fontSize="13" textAnchor="middle">{formatTime(midTime, 'mid')}</text>
                                            <text x={margin.left + chartWidth} y={height - 5} fill="white" fontSize="13" textAnchor="end">{formatTime(lastTime, 'end')}</text>
                                          </g>
                                        );
                                      })()}
                                    </svg>
                                  ) : (
                                    <div className="flex items-center justify-center h-full text-gray-600 text-sm">Loading...</div>
                                  )}
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              );
            })()}
          </div>
        )}
      </div>
    );
  };

  // Enhanced Market Regimes Panel Component with advanced analytics
  const RegimesPanel = ({ activeTab, setActiveTab, highlightFilter, setHighlightFilter }: {
    activeTab: string,
    setActiveTab: (tab: string) => void,
    highlightFilter: 'all' | 'gold' | 'purple' | 'highlights',
    setHighlightFilter: (filter: 'all' | 'gold' | 'purple' | 'highlights') => void
  }) => {

    const getCurrentTimeframeData = useCallback(() => {
      if (!marketRegimeData) {
        return null;
      }

      let data;
      switch (activeTab.toLowerCase()) {
        case 'life':
          data = marketRegimeData.life;
          break;
        case 'developing':
          data = marketRegimeData.developing;
          break;
        case 'momentum':
          data = marketRegimeData.momentum;
          break;
        case 'legacy':
          data = marketRegimeData.legacy;
          break;
        default:
          data = marketRegimeData.life;
      }

      return data;
    }, [marketRegimeData, activeTab]);

    const timeframeData = getCurrentTimeframeData();
    const bullishIndustries = useMemo(() =>
      timeframeData?.industries?.filter((industry: any) => industry.trend === 'bullish').slice(0, 20) || []
      , [timeframeData]);
    const bearishIndustries = useMemo(() =>
      timeframeData?.industries?.filter((industry: any) => industry.trend === 'bearish').slice(0, 20) || []
      , [timeframeData]);

    // Memoize filtered and sorted trades to prevent re-computation on every render
    const { filteredBullishTrades, filteredBearishTrades } = useMemo(() => {
      const allTabsHighlights: Array<[string, any]> = [];
      Object.keys(highlightedTradesCache).forEach(tab => {
        Object.entries(highlightedTradesCache[tab] || {}).forEach(([symbol, trade]) => {
          allTabsHighlights.push([symbol, trade]);
        });
      });

      const bullish = allTabsHighlights.filter(([symbol, trade]: [string, any]) => {
        const matchesFilter = highlightFilter === 'gold' ? (trade.highlightType === 'gold' || trade.highlightType === 'blue') :
          highlightFilter === 'purple' ? (trade.highlightType === 'purple' || trade.highlightType === 'pink') :
            highlightFilter === 'highlights' ? (trade.highlightType === 'gold' || trade.highlightType === 'purple' || trade.highlightType === 'blue' || trade.highlightType === 'pink') : true;
        return matchesFilter && trade.optionType?.toLowerCase() === 'call';
      }).sort((a, b) => {
        const scoreA = a[1].score || 0;
        const scoreB = b[1].score || 0;
        return sortByPercentage ? scoreB - scoreA : scoreA - scoreB;
      });

      const bearish = allTabsHighlights.filter(([symbol, trade]: [string, any]) => {
        const matchesFilter = highlightFilter === 'gold' ? (trade.highlightType === 'gold' || trade.highlightType === 'blue') :
          highlightFilter === 'purple' ? (trade.highlightType === 'purple' || trade.highlightType === 'pink') :
            highlightFilter === 'highlights' ? (trade.highlightType === 'gold' || trade.highlightType === 'purple' || trade.highlightType === 'blue' || trade.highlightType === 'pink') : true;
        return matchesFilter && trade.optionType?.toLowerCase() === 'put';
      }).sort((a, b) => {
        const scoreA = a[1].score || 0;
        const scoreB = b[1].score || 0;
        return sortByPercentage ? scoreB - scoreA : scoreA - scoreB;
      });

      return { filteredBullishTrades: bullish, filteredBearishTrades: bearish };
    }, [highlightedTradesCache, highlightFilter, sortByPercentage]);

    // Preserve scroll position on re-renders
    useLayoutEffect(() => {
      const scrollContainer = regimesPanelScrollRef.current;
      if (scrollContainer && savedRegimesScrollPos.current > 0) {
        scrollContainer.scrollTop = savedRegimesScrollPos.current;
      }
    });

    // Save scroll position before any updates
    const handleScroll = useCallback(() => {
      if (regimesPanelScrollRef.current) {
        savedRegimesScrollPos.current = regimesPanelScrollRef.current.scrollTop;
      }
    }, []);

    return (
      <>
        <div
          ref={regimesPanelScrollRef}
          onScroll={handleScroll}
          className="h-screen overflow-auto"
          style={{
            background: '#000000',
            borderBottom: '2px solid rgba(255, 102, 0, 0.4)',
            boxShadow: '0 4px 20px rgba(0, 0, 0, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.05)'
          }}>
          {/* Premium Title Section */}
          <div className="px-6 py-6 relative overflow-hidden">
            {/* Background Ambient Glow */}
            <div className="absolute inset-0 opacity-30" style={{
              background: 'radial-gradient(ellipse at top, rgba(255, 102, 0, 0.1) 0%, transparent 70%)'
            }} />
            <div className="absolute inset-0 opacity-20" style={{
              background: 'linear-gradient(90deg, transparent 0%, rgba(255, 102, 0, 0.05) 50%, transparent 100%)'
            }} />

            {/* Close button */}
            <button
              onClick={() => setActiveSidebarPanel(null)}
              className="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors z-50"
              aria-label="Close panel"
            >
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>

            <div className="relative z-10 flex items-center justify-center">
              <div className="text-center">
                <h1 className="text-2xl md:text-4xl font-bold tracking-wider uppercase" style={{
                  fontFamily: '"JetBrains Mono", monospace',
                  background: 'linear-gradient(135deg, #ffffff 0%, #ffcc80 25%, #ff9800 50%, #ffcc80 75%, #ffffff 100%)',
                  WebkitBackgroundClip: 'text',
                  WebkitTextFillColor: 'transparent',
                  textShadow: '0 2px 10px rgba(255, 152, 0, 0.3)',
                  filter: 'drop-shadow(0 1px 2px rgba(0, 0, 0, 0.8))',
                  fontSize: window.innerWidth < 768 ? '2.4375rem' : undefined,
                  marginBottom: window.innerWidth < 768 ? '0px' : undefined
                }}>
                  Market Regimes
                </h1>
              </div>
            </div>
          </div>

          {/* Abstract Hexagonal Tab Navigation */}
          <div className="px-6 pb-3" style={{
            marginTop: window.innerWidth < 768 ? '-12px' : '-16px'
          }}>
            <div className="grid grid-cols-4 gap-3" style={{
              position: 'relative'
            }}>
              {['Weekly', 'Monthly', 'Quarterly', 'Leap'].map((tab, index) => {
                const tabConfig = {
                  'Weekly': {
                    gradient: 'linear-gradient(135deg, #10b981 0%, #059669 50%, #047857 100%)',
                    glow: 'rgba(16, 185, 129, 0.4)',
                    border: '#10b981',
                    color: '#10b981',
                    originalTab: 'Life'
                  },
                  'Monthly': {
                    gradient: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 50%, #1d4ed8 100%)',
                    glow: 'rgba(59, 130, 246, 0.4)',
                    border: '#3b82f6',
                    color: '#3b82f6',
                    originalTab: 'Developing'
                  },
                  'Quarterly': {
                    gradient: 'linear-gradient(135deg, #a855f7 0%, #9333ea 50%, #7e22ce 100%)',
                    glow: 'rgba(168, 85, 247, 0.4)',
                    border: '#a855f7',
                    color: '#a855f7',
                    originalTab: 'Momentum'
                  },
                  'Leap': {
                    gradient: 'linear-gradient(135deg, #f59e0b 0%, #d97706 50%, #b45309 100%)',
                    glow: 'rgba(245, 158, 11, 0.4)',
                    border: '#f59e0b',
                    color: '#f59e0b',
                    originalTab: 'Legacy'
                  }
                };
                const config = tabConfig[tab as keyof typeof tabConfig];
                const isMobile = window.innerWidth < 768;
                const isActive = activeTab === config.originalTab;

                return (
                  <button
                    key={tab}
                    onClick={() => setActiveTab(config.originalTab)}
                    className="relative overflow-hidden transition-all duration-500 group"
                    style={{
                      padding: isMobile ? '10px 6px' : '16px 12px',
                      background: isActive
                        ? `linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 10, 0.98) 50%, rgba(0, 0, 0, 0.95) 100%)`
                        : 'linear-gradient(135deg, rgba(15, 15, 15, 0.8) 0%, rgba(5, 5, 5, 0.95) 100%)',
                      backdropFilter: 'blur(10px)',
                      border: isActive
                        ? `2px solid ${config.border}`
                        : '2px solid rgba(40, 40, 40, 0.5)',
                      borderRadius: '0px',
                      clipPath: 'polygon(0 0, 95% 0, 100% 100%, 5% 100%)',
                      boxShadow: isActive
                        ? `0 8px 25px ${config.glow}, 
                           0 15px 45px rgba(0, 0, 0, 0.9),
                           inset 0 3px 15px ${config.glow},
                           inset 0 1px 0 rgba(255, 255, 255, 0.4),
                           inset 0 -2px 8px rgba(0, 0, 0, 0.8)`
                        : `0 4px 12px rgba(0, 0, 0, 0.8), 
                           0 8px 20px rgba(0, 0, 0, 0.5),
                           inset 0 1px 0 rgba(255, 255, 255, 0.05),
                           inset 0 -1px 3px rgba(0, 0, 0, 0.6)`,
                      transform: isActive ? 'scale(1.05) translateY(-6px) perspective(1000px) rotateX(2deg)' : 'scale(1) perspective(1000px)',
                      cursor: 'pointer',
                      position: 'relative',
                      transformStyle: 'preserve-3d'
                    }}
                  >
                    {/* Glossy top highlight - stronger for 4D effect */}
                    <div className="absolute top-0 left-0 right-0 h-1" style={{
                      background: 'linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.5) 50%, transparent 100%)',
                      opacity: isActive ? 1 : 0.2,
                      filter: 'blur(1px)'
                    }} />

                    {/* Bottom shadow for depth */}
                    <div className="absolute bottom-0 left-0 right-0 h-2" style={{
                      background: 'linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.6) 100%)',
                      opacity: isActive ? 0.8 : 0.3
                    }} />

                    {/* Side edge highlight for 3D depth */}
                    <div className="absolute top-0 right-0 w-px h-full" style={{
                      background: `linear-gradient(180deg, ${config.border} 0%, transparent 100%)`,
                      opacity: isActive ? 0.6 : 0
                    }} />

                    {/* Geometric accent line */}
                    <div className="absolute top-0 left-0 right-0 h-0.5" style={{
                      background: isActive ? `linear-gradient(90deg, transparent, ${config.border}, transparent)` : 'transparent',
                      opacity: isActive ? 1 : 0,
                      transition: 'opacity 0.3s'
                    }} />

                    <div className="relative z-10 flex flex-col items-center justify-center">
                      <div className="font-black tracking-wider" style={{
                        fontSize: isMobile ? '0.85rem' : '1.1rem',
                        color: isActive ? config.color : '#ffffff',
                        textShadow: 'none',
                        letterSpacing: '0.1em',
                        fontFamily: 'system-ui, -apple-system, sans-serif'
                      }}>
                        {tab.toUpperCase()}
                      </div>
                    </div>

                  </button>
                );
              })}
            </div>
          </div>

          {/* Abstract Filter Control Panel */}
          <div className="px-6 pb-6">
            <div className="relative" style={{
              background: 'linear-gradient(135deg, rgba(20, 20, 20, 0.4) 0%, rgba(10, 10, 10, 0.6) 100%)',
              backdropFilter: 'blur(20px)',
              border: '1px solid rgba(255, 255, 255, 0.05)',
              borderRadius: '16px',
              padding: '16px',
              boxShadow: '0 8px 32px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.03)'
            }}>
              {/* Decorative corner accents */}
              <div className="absolute top-0 left-0 w-12 h-12" style={{
                background: 'linear-gradient(135deg, rgba(255, 102, 0, 0.15) 0%, transparent 100%)',
                borderRadius: '16px 0 0 0'
              }} />
              <div className="absolute bottom-0 right-0 w-12 h-12" style={{
                background: 'linear-gradient(-45deg, rgba(255, 102, 0, 0.15) 0%, transparent 100%)',
                borderRadius: '0 0 16px 0'
              }} />

              <div className="grid grid-cols-1 md:grid-cols-4 gap-3 relative z-10">
                <button
                  onClick={() => setHighlightFilter('all')}
                  className="group relative overflow-hidden transition-all duration-300"
                  style={{
                    padding: '12px 20px',
                    background: highlightFilter === 'all'
                      ? 'linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 10, 0.98) 50%, rgba(0, 0, 0, 0.95) 100%)'
                      : 'linear-gradient(135deg, rgba(30, 30, 30, 0.6) 0%, rgba(15, 15, 15, 0.8) 100%)',
                    border: highlightFilter === 'all' ? '2px solid #ff6600' : '2px solid rgba(60, 60, 60, 0.4)',
                    borderRadius: '10px',
                    boxShadow: highlightFilter === 'all'
                      ? '0 8px 25px rgba(255, 102, 0, 0.5), 0 15px 45px rgba(0, 0, 0, 0.9), inset 0 3px 15px rgba(255, 102, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.4), inset 0 -2px 8px rgba(0, 0, 0, 0.8)'
                      : '0 4px 10px rgba(0, 0, 0, 0.3), 0 8px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.05), inset 0 -1px 3px rgba(0, 0, 0, 0.6)',
                    transform: highlightFilter === 'all' ? 'scale(1.02) translateY(-6px) perspective(1000px) rotateX(2deg)' : 'scale(1) perspective(1000px)',
                    clipPath: 'polygon(8% 0%, 100% 0%, 92% 100%, 0% 100%)',
                    transformStyle: 'preserve-3d'
                  }}
                >
                  {/* Glossy top highlight */}
                  <div className="absolute top-0 left-0 right-0 h-1" style={{
                    background: 'linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.5) 50%, transparent 100%)',
                    opacity: highlightFilter === 'all' ? 1 : 0.2,
                    filter: 'blur(1px)'
                  }} />
                  {/* Bottom shadow */}
                  <div className="absolute bottom-0 left-0 right-0 h-2" style={{
                    background: 'linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.6) 100%)',
                    opacity: highlightFilter === 'all' ? 0.8 : 0.3
                  }} />
                  {/* Side edge */}
                  <div className="absolute top-0 right-0 w-px h-full" style={{
                    background: 'linear-gradient(180deg, #ff6600 0%, transparent 100%)',
                    opacity: highlightFilter === 'all' ? 0.6 : 0
                  }} />
                  <div className="flex items-center justify-center gap-2 relative z-10">
                    <TbFilter size={18} style={{
                      color: highlightFilter === 'all' ? '#ff6600' : '#ffffff'
                    }} />
                    <span className="font-black text-sm tracking-widest" style={{
                      color: highlightFilter === 'all' ? '#ff6600' : '#ffffff',
                      textShadow: 'none',
                      fontFamily: 'system-ui, -apple-system, sans-serif'
                    }}>
                      ALL
                    </span>
                  </div>
                </button>

                <button
                  onClick={() => setHighlightFilter('gold')}
                  className="group relative overflow-hidden transition-all duration-300"
                  style={{
                    padding: '12px 20px',
                    background: highlightFilter === 'gold'
                      ? 'linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 10, 0.98) 50%, rgba(0, 0, 0, 0.95) 100%)'
                      : 'linear-gradient(135deg, rgba(30, 30, 30, 0.6) 0%, rgba(15, 15, 15, 0.8) 100%)',
                    border: highlightFilter === 'gold' ? '2px solid #FFD700' : '2px solid rgba(255, 215, 0, 0.2)',
                    borderRadius: '10px',
                    boxShadow: highlightFilter === 'gold'
                      ? '0 8px 25px rgba(255, 215, 0, 0.5), 0 15px 45px rgba(0, 0, 0, 0.9), inset 0 3px 15px rgba(255, 215, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.4), inset 0 -2px 8px rgba(0, 0, 0, 0.8)'
                      : '0 4px 10px rgba(0, 0, 0, 0.3), 0 8px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.05), inset 0 -1px 3px rgba(0, 0, 0, 0.6)',
                    transform: highlightFilter === 'gold' ? 'scale(1.02) translateY(-6px) perspective(1000px) rotateX(2deg)' : 'scale(1) perspective(1000px)',
                    clipPath: 'polygon(8% 0%, 100% 0%, 92% 100%, 0% 100%)',
                    transformStyle: 'preserve-3d'
                  }}
                >
                  {/* Glossy top highlight */}
                  <div className="absolute top-0 left-0 right-0 h-1" style={{
                    background: 'linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.5) 50%, transparent 100%)',
                    opacity: highlightFilter === 'gold' ? 1 : 0.2,
                    filter: 'blur(1px)'
                  }} />
                  {/* Bottom shadow */}
                  <div className="absolute bottom-0 left-0 right-0 h-2" style={{
                    background: 'linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.6) 100%)',
                    opacity: highlightFilter === 'gold' ? 0.8 : 0.3
                  }} />
                  {/* Side edge */}
                  <div className="absolute top-0 right-0 w-px h-full" style={{
                    background: 'linear-gradient(180deg, #FFD700 0%, transparent 100%)',
                    opacity: highlightFilter === 'gold' ? 0.6 : 0
                  }} />
                  <div className="flex items-center justify-center gap-2 relative z-10">
                    <TbTrendingUp size={18} style={{
                      color: highlightFilter === 'gold' ? '#FFD700' : '#ffffff'
                    }} />
                    <span className="font-black text-sm tracking-widest" style={{
                      color: highlightFilter === 'gold' ? '#FFD700' : '#ffffff',
                      textShadow: 'none',
                      fontFamily: 'system-ui, -apple-system, sans-serif'
                    }}>
                      {window.innerWidth < 768 ? 'BEST' : 'BEST PERFORMERS'}
                    </span>
                  </div>
                </button>

                <button
                  onClick={() => setHighlightFilter('purple')}
                  className="group relative overflow-hidden transition-all duration-300"
                  style={{
                    padding: '12px 20px',
                    background: highlightFilter === 'purple'
                      ? 'linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 10, 0.98) 50%, rgba(0, 0, 0, 0.95) 100%)'
                      : 'linear-gradient(135deg, rgba(30, 30, 30, 0.6) 0%, rgba(15, 15, 15, 0.8) 100%)',
                    border: highlightFilter === 'purple' ? '2px solid #8A2BE2' : '2px solid rgba(138, 43, 226, 0.2)',
                    borderRadius: '10px',
                    boxShadow: highlightFilter === 'purple'
                      ? '0 8px 25px rgba(138, 43, 226, 0.5), 0 15px 45px rgba(0, 0, 0, 0.9), inset 0 3px 15px rgba(138, 43, 226, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.4), inset 0 -2px 8px rgba(0, 0, 0, 0.8)'
                      : '0 4px 10px rgba(0, 0, 0, 0.3), 0 8px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.05), inset 0 -1px 3px rgba(0, 0, 0, 0.6)',
                    transform: highlightFilter === 'purple' ? 'scale(1.02) translateY(-6px) perspective(1000px) rotateX(2deg)' : 'scale(1) perspective(1000px)',
                    clipPath: 'polygon(8% 0%, 100% 0%, 92% 100%, 0% 100%)',
                    transformStyle: 'preserve-3d'
                  }}
                >
                  {/* Glossy top highlight */}
                  <div className="absolute top-0 left-0 right-0 h-1" style={{
                    background: 'linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.5) 50%, transparent 100%)',
                    opacity: highlightFilter === 'purple' ? 1 : 0.2,
                    filter: 'blur(1px)'
                  }} />
                  {/* Bottom shadow */}
                  <div className="absolute bottom-0 left-0 right-0 h-2" style={{
                    background: 'linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.6) 100%)',
                    opacity: highlightFilter === 'purple' ? 0.8 : 0.3
                  }} />
                  {/* Side edge */}
                  <div className="absolute top-0 right-0 w-px h-full" style={{
                    background: 'linear-gradient(180deg, #8A2BE2 0%, transparent 100%)',
                    opacity: highlightFilter === 'purple' ? 0.6 : 0
                  }} />
                  <div className="flex items-center justify-center gap-2 relative z-10">
                    <TbChartBar size={18} style={{
                      color: highlightFilter === 'purple' ? '#8A2BE2' : '#ffffff'
                    }} />
                    <span className="font-black text-sm tracking-widest" style={{
                      color: highlightFilter === 'purple' ? '#8A2BE2' : '#ffffff',
                      textShadow: 'none',
                      fontFamily: 'system-ui, -apple-system, sans-serif'
                    }}>
                      {window.innerWidth < 768 ? 'PICKS' : 'INDUSTRY PICKS'}
                    </span>
                  </div>
                </button>

                <button
                  onClick={() => setHighlightFilter('highlights')}
                  className="group relative overflow-hidden transition-all duration-300"
                  style={{
                    padding: '12px 20px',
                    background: highlightFilter === 'highlights'
                      ? 'linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 10, 0.98) 50%, rgba(0, 0, 0, 0.95) 100%)'
                      : 'linear-gradient(135deg, rgba(30, 30, 30, 0.6) 0%, rgba(15, 15, 15, 0.8) 100%)',
                    border: highlightFilter === 'highlights' ? '2px solid #CD7F32' : '2px solid rgba(205, 127, 50, 0.2)',
                    borderRadius: '10px',
                    boxShadow: highlightFilter === 'highlights'
                      ? '0 8px 25px rgba(205, 127, 50, 0.5), 0 15px 45px rgba(0, 0, 0, 0.9), inset 0 3px 15px rgba(205, 127, 50, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.4), inset 0 -2px 8px rgba(0, 0, 0, 0.8)'
                      : '0 4px 10px rgba(0, 0, 0, 0.3), 0 8px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.05), inset 0 -1px 3px rgba(0, 0, 0, 0.6)',
                    transform: highlightFilter === 'highlights' ? 'scale(1.02) translateY(-6px) perspective(1000px) rotateX(2deg)' : 'scale(1) perspective(1000px)',
                    clipPath: 'polygon(8% 0%, 100% 0%, 92% 100%, 0% 100%)',
                    transformStyle: 'preserve-3d'
                  }}
                >
                  {/* Glossy top highlight */}
                  <div className="absolute top-0 left-0 right-0 h-1" style={{
                    background: 'linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.5) 50%, transparent 100%)',
                    opacity: highlightFilter === 'highlights' ? 1 : 0.2,
                    filter: 'blur(1px)'
                  }} />
                  {/* Bottom shadow */}
                  <div className="absolute bottom-0 left-0 right-0 h-2" style={{
                    background: 'linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.6) 100%)',
                    opacity: highlightFilter === 'highlights' ? 0.8 : 0.3
                  }} />
                  {/* Side edge */}
                  <div className="absolute top-0 right-0 w-px h-full" style={{
                    background: 'linear-gradient(180deg, #CD7F32 0%, transparent 100%)',
                    opacity: highlightFilter === 'highlights' ? 0.6 : 0
                  }} />
                  <div className="flex items-center justify-center gap-2 relative z-10">
                    <TbStarFilled size={18} style={{
                      color: highlightFilter === 'highlights' ? '#CD7F32' : '#ffffff'
                    }} />
                    <span className="font-black text-sm tracking-widest" style={{
                      color: highlightFilter === 'highlights' ? '#CD7F32' : '#ffffff',
                      textShadow: 'none',
                      fontFamily: 'system-ui, -apple-system, sans-serif'
                    }}>
                      {window.innerWidth < 768 ? 'HIGHLIGHTS' : 'KEY HIGHLIGHTS'}
                    </span>
                  </div>
                </button>
              </div>
            </div>
          </div>

          {/* Premium Progress Bar */}
          {isLoadingRegimes && (
            <div className="w-full h-1 relative overflow-hidden" style={{
              background: 'linear-gradient(90deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%)'
            }}>
              <div
                className="h-full transition-all duration-500 ease-out relative"
                style={{
                  width: `${regimeUpdateProgress}%`,
                  background: 'linear-gradient(90deg, #ff6600 0%, #ff9800 50%, #ffcc80 100%)',
                  boxShadow: '0 0 10px rgba(255, 102, 0, 0.6)'
                }}
              >
                <div className="absolute inset-0 animate-pulse" style={{
                  background: 'linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%)'
                }} />
              </div>
            </div>
          )}

          {/* Premium Content Area */}
          <div className="flex-1 overflow-hidden">
            {isLoadingRegimes && !marketRegimeData ? (
              <div className="flex flex-col items-center justify-center h-full space-y-6 p-8">
                <div className="relative">
                  <div className="w-12 h-12 border-2 border-orange-500 border-t-transparent rounded-full animate-spin" style={{
                    boxShadow: '0 0 20px rgba(255, 152, 0, 0.3)'
                  }}></div>
                  <div className="absolute inset-0 w-12 h-12 border border-orange-300 border-opacity-20 rounded-full animate-ping"></div>
                </div>
                <div className="text-center font-mono">
                  <div className="text-white text-lg font-bold mb-2">{regimeLoadingStage}</div>
                  <div className="text-orange-400 text-sm mb-1">{regimeUpdateProgress}% complete</div>
                  <div className="text-gray-500 text-xs">Analyzing market momentum...</div>
                </div>
              </div>
            ) : !marketRegimeData ? (
              <div className="flex flex-col items-center justify-center h-full space-y-6 p-8">
                <div className="text-4xl mb-4">??</div>
                <div className="text-center font-mono">
                  <div className="text-white text-xl font-bold mb-2">Market Regime Analysis</div>
                  <div className="text-orange-400 text-sm">Initializing premium analytics...</div>
                </div>
              </div>
            ) : (
              <div className="h-full overflow-y-auto" style={{
                background: 'linear-gradient(180deg, #000000 0%, #0a0a0a 50%, #000000 100%)'
              }}>
                {/* Premium Streaming Indicator */}
                {isLoadingRegimes && (
                  <div className="mx-6 mt-4 p-3 rounded-lg" style={{
                    background: 'linear-gradient(135deg, rgba(255, 102, 0, 0.1) 0%, rgba(255, 152, 0, 0.05) 100%)',
                    border: '1px solid rgba(255, 102, 0, 0.3)',
                    boxShadow: 'inset 0 1px 0 rgba(255, 255, 255, 0.1)'
                  }}>
                    <div className="flex items-center space-x-3">
                      <div className="w-3 h-3 bg-orange-400 rounded-full animate-pulse" style={{
                        boxShadow: '0 0 8px rgba(255, 152, 0, 0.8)'
                      }} />
                      <span className="text-orange-300 font-mono text-sm font-medium">
                        {regimeLoadingStage} ({regimeUpdateProgress}%)
                      </span>
                    </div>
                  </div>
                )}

                {/* Conditional Rendering: Highlights View or Industry Grid */}
                {highlightFilter !== 'all' ? (
                  <div className="px-6 pb-6">
                    {/* Sort Button */}
                    <div className="flex justify-center mb-6">
                      <button
                        onClick={() => setSortByPercentage(!sortByPercentage)}
                        className="px-4 py-2 font-mono font-bold uppercase tracking-wider transition-all duration-200 flex items-center gap-2 text-xs"
                        style={{
                          background: '#000000',
                          color: '#ff6600',
                          border: '2px solid #ff6600',
                          borderRadius: '8px',
                          boxShadow: 'inset 2px 2px 5px rgba(0, 0, 0, 0.8), inset -2px -2px 5px rgba(30, 30, 30, 0.4), 3px 3px 8px rgba(0, 0, 0, 0.9), -1px -1px 4px rgba(40, 40, 40, 0.2)'
                        }}
                      >
                        <TbArrowsSort size={16} /> {sortByPercentage ? 'Highest % First' : 'Lowest % First'}
                      </button>
                    </div>

                    {/* Conditional Layout - Best Performers: 1+1 | Others: 2+2 = 4 columns */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                      {/* Bullish Section */}
                      <div>
                        <div className="mb-6 pb-3 border-b relative overflow-hidden" style={{
                          borderColor: '#10b981',
                          background: 'linear-gradient(90deg, rgba(16, 185, 129, 0.15) 0%, transparent 50%, rgba(16, 185, 129, 0.15) 100%)'
                        }}>
                          <div className="flex items-center justify-center gap-3 py-3">
                            <div className="w-px h-6 bg-gradient-to-b from-transparent via-green-400 to-transparent" />
                            <h3 className="font-black uppercase tracking-widest flex items-center gap-2" style={{
                              fontSize: '1.1rem',
                              color: '#00ff00',
                              fontFamily: 'system-ui, -apple-system, sans-serif',
                              letterSpacing: '0.15em'
                            }}>
                              <TbTrendingUp size={20} /> BULLISH
                            </h3>
                            <div className="w-px h-6 bg-gradient-to-b from-transparent via-green-400 to-transparent" />
                          </div>
                        </div>
                        <div className="space-y-4">
                          {filteredBullishTrades.map(([symbol, trade]: [string, any], idx) => {
                            const isGold = trade.highlightType === 'gold';
                            const isPurple = trade.highlightType === 'purple';
                            const isBlue = trade.highlightType === 'blue';
                            const isPink = trade.highlightType === 'pink';

                            const tickerColor = isGold ? '#FFD700' :
                              isPurple ? '#8A2BE2' :
                                isBlue ? '#1E90FF' :
                                  isPink ? '#FF69B4' : '#ffffff';
                            const uniqueKey = `${symbol}-${trade.sourceTab}-${idx}`;

                            // Get tab label and color from trade's sourceTab
                            const tradeTab = trade.sourceTab;
                            if (!tradeTab) {
                              console.log(`âš ï¸ WARNING: Bullish ${symbol} missing sourceTab:`, trade);
                            }
                            const tabColor = tradeTab === 'life' ? '#10b981' :
                              tradeTab === 'developing' ? '#3b82f6' :
                                tradeTab === 'momentum' ? '#a855f7' : '#f59e0b';

                            // Determine card styling based on highlight type
                            let cardBorder = '1px solid rgba(16, 185, 129, 0.3)';
                            let cardShadow = '0 2px 8px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(16, 185, 129, 0.1)';

                            if (isGold) {
                              cardBorder = '2px solid rgba(255, 215, 0, 0.6)';
                              cardShadow = '0 4px 12px rgba(255, 215, 0, 0.4), inset 0 1px 0 rgba(255, 215, 0, 0.2)';
                            } else if (isPurple) {
                              cardBorder = '2px solid rgba(138, 43, 226, 0.6)';
                              cardShadow = '0 4px 12px rgba(138, 43, 226, 0.4), inset 0 1px 0 rgba(138, 43, 226, 0.2)';
                            } else if (isBlue) {
                              cardBorder = '2px solid rgba(30, 144, 255, 0.6)';
                              cardShadow = '0 4px 12px rgba(30, 144, 255, 0.4), inset 0 1px 0 rgba(30, 144, 255, 0.2)';
                            } else if (isPink) {
                              cardBorder = '2px solid rgba(255, 105, 180, 0.6)';
                              cardShadow = '0 4px 12px rgba(255, 105, 180, 0.4), inset 0 1px 0 rgba(255, 105, 180, 0.2)';
                            }

                            return (
                              <div
                                key={uniqueKey}
                                className="group relative overflow-hidden transition-all duration-200 hover:scale-[1.02] cursor-pointer"
                                style={{
                                  background: 'linear-gradient(135deg, #000000 0%, #0a0a0a 100%)',
                                  border: cardBorder,
                                  borderRadius: '8px',
                                  boxShadow: cardShadow
                                }}
                                onClick={() => {
                                  setSelectedTradeForModal(trade);
                                  setShowTradeModal(true);
                                }}
                              >
                                <div className="relative p-4">
                                  {/* Horizontal Header: Timeframe | Symbol | Score */}
                                  <div className="flex items-center gap-3 mb-3">
                                    {/* Timeframe indicator - vertical colored bar */}
                                    <div className="flex items-center gap-2">
                                      <div className="w-1 h-8 rounded-full" style={{ background: tabColor }} />
                                      <div className="flex flex-col">
                                        <div className="text-xs font-bold uppercase tracking-wide" style={{ color: tabColor }}>
                                          {tradeTab === 'life' ? 'Weekly' : tradeTab === 'developing' ? 'Monthly' : tradeTab === 'momentum' ? 'Quarterly' : 'Leap'}
                                        </div>
                                        <div className="text-[0.65rem] font-medium uppercase tracking-wide" style={{
                                          color: '#ffffff',
                                          marginTop: '2px'
                                        }}>
                                          {isBlue || isPink ? 'Momentum' : 'Quality'}
                                        </div>
                                      </div>
                                    </div>

                                    {/* Symbol in center */}
                                    <div className="flex-1 text-center flex items-center justify-center gap-2">
                                      <span className="font-black tracking-tight" style={{
                                        fontSize: '1.5rem',
                                        background: isGold ? 'linear-gradient(135deg, #FFD700, #FFA500)' :
                                          isBlue ? 'linear-gradient(135deg, #1E90FF, #4169E1)' :
                                            isPink ? 'linear-gradient(135deg, #FF69B4, #FF1493)' :
                                              'linear-gradient(135deg, #A855F7, #D946EF)',
                                        WebkitBackgroundClip: 'text',
                                        WebkitTextFillColor: 'transparent',
                                        fontFamily: 'system-ui, -apple-system, sans-serif',
                                        display: 'inline-block'
                                      }}>
                                        {symbol}
                                      </span>
                                    </div>

                                    {/* Score and Watchlist Button */}
                                    <div className="flex items-center gap-2">
                                      <span className="font-black tabular-nums" style={{
                                        fontSize: '1.5rem',
                                        color: '#00ff00',
                                        fontFamily: 'system-ui, -apple-system, sans-serif',
                                        opacity: 1
                                      }}>
                                        {Math.round(trade.score)}
                                      </span>
                                      <button
                                        onClick={(e) => {
                                          e.stopPropagation();
                                          if (trade && trade.strike && trade.expiration && trade.contractPrice) {
                                            // Get current stock price - use strike if stockPrice not available
                                            let currentStockPrice = trade.stockPrice;
                                            if (!currentStockPrice || currentStockPrice === 0) {
                                              currentStockPrice = trade.strike;
                                            }

                                            // Calculate targets using Black-Scholes expected move
                                            const expiryDate = new Date(trade.expiration);
                                            const now = new Date();
                                            const daysToExpiry = Math.max(1, Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));
                                            const T = daysToExpiry / 365;
                                            const sigma = (trade.impliedVolatility || 50) / 100;
                                            const isCall = trade.optionType?.toLowerCase() === 'call';

                                            let target80StockPrice = 0;
                                            let target90StockPrice = 0;

                                            if (T > 0 && sigma > 0 && currentStockPrice > 0) {
                                              if (isCall) {
                                                const expectedMove1SD = currentStockPrice * sigma * Math.sqrt(T);
                                                target80StockPrice = currentStockPrice + (expectedMove1SD * 0.84);
                                                target90StockPrice = currentStockPrice + (expectedMove1SD * 1.28);
                                              } else {
                                                const expectedMove1SD = currentStockPrice * sigma * Math.sqrt(T);
                                                target80StockPrice = currentStockPrice - (expectedMove1SD * 0.84);
                                                target90StockPrice = currentStockPrice - (expectedMove1SD * 1.28);
                                              }
                                            }

                                            const watchlistItem = {
                                              id: `${symbol}-${trade.strike}-${trade.expiration}-${Date.now()}`,
                                              ticker: trade.optionTicker || `${symbol}${new Date(trade.expiration).toLocaleDateString('en-US', { year: '2-digit', month: '2-digit', day: '2-digit' }).replace(/\//g, '')}${trade.optionType === 'call' ? 'C' : 'P'}${trade.strike}`,
                                              symbol: symbol,
                                              strike: trade.strike,
                                              type: trade.optionType?.toLowerCase() || 'call',
                                              contract_type: trade.optionType?.toLowerCase() || 'call',
                                              expiration: trade.expiration,
                                              bid: trade.contractPrice * 0.98,
                                              ask: trade.contractPrice * 1.02,
                                              lastPrice: trade.contractPrice,
                                              last_price: trade.contractPrice,
                                              delta: trade.delta || 0,
                                              theta: trade.thetaDecay ? -Math.abs(trade.thetaDecay) : 0,
                                              implied_volatility: trade.impliedVolatility || 0,
                                              strike_price: trade.strike,
                                              expiration_date: trade.expiration,
                                              addedAt: new Date(),
                                              entryPrice: trade.contractPrice,
                                              stockPrice: currentStockPrice,
                                              stockTarget80: target80StockPrice,
                                              stockTarget90: target90StockPrice,
                                              stopLoss: trade.contractPrice * 0.75
                                            };
                                            const saved = localStorage.getItem('optionsWatchlist');
                                            const existing = saved ? JSON.parse(saved) : [];
                                            const alreadyExists = existing.some((item: any) =>
                                              item.symbol === watchlistItem.symbol &&
                                              item.strike === watchlistItem.strike &&
                                              item.expiration === watchlistItem.expiration
                                            );
                                            if (!alreadyExists) {
                                              localStorage.setItem('optionsWatchlist', JSON.stringify([...existing, watchlistItem]));
                                              setHighlightFilter(highlightFilter);
                                            }
                                          }
                                        }}
                                        className="hover:scale-110 transition-transform"
                                        title="Add to Watchlist"
                                      >
                                        {(() => {
                                          const saved = localStorage.getItem('optionsWatchlist');
                                          const existing = saved ? JSON.parse(saved) : [];
                                          const isInWatchlist = existing.some((item: any) =>
                                            item.symbol === symbol &&
                                            item.strike === trade.strike &&
                                            item.expiration === trade.expiration
                                          );
                                          return isInWatchlist ?
                                            <TbStarFilled className="w-4 h-4 text-yellow-400" /> :
                                            <TbStar className="w-4 h-4 text-gray-500 hover:text-yellow-400" />;
                                        })()}
                                      </button>
                                    </div>
                                  </div>

                                  {/* Industry */}
                                  <div className="text-xs text-orange-400 mb-3 text-center font-bold">
                                    {trade.industry}
                                  </div>

                                  {/* Trade Info */}
                                  <div className="flex items-center justify-center gap-2 mb-3 text-xs">
                                    <span className="font-bold text-white">${trade.strike?.toFixed(0)}</span>
                                    <span className="font-bold" style={{ color: '#10b981' }}>{trade.optionType?.toUpperCase()}</span>
                                    <span className="text-orange-400 font-bold">
                                      {trade.expiration ? new Date(trade.expiration + 'T12:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'UTC' }) : ''}
                                    </span>
                                  </div>

                                  {/* Metrics Grid */}
                                  <div className="grid grid-cols-3 gap-2 text-xs pt-3" style={{
                                    borderTop: '1px solid rgba(16, 185, 129, 0.1)'
                                  }}>
                                    <div className="text-center">
                                      <div className="text-orange-400 mb-1 font-bold">Price</div>
                                      <div className="text-white font-mono font-bold text-xs">
                                        ${typeof trade.contractPrice === 'number' ? trade.contractPrice.toFixed(2) : 'N/A'}
                                      </div>
                                    </div>
                                    <div className="text-center">
                                      <div className="text-orange-400 mb-1 font-bold">IV</div>
                                      <div className="text-white font-mono font-bold text-xs">
                                        {trade.impliedVolatility || 'N/A'}%
                                      </div>
                                    </div>
                                    <div className="text-center">
                                      <div className="text-orange-400 mb-1 font-bold">Decay</div>
                                      <div className="text-white font-mono font-bold text-xs">
                                        ${typeof trade.thetaDecay === 'number' ? trade.thetaDecay.toFixed(2) : 'N/A'}
                                      </div>
                                    </div>
                                  </div>

                                  {/* Targets */}
                                  <div className="grid grid-cols-3 gap-2 text-xs mt-2">
                                    <div className="text-center">
                                      <div className="text-orange-400 mb-1 font-bold">Target 1</div>
                                      <div className="text-green-400 font-mono font-bold text-xs">
                                        ${typeof trade.stockTarget80 === 'number' ? trade.stockTarget80.toFixed(2) : 'N/A'}
                                      </div>
                                    </div>
                                    <div className="text-center">
                                      <div className="text-orange-400 mb-1 font-bold">Target 2</div>
                                      <div className="text-green-400 font-mono font-bold text-xs">
                                        ${typeof trade.stockTarget90 === 'number' ? trade.stockTarget90.toFixed(2) : 'N/A'}
                                      </div>
                                    </div>
                                    <div className="text-center">
                                      <div className="text-orange-400 mb-1 font-bold">Stop Loss</div>
                                      <div className="text-red-400 font-mono font-bold text-xs">
                                        ${typeof trade.stopLoss === 'number' ? trade.stopLoss.toFixed(2) : 'N/A'}
                                      </div>
                                    </div>
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                          {filteredBullishTrades.length === 0 && (
                            <div className="col-span-full text-center py-8">
                              <div className="text-gray-500 font-mono text-sm">No bullish trades</div>
                            </div>
                          )}
                        </div>
                      </div>

                      {/* Bearish Section */}
                      <div>
                        <div className="mb-6 pb-3 border-b relative overflow-hidden" style={{
                          borderColor: '#ef4444',
                          background: 'linear-gradient(90deg, rgba(239, 68, 68, 0.15) 0%, transparent 50%, rgba(239, 68, 68, 0.15) 100%)'
                        }}>
                          <div className="flex items-center justify-center gap-3 py-3">
                            <div className="w-px h-6 bg-gradient-to-b from-transparent via-red-400 to-transparent" />
                            <h3 className="font-black uppercase tracking-widest flex items-center gap-2" style={{
                              fontSize: '1.1rem',
                              color: '#ff0000',
                              fontFamily: 'system-ui, -apple-system, sans-serif',
                              letterSpacing: '0.15em'
                            }}>
                              <TbTrendingDown size={20} /> BEARISH
                            </h3>
                            <div className="w-px h-6 bg-gradient-to-b from-transparent via-red-400 to-transparent" />
                          </div>
                        </div>
                        <div className="space-y-4">
                          {filteredBearishTrades.map(([symbol, trade]: [string, any], idx) => {
                            const isGold = trade.highlightType === 'gold';
                            const isPurple = trade.highlightType === 'purple';
                            const isBlue = trade.highlightType === 'blue';
                            const isPink = trade.highlightType === 'pink';

                            const tickerColor = isGold ? '#FFD700' :
                              isPurple ? '#8A2BE2' :
                                isBlue ? '#1E90FF' :
                                  isPink ? '#FF69B4' : '#ffffff';
                            const uniqueKey = `${symbol}-${trade.sourceTab}-${idx}`;

                            // Get tab label and color from trade's sourceTab
                            const tradeTab = trade.sourceTab;
                            if (!tradeTab) {
                              console.log(`âš ï¸ WARNING: Bearish ${symbol} missing sourceTab:`, trade);
                            }
                            const tabColor = tradeTab === 'life' ? '#10b981' :
                              tradeTab === 'developing' ? '#3b82f6' :
                                tradeTab === 'momentum' ? '#a855f7' : '#f59e0b';

                            // Determine card styling based on highlight type
                            let cardBorder = '1px solid rgba(239, 68, 68, 0.3)';
                            let cardShadow = '0 2px 8px rgba(0, 0, 0, 0.6)';

                            if (isGold) {
                              cardBorder = '2px solid rgba(255, 215, 0, 0.6)';
                              cardShadow = '0 4px 12px rgba(255, 215, 0, 0.4), inset 0 1px 0 rgba(255, 215, 0, 0.2)';
                            } else if (isPurple) {
                              cardBorder = '2px solid rgba(138, 43, 226, 0.6)';
                              cardShadow = '0 4px 12px rgba(138, 43, 226, 0.4), inset 0 1px 0 rgba(138, 43, 226, 0.2)';
                            } else if (isBlue) {
                              cardBorder = '2px solid rgba(30, 144, 255, 0.6)';
                              cardShadow = '0 4px 12px rgba(30, 144, 255, 0.4), inset 0 1px 0 rgba(30, 144, 255, 0.2)';
                            } else if (isPink) {
                              cardBorder = '2px solid rgba(255, 105, 180, 0.6)';
                              cardShadow = '0 4px 12px rgba(255, 105, 180, 0.4), inset 0 1px 0 rgba(255, 105, 180, 0.2)';
                            }

                            return (
                              <div
                                key={uniqueKey}
                                className="group relative overflow-hidden transition-all duration-300 hover:scale-[1.02] cursor-pointer"
                                style={{
                                  background: 'linear-gradient(135deg, #000000 0%, #0a0a0a 100%)',
                                  border: cardBorder,
                                  borderRadius: '8px',
                                  boxShadow: cardShadow
                                }}
                                onClick={() => {
                                  setSelectedTradeForModal(trade);
                                  setShowTradeModal(true);
                                }}
                              >
                                <div className="relative p-4">
                                  {/* Horizontal Header: Timeframe | Symbol | Score */}
                                  <div className="flex items-center gap-3 mb-3">
                                    {/* Timeframe indicator - vertical colored bar */}
                                    <div className="flex items-center gap-2">
                                      <div className="w-1 h-8 rounded-full" style={{ background: tabColor }} />
                                      <div className="flex flex-col">
                                        <div className="text-xs font-bold uppercase tracking-wide" style={{ color: tabColor }}>
                                          {tradeTab === 'life' ? 'Weekly' : tradeTab === 'developing' ? 'Monthly' : tradeTab === 'momentum' ? 'Quarterly' : 'Leap'}
                                        </div>
                                        <div className="text-[0.65rem] font-medium uppercase tracking-wide" style={{
                                          color: '#ffffff',
                                          marginTop: '2px'
                                        }}>
                                          {isBlue || isPink ? 'Momentum' : 'Quality'}
                                        </div>
                                      </div>
                                    </div>

                                    {/* Symbol in center */}
                                    <div className="flex-1 text-center flex items-center justify-center gap-2">
                                      <span className="font-black tracking-tight" style={{
                                        fontSize: '1.5rem',
                                        background: isGold ? 'linear-gradient(135deg, #FFD700 0%, #FFA500 50%, #FFD700 100%)' :
                                          isBlue ? 'linear-gradient(135deg, #1E90FF 0%, #4169E1 50%, #1E90FF 100%)' :
                                            isPink ? 'linear-gradient(135deg, #FF69B4 0%, #FF1493 50%, #FF69B4 100%)' :
                                              'linear-gradient(135deg, #A855F7 0%, #D946EF 50%, #A855F7 100%)',
                                        WebkitBackgroundClip: 'text',
                                        WebkitTextFillColor: 'transparent',
                                        filter: 'drop-shadow(0 2px 3px rgba(0, 0, 0, 0.8))',
                                        fontFamily: 'system-ui, -apple-system, sans-serif',
                                        display: 'inline-block'
                                      }}>
                                        {symbol}
                                      </span>
                                    </div>

                                    {/* Score and Watchlist Button */}
                                    <div className="flex items-center gap-2">
                                      <span className="font-black tracking-tight" style={{
                                        fontSize: '1.5rem',
                                        color: '#ff0000',
                                        fontFamily: 'system-ui, -apple-system, sans-serif',
                                        opacity: 1
                                      }}>
                                        {window.innerWidth < 768
                                          ? (typeof trade.score === 'number' ? Math.round(trade.score) : 'N/A')
                                          : (typeof trade.score === 'number' ? trade.score.toFixed(1) : 'N/A')}
                                      </span>
                                      <button
                                        onClick={(e) => {
                                          e.stopPropagation();
                                          if (trade && trade.strike && trade.expiration && trade.contractPrice) {
                                            // Get current stock price - use strike if stockPrice not available
                                            let currentStockPrice = trade.stockPrice;
                                            if (!currentStockPrice || currentStockPrice === 0) {
                                              currentStockPrice = trade.strike;
                                            }

                                            // Calculate targets using Black-Scholes expected move
                                            const expiryDate = new Date(trade.expiration);
                                            const now = new Date();
                                            const daysToExpiry = Math.max(1, Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));
                                            const T = daysToExpiry / 365;
                                            const sigma = (trade.impliedVolatility || 50) / 100;
                                            const isPut = trade.optionType?.toLowerCase() === 'put';

                                            let target80StockPrice = 0;
                                            let target90StockPrice = 0;

                                            if (T > 0 && sigma > 0 && currentStockPrice > 0) {
                                              if (isPut) {
                                                const expectedMove1SD = currentStockPrice * sigma * Math.sqrt(T);
                                                target80StockPrice = currentStockPrice - (expectedMove1SD * 0.84);
                                                target90StockPrice = currentStockPrice - (expectedMove1SD * 1.28);
                                              } else {
                                                const expectedMove1SD = currentStockPrice * sigma * Math.sqrt(T);
                                                target80StockPrice = currentStockPrice + (expectedMove1SD * 0.84);
                                                target90StockPrice = currentStockPrice + (expectedMove1SD * 1.28);
                                              }
                                            }

                                            const watchlistItem = {
                                              id: `${symbol}-${trade.strike}-${trade.expiration}-${Date.now()}`,
                                              ticker: trade.optionTicker || `${symbol}${new Date(trade.expiration).toLocaleDateString('en-US', { year: '2-digit', month: '2-digit', day: '2-digit' }).replace(/\//g, '')}${trade.optionType === 'put' ? 'P' : 'C'}${trade.strike}`,
                                              symbol: symbol,
                                              strike: trade.strike,
                                              type: trade.optionType?.toLowerCase() || 'put',
                                              contract_type: trade.optionType?.toLowerCase() || 'put',
                                              expiration: trade.expiration,
                                              bid: trade.contractPrice * 0.98,
                                              ask: trade.contractPrice * 1.02,
                                              lastPrice: trade.contractPrice,
                                              last_price: trade.contractPrice,
                                              delta: trade.delta || 0,
                                              theta: trade.thetaDecay ? -Math.abs(trade.thetaDecay) : 0,
                                              implied_volatility: trade.impliedVolatility || 0,
                                              strike_price: trade.strike,
                                              expiration_date: trade.expiration,
                                              addedAt: new Date(),
                                              entryPrice: trade.contractPrice,
                                              stockPrice: currentStockPrice,
                                              stockTarget80: target80StockPrice,
                                              stockTarget90: target90StockPrice,
                                              stopLoss: trade.contractPrice * 0.75
                                            };
                                            const saved = localStorage.getItem('optionsWatchlist');
                                            const existing = saved ? JSON.parse(saved) : [];
                                            const alreadyExists = existing.some((item: any) =>
                                              item.symbol === watchlistItem.symbol &&
                                              item.strike === watchlistItem.strike &&
                                              item.expiration === watchlistItem.expiration
                                            );
                                            if (!alreadyExists) {
                                              localStorage.setItem('optionsWatchlist', JSON.stringify([...existing, watchlistItem]));
                                              setHighlightFilter(highlightFilter);
                                            }
                                          }
                                        }}
                                        className="hover:scale-110 transition-transform"
                                        title="Add to Options Watchlist"
                                      >
                                        {(() => {
                                          const saved = localStorage.getItem('optionsWatchlist');
                                          const existing = saved ? JSON.parse(saved) : [];
                                          const isInWatchlist = existing.some((item: any) =>
                                            item.symbol === symbol &&
                                            item.strike === trade.strike &&
                                            item.expiration === trade.expiration
                                          );
                                          return isInWatchlist ?
                                            <TbStarFilled className="w-4 h-4 text-yellow-400" /> :
                                            <TbStar className="w-4 h-4 text-yellow-400 hover:text-yellow-300" />;
                                        })()}
                                      </button>
                                    </div>
                                  </div>

                                  {/* Industry and Trade Details */}
                                  <div className="mb-2">
                                    <div className="text-xs text-orange-400 text-center font-bold">
                                      {trade.industry}
                                    </div>
                                  </div>

                                  <div className="text-xs text-center text-orange-400 mb-3 font-bold">
                                    <span className="font-bold text-white">${trade.strike?.toFixed(0)}</span>
                                    {' '}<span className="text-red-400 font-semibold">{trade.optionType?.toUpperCase()}</span>
                                    {' â€¢ '}
                                    <span className="text-white">{trade.expiration ? new Date(trade.expiration + 'T12:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'UTC' }) : ''}</span>
                                  </div>

                                  {/* Contract Metrics */}
                                  <div className="grid grid-cols-3 gap-2 text-xs mb-2">
                                    <div className="text-center">
                                      <div className="text-orange-400 mb-0.5 font-bold">Price</div>
                                      <div className="text-white font-mono font-bold">
                                        ${typeof trade.contractPrice === 'number' ? trade.contractPrice.toFixed(2) : 'N/A'}
                                      </div>
                                    </div>
                                    <div className="text-center">
                                      <div className="text-orange-400 mb-0.5 font-bold">IV</div>
                                      <div className="text-white font-mono font-bold">
                                        {trade.impliedVolatility || 'N/A'}%
                                      </div>
                                    </div>
                                    <div className="text-center">
                                      <div className="text-orange-400 mb-0.5 font-bold">Decay</div>
                                      <div className="text-white font-mono font-bold">
                                        ${typeof trade.thetaDecay === 'number' ? trade.thetaDecay.toFixed(2) : 'N/A'}
                                      </div>
                                    </div>
                                  </div>

                                  {/* Targets */}
                                  <div className="grid grid-cols-3 gap-2 text-xs pt-2 border-t border-gray-800">
                                    <div className="text-center">
                                      <div className="text-orange-400 mb-0.5 font-bold">Target 1</div>
                                      <div className="text-red-400 font-mono font-bold">
                                        ${typeof trade.stockTarget80 === 'number' ? trade.stockTarget80.toFixed(2) : 'N/A'}
                                      </div>
                                    </div>
                                    <div className="text-center">
                                      <div className="text-orange-400 mb-0.5 font-bold">Target 2</div>
                                      <div className="text-red-400 font-mono font-bold">
                                        ${typeof trade.stockTarget90 === 'number' ? trade.stockTarget90.toFixed(2) : 'N/A'}
                                      </div>
                                    </div>
                                    <div className="text-center">
                                      <div className="text-orange-400 mb-0.5 font-bold">Stop Loss</div>
                                      <div className="text-red-400 font-mono font-bold">
                                        ${typeof trade.stopLoss === 'number' ? trade.stopLoss.toFixed(2) : 'N/A'}
                                      </div>
                                    </div>
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                          {filteredBearishTrades.length === 0 && (
                            <div className="text-center py-8">
                              <div className="text-gray-500 font-mono text-sm">No bearish trades</div>
                            </div>
                          )}
                        </div>
                      </div>
                    </div>
                  </div>
                ) : (
                  <>
                    {/* Premium Industry Analysis Grid */}
                    <div className="px-6 pb-6 relative">
                      {/* Loading Overlay */}
                      {isCalculatingTrades && (
                        <div className="absolute inset-0 z-10 flex flex-col items-center justify-center bg-black bg-opacity-90">
                          <div className="text-center">
                            <div className="text-orange-400 font-mono font-bold text-3xl mb-4">
                              {Math.round((Object.keys(highlightedTrades).length / Math.max(bullishIndustries.length + bearishIndustries.length, 1)) * 100)}%
                            </div>
                            <div className="w-64 h-2 bg-gray-800 rounded-full overflow-hidden">
                              <div
                                className="h-full bg-gradient-to-r from-orange-500 to-orange-400 transition-all duration-300"
                                style={{ width: `${(Object.keys(highlightedTrades).length / Math.max(bullishIndustries.length + bearishIndustries.length, 1)) * 100}%` }}
                              />
                            </div>
                          </div>
                        </div>
                      )}

                      <div className="grid grid-cols-2 gap-6" style={{ opacity: isCalculatingTrades ? 0.3 : 1 }}>
                        {/* Premium Bullish Industries Section */}
                        <div>
                          <div className="flex items-center justify-between mb-4 pb-3 border-b" style={{ borderColor: '#00ff00' }}>
                            <h3 className="flex items-center justify-center flex-1">
                              <span className="font-black uppercase tracking-wider" style={{ color: '#00ff00', fontSize: '1rem' }}>
                                BULLISH
                              </span>
                            </h3>
                            <div className="font-mono text-xs font-bold px-3 py-1 rounded" style={{
                              color: '#ff6600',
                              background: 'rgba(255, 102, 0, 0.1)',
                              border: '1px solid rgba(255, 102, 0, 0.3)'
                            }}>
                              {bullishIndustries.length} sectors
                            </div>
                          </div>

                          <div className="grid grid-cols-2 gap-4">
                            {bullishIndustries.length > 0 ? bullishIndustries.map((industry: any, index: number) => (
                              <div
                                key={industry.symbol}
                                className="group relative p-4 rounded-lg transition-all duration-200 cursor-pointer"
                                style={{
                                  background: 'linear-gradient(135deg, #000000 0%, #0a0a0a 100%)',
                                  border: '1px solid rgba(0, 255, 0, 0.3)',
                                  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.6)'
                                }}
                                onMouseEnter={(e) => {
                                  e.currentTarget.style.borderColor = 'rgba(0, 255, 0, 0.6)';
                                  e.currentTarget.style.transform = 'translateY(-2px)';
                                  e.currentTarget.style.boxShadow = '0 4px 12px rgba(0, 255, 0, 0.2)';
                                }}
                                onMouseLeave={(e) => {
                                  e.currentTarget.style.borderColor = 'rgba(0, 255, 0, 0.3)';
                                  e.currentTarget.style.transform = 'translateY(0)';
                                  e.currentTarget.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.6)';
                                }}
                              >
                                <div className="flex justify-between items-start mb-3">
                                  <div className="flex-1">
                                    <div className="flex items-center space-x-3">
                                      <span className="font-black text-2xl tracking-wide" style={{ color: '#00ff00' }}>
                                        {industry.symbol}
                                      </span>
                                    </div>
                                    <div className="text-xs mt-1 font-bold uppercase tracking-wide" style={{ color: '#ff6600' }}>
                                      {industry.name}
                                    </div>
                                  </div>
                                  <div className="text-right">
                                    <div className="font-mono text-xl font-black" style={{ color: '#00ff00' }}>
                                      +{industry.relativePerformance.toFixed(2)}%
                                    </div>
                                  </div>
                                </div>

                                {/* Top Performers */}
                                {industry.topPerformers && industry.topPerformers.length > 0 && (
                                  <div className="border-t pt-3 mt-3" style={{ borderColor: 'rgba(0, 255, 0, 0.2)' }}>
                                    <div className="space-y-2">
                                      {industry.topPerformers.slice(0, 3).map((stock: any) => {
                                        const tradeData = highlightedTrades[stock.symbol];
                                        const isHighlighted = !!tradeData;
                                        const isGold = tradeData?.highlightType === 'gold';
                                        const isPurple = tradeData?.highlightType === 'purple';
                                        const isBlue = tradeData?.highlightType === 'blue';
                                        const isPink = tradeData?.highlightType === 'pink';

                                        let bgColor = 'rgba(0, 0, 0, 0.3)';
                                        let borderColor = 'rgba(0, 255, 0, 0.3)';
                                        let symbolColor = '#ffffff';

                                        if (isGold) {
                                          bgColor = 'rgba(255, 215, 0, 0.1)';
                                          borderColor = '#FFD700';
                                          symbolColor = '#FFD700';
                                        } else if (isPurple) {
                                          bgColor = 'rgba(138, 43, 226, 0.1)';
                                          borderColor = '#8A2BE2';
                                          symbolColor = '#8A2BE2';
                                        } else if (isBlue) {
                                          bgColor = 'rgba(30, 144, 255, 0.1)';
                                          borderColor = '#1E90FF';
                                          symbolColor = '#1E90FF';
                                        } else if (isPink) {
                                          bgColor = 'rgba(255, 105, 180, 0.1)';
                                          borderColor = '#FF69B4';
                                          symbolColor = '#FF69B4';
                                        }

                                        return (
                                          <div
                                            key={stock.symbol}
                                            className="flex justify-between items-center py-2 px-3 rounded transition-all duration-200 cursor-pointer"
                                            style={{
                                              background: bgColor,
                                              border: `1px solid ${borderColor}`,
                                              boxShadow: isHighlighted ? `0 0 8px ${borderColor}` : 'none'
                                            }}
                                            onClick={(e: React.MouseEvent<HTMLDivElement>) => {
                                              e.stopPropagation();
                                              if (isHighlighted && tradeData) {
                                                setSelectedTradeForModal(tradeData);
                                                setShowTradeModal(true);
                                              } else {
                                                if (onSymbolChange) {
                                                  onSymbolChange(stock.symbol);
                                                }
                                                setConfig(prev => ({ ...prev, symbol: stock.symbol }));
                                              }
                                            }}
                                          >
                                            <span className="font-mono font-bold" style={{ color: symbolColor, fontSize: '0.875rem' }}>
                                              {stock.symbol}
                                            </span>
                                            <span className="font-mono font-black" style={{ color: '#00ff00', fontSize: '0.875rem' }}>
                                              +{stock.relativePerformance.toFixed(1)}%
                                            </span>
                                          </div>
                                        );
                                      })}
                                    </div>
                                  </div>
                                )}
                              </div>
                            )) : (
                              <div className="text-center py-8">
                                <div className="text-gray-500 font-mono text-sm">
                                  No bullish sectors detected
                                </div>
                              </div>
                            )}
                          </div>
                        </div>

                        {/* Premium Bearish Industries Section */}
                        <div>
                          <div className="flex items-center justify-between mb-4 pb-3 border-b" style={{ borderColor: '#ff0000' }}>
                            <h3 className="flex items-center justify-center flex-1">
                              <span className="font-black uppercase tracking-wider" style={{ color: '#ff0000', fontSize: '1rem' }}>
                                BEARISH
                              </span>
                            </h3>
                            <div className="font-mono text-xs font-bold px-3 py-1 rounded" style={{
                              color: '#ff6600',
                              background: 'rgba(255, 102, 0, 0.1)',
                              border: '1px solid rgba(255, 102, 0, 0.3)'
                            }}>
                              {bearishIndustries.length} sectors
                            </div>
                          </div>

                          <div className="grid grid-cols-2 gap-4">
                            {bearishIndustries.length > 0 ? bearishIndustries.map((industry: any, index: number) => (
                              <div
                                key={industry.symbol}
                                className="group relative p-4 rounded-lg transition-all duration-200 cursor-pointer"
                                style={{
                                  background: 'linear-gradient(135deg, #000000 0%, #0a0a0a 100%)',
                                  border: '1px solid rgba(255, 0, 0, 0.3)',
                                  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.6)'
                                }}
                                onMouseEnter={(e) => {
                                  e.currentTarget.style.borderColor = 'rgba(255, 0, 0, 0.6)';
                                  e.currentTarget.style.transform = 'translateY(-2px)';
                                  e.currentTarget.style.boxShadow = '0 4px 12px rgba(255, 0, 0, 0.2)';
                                }}
                                onMouseLeave={(e) => {
                                  e.currentTarget.style.borderColor = 'rgba(255, 0, 0, 0.3)';
                                  e.currentTarget.style.transform = 'translateY(0)';
                                  e.currentTarget.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.6)';
                                }}
                              >
                                <div className="flex justify-between items-start mb-3">
                                  <div className="flex-1">
                                    <div className="flex items-center space-x-3">
                                      <span className="text-red-400 font-mono font-bold text-2xl tracking-wide">
                                        {industry.symbol}
                                      </span>
                                    </div>
                                    <div className="text-xs mt-1 font-bold uppercase tracking-wide" style={{ color: '#ff6600' }}>
                                      {industry.name}
                                    </div>
                                  </div>
                                  <div className="text-right">
                                    <div className="font-mono text-xl font-black" style={{ color: '#ff0000' }}>
                                      {industry.relativePerformance.toFixed(2)}%
                                    </div>
                                  </div>
                                </div>

                                {/* Worst Performers */}
                                {industry.worstPerformers && industry.worstPerformers.length > 0 && (
                                  <div className="border-t pt-3 mt-3" style={{ borderColor: 'rgba(255, 0, 0, 0.2)' }}>
                                    <div className="space-y-2">
                                      {industry.worstPerformers.slice(0, 3).map((stock: any) => {
                                        const tradeData = highlightedTrades[stock.symbol];
                                        const isHighlighted = !!tradeData;
                                        const isGold = tradeData?.highlightType === 'gold';
                                        const isPurple = tradeData?.highlightType === 'purple';
                                        const isBlue = tradeData?.highlightType === 'blue';
                                        const isPink = tradeData?.highlightType === 'pink';

                                        let bgColor = 'rgba(0, 0, 0, 0.3)';
                                        let borderColor = 'rgba(255, 0, 0, 0.3)';
                                        let symbolColor = '#ffffff';

                                        if (isGold) {
                                          bgColor = 'rgba(255, 215, 0, 0.1)';
                                          borderColor = '#FFD700';
                                          symbolColor = '#FFD700';
                                        } else if (isPurple) {
                                          bgColor = 'rgba(138, 43, 226, 0.1)';
                                          borderColor = '#8A2BE2';
                                          symbolColor = '#8A2BE2';
                                        } else if (isBlue) {
                                          bgColor = 'rgba(30, 144, 255, 0.1)';
                                          borderColor = '#1E90FF';
                                          symbolColor = '#1E90FF';
                                        } else if (isPink) {
                                          bgColor = 'rgba(255, 105, 180, 0.1)';
                                          borderColor = '#FF69B4';
                                          symbolColor = '#FF69B4';
                                        }

                                        return (
                                          <div
                                            key={stock.symbol}
                                            className="flex justify-between items-center py-2 px-3 rounded transition-all duration-200 cursor-pointer"
                                            style={{
                                              background: bgColor,
                                              border: `1px solid ${borderColor}`,
                                              boxShadow: isHighlighted ? `0 0 8px ${borderColor}` : 'none'
                                            }}
                                            onClick={(e: React.MouseEvent<HTMLDivElement>) => {
                                              e.stopPropagation();
                                              if (isHighlighted && tradeData) {
                                                setSelectedTradeForModal(tradeData);
                                                setShowTradeModal(true);
                                              } else {
                                                if (onSymbolChange) {
                                                  onSymbolChange(stock.symbol);
                                                }
                                                setConfig(prev => ({ ...prev, symbol: stock.symbol }));
                                              }
                                            }}
                                          >
                                            <span className="font-mono font-bold" style={{ color: symbolColor, fontSize: '0.875rem' }}>
                                              {stock.symbol}
                                            </span>
                                            <span className="font-mono font-black" style={{ color: '#ff0000', fontSize: '0.875rem' }}>
                                              {stock.relativePerformance.toFixed(1)}%
                                            </span>
                                          </div>
                                        );
                                      })}
                                    </div>
                                  </div>
                                )}
                              </div>
                            )) : (
                              <div className="text-center py-8">
                                <div className="text-gray-500 font-mono text-sm">
                                  No bearish sectors detected
                                </div>
                              </div>
                            )}
                          </div>
                        </div>
                      </div>
                    </div>
                  </>
                )}
              </div>
            )}
          </div>
        </div>

        {/* Premium Trade Details Modal */}
        {showTradeModal && selectedTradeForModal && (
          <div
            className="fixed inset-0 z-50 flex items-center justify-center"
            style={{ background: 'rgba(0, 0, 0, 0.85)' }}
            onClick={() => {
              setShowTradeModal(false);
              setExpandedScoreComponent(null);
            }}
          >
            <div
              className="relative rounded-xl p-8 max-w-2xl w-full mx-4 overflow-y-auto max-h-[90vh]"
              style={{
                background: '#000000',
                border: '2px solid rgba(255, 255, 255, 0.3)'
              }}
              onClick={(e) => e.stopPropagation()}
            >
              {/* Close Button */}
              <button
                onClick={() => {
                  setShowTradeModal(false);
                  setExpandedScoreComponent(null);
                }}
                className="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors"
              >
                <TbX size={24} />
              </button>

              {/* Header */}
              <div className="mb-6">
                <div className="flex items-start justify-between">
                  <div className="flex items-center space-x-2">
                    <div
                      className="px-3 py-1 font-mono font-bold text-2xl"
                      style={{
                        background: '#000000',
                        color: selectedTradeForModal.highlightType === 'gold' ? '#FFD700' :
                          selectedTradeForModal.highlightType === 'purple' ? '#8A2BE2' :
                            selectedTradeForModal.highlightType === 'blue' ? '#1E90FF' :
                              selectedTradeForModal.highlightType === 'pink' ? '#FF69B4' : '#ffffff'
                      }}
                    >
                      {selectedTradeForModal.symbol}
                    </div>
                    <div
                      className="px-3 py-1 font-mono text-sm font-bold uppercase"
                      style={{
                        background: selectedTradeForModal.strategy === 'setup' ? 'rgba(218, 165, 32, 0.2)' : 'rgba(255, 140, 0, 0.2)',
                        color: selectedTradeForModal.strategy === 'setup' ? '#FFD700' : '#FF8C00',
                        border: `1px solid ${selectedTradeForModal.strategy === 'setup' ? 'rgba(218, 165, 32, 0.4)' : 'rgba(255, 140, 0, 0.4)'}`
                      }}
                    >
                      {selectedTradeForModal.strategy === 'setup' ? 'ðŸ“Š SETUP QUALITY' : 'ðŸš€ MOMENTUM'}
                    </div>
                  </div>
                  <div className="flex-1 text-center font-mono text-base" style={{ color: '#ffffff' }}>
                    {selectedTradeForModal.industry} â€¢ {selectedTradeForModal.industrySymbol}
                  </div>
                </div>
              </div>

              {/* Trade Pick */}
              <div className="mb-8 p-5 rounded-lg" style={{
                background: '#000000',
                border: '1px solid rgba(255, 102, 0, 0.8)',
                boxShadow: '0 4px 15px rgba(255, 102, 0, 0.3)'
              }}>
                <div className="text-white font-mono text-2xl font-bold text-center">
                  <span style={{ color: '#ff6600' }}>Trade Pick :</span> ${selectedTradeForModal.strike?.toFixed(0)} {selectedTradeForModal.optionType.charAt(0).toUpperCase() + selectedTradeForModal.optionType.slice(1).toLowerCase()}s {new Date(selectedTradeForModal.expiration + 'T12:00:00').toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: 'numeric', timeZone: 'UTC' })}
                </div>
              </div>

              {/* AI Score + Current Price + Relative Strength + IV */}
              <div className="grid grid-cols-4 gap-4 mb-8">
                {/* Strength Score */}
                <div className="p-4 rounded-lg" style={{
                  background: '#000000',
                  border: '2px solid #ff6600'
                }}>
                  <div className="font-mono text-xs uppercase tracking-wide mb-2 text-center" style={{ color: '#ff6600' }}>
                    Strength Score
                  </div>
                  <div className="text-white font-mono text-2xl font-bold mb-2 text-center">
                    {selectedTradeForModal.score}
                  </div>
                  <div className="h-2 rounded-full overflow-hidden" style={{
                    background: '#000000'
                  }}>
                    <div
                      className="h-full transition-all duration-1000 rounded-full"
                      style={{
                        width: `${selectedTradeForModal.score}%`,
                        background: 'linear-gradient(90deg, #ff6600 0%, #ff9933 100%)'
                      }}
                    />
                  </div>
                </div>

                {/* Current Price */}
                <div className="p-4 rounded-lg" style={{
                  background: '#000000',
                  border: '2px solid #ffffff'
                }}>
                  <div className="font-mono text-xs uppercase tracking-wide mb-1 text-center" style={{ color: '#ffffff' }}>
                    Current Price
                  </div>
                  <div className="text-white font-mono text-2xl font-bold text-center">
                    ${selectedTradeForModal.currentPrice?.toFixed(2)}
                  </div>
                </div>

                {/* Relative Strength */}
                <div className="p-4 rounded-lg" style={{
                  background: '#000000',
                  border: `2px solid ${selectedTradeForModal.relativePerformance > 0 ? '#4caf50' : '#f44336'}`
                }}>
                  <div className="font-mono text-xs uppercase tracking-wide mb-1 text-center" style={{ color: '#ff6600' }}>
                    Relative Strength
                  </div>
                  <div
                    className="font-mono text-2xl font-bold text-center"
                    style={{ color: selectedTradeForModal.relativePerformance > 0 ? '#4caf50' : '#f44336' }}
                  >
                    {selectedTradeForModal.relativePerformance > 0 ? '+' : ''}{selectedTradeForModal.relativePerformance?.toFixed(2)}%
                  </div>
                </div>

                {/* IV */}
                {selectedTradeForModal.impliedVolatility && (
                  <div className="p-4 rounded-lg" style={{
                    background: '#000000',
                    border: '2px solid #ff6600'
                  }}>
                    <div className="font-mono text-xs uppercase tracking-wide mb-1 text-center" style={{ color: '#ff6600' }}>
                      IV
                    </div>
                    <div className="text-white font-mono text-2xl font-bold text-center">
                      {selectedTradeForModal.impliedVolatility}%
                    </div>
                  </div>
                )}
              </div>

              {/* Option Contract Details */}
              <div className="mb-8 p-6 rounded-lg" style={{
                background: 'linear-gradient(135deg, #0a1628 0%, #0d0d0d 100%)',
                border: '1px solid #2563eb',
                boxShadow: '0 4px 12px rgba(37, 99, 235, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.05)'
              }}>
                <div className="text-center font-mono text-sm uppercase tracking-widest mb-4" style={{
                  color: '#60a5fa',
                  fontWeight: 600
                }}>
                  Contract Analysis
                </div>

                <div className="grid grid-cols-3 gap-4 mb-4">
                  {/* Contract Price */}
                  <div className="text-center p-3 rounded" style={{
                    background: '#000000',
                    border: '1px solid #1e3a8a'
                  }}>
                    <div className="text-xs font-mono uppercase tracking-wide mb-1" style={{ color: '#60a5fa' }}>Price</div>
                    <div className="text-xl font-bold font-mono" style={{ color: '#ffffff' }}>
                      ${selectedTradeForModal.contractPrice ? selectedTradeForModal.contractPrice.toFixed(2) : 'N/A'}
                    </div>
                  </div>

                  {/* IV */}
                  <div className="text-center p-3 rounded" style={{
                    background: '#000000',
                    border: '1px solid #7c3aed'
                  }}>
                    <div className="text-xs font-mono uppercase tracking-wide mb-1" style={{ color: '#a78bfa' }}>IV</div>
                    <div className="text-xl font-bold font-mono" style={{ color: '#ffffff' }}>
                      {selectedTradeForModal.impliedVolatility ? `${selectedTradeForModal.impliedVolatility}%` : 'N/A'}
                    </div>
                  </div>

                  {/* Theta Decay */}
                  <div className="text-center p-3 rounded" style={{
                    background: '#000000',
                    border: '1px solid #dc2626'
                  }}>
                    <div className="text-xs font-mono uppercase tracking-wide mb-1" style={{ color: '#f87171' }}>Decay/Day</div>
                    <div className="text-xl font-bold font-mono" style={{ color: '#ffffff' }}>
                      ${selectedTradeForModal.thetaDecay ? selectedTradeForModal.thetaDecay.toFixed(2) : 'N/A'}
                    </div>
                  </div>
                </div>

                {/* Targets & Stop Loss */}
                <div className="grid grid-cols-3 gap-4">
                  {/* Target #1 (Stock Price) */}
                  <div className="text-center p-3 rounded" style={{
                    background: '#000000',
                    border: '1px solid #059669'
                  }}>
                    <div className="text-xs font-mono uppercase tracking-wide mb-1" style={{ color: '#34d399' }}>Target #1</div>
                    <div className="text-lg font-bold font-mono" style={{ color: '#10b981' }}>
                      ${selectedTradeForModal.stockTarget80 ? selectedTradeForModal.stockTarget80.toFixed(2) : 'N/A'}
                    </div>
                  </div>

                  {/* Target #2 (Stock Price) */}
                  <div className="text-center p-3 rounded" style={{
                    background: '#000000',
                    border: '1px solid #059669'
                  }}>
                    <div className="text-xs font-mono uppercase tracking-wide mb-1" style={{ color: '#34d399' }}>Target #2</div>
                    <div className="text-lg font-bold font-mono" style={{ color: '#10b981' }}>
                      ${selectedTradeForModal.stockTarget90 ? selectedTradeForModal.stockTarget90.toFixed(2) : 'N/A'}
                    </div>
                  </div>

                  {/* Stop Loss (Option Price) */}
                  <div className="text-center p-3 rounded" style={{
                    background: '#000000',
                    border: '1px solid #dc2626'
                  }}>
                    <div className="text-xs font-mono uppercase tracking-wide mb-1" style={{ color: '#f87171' }}>Stop Loss</div>
                    <div className="text-lg font-bold font-mono" style={{ color: '#ef4444' }}>
                      ${selectedTradeForModal.stopLoss ? selectedTradeForModal.stopLoss.toFixed(2) : 'N/A'}
                    </div>
                  </div>
                </div>

                {/* Add to Watchlist Button */}
                <button
                  onClick={() => {
                    // Add to options watchlist
                    const saved = localStorage.getItem('optionsWatchlist');
                    const watchlist = saved ? JSON.parse(saved) : [];

                    const newOption = {
                      id: `${selectedTradeForModal.symbol}-${selectedTradeForModal.strike}-${selectedTradeForModal.optionType}-${selectedTradeForModal.expiration}`,
                      symbol: selectedTradeForModal.symbol,
                      type: selectedTradeForModal.optionType,
                      strike: selectedTradeForModal.strike,
                      expiration: selectedTradeForModal.expiration,
                      bid: selectedTradeForModal.contractBid || 0,
                      ask: selectedTradeForModal.contractAsk || 0,
                      entryPrice: selectedTradeForModal.contractPrice || 0,
                      delta: selectedTradeForModal.delta || 0,
                      gamma: selectedTradeForModal.gamma || 0,
                      theta: selectedTradeForModal.theta || 0,
                      vega: selectedTradeForModal.vega || 0,
                      implied_volatility: selectedTradeForModal.impliedVolatility / 100 || 0,
                      stockPrice: selectedTradeForModal.currentPrice || 0,
                      addedAt: new Date().toISOString()
                    };

                    // Check if already exists
                    const exists = watchlist.some((opt: any) => opt.id === newOption.id);
                    if (!exists) {
                      watchlist.push(newOption);
                      localStorage.setItem('optionsWatchlist', JSON.stringify(watchlist));

                      // Switch to Options Trades tab
                      setWatchlistTab('Options Trades');
                      setShowTradeModal(false);
                    }
                  }}
                  className="mt-4 w-full py-3 rounded-lg font-mono font-bold uppercase tracking-wider transition-all duration-200"
                  style={{
                    background: 'linear-gradient(135deg, #2563eb 0%, #1e40af 100%)',
                    color: '#ffffff',
                    border: '1px solid #3b82f6',
                    boxShadow: '0 4px 12px rgba(37, 99, 235, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2)'
                  }}
                >
                  Add to Watchlist
                </button>
              </div>

              {/* Score Breakdown */}
              {selectedTradeForModal.details && (
                <div className="p-6 rounded-lg" style={{
                  background: 'linear-gradient(135deg, #1a1a1a 0%, #000000 100%)',
                  border: '2px solid #ff6600',
                  boxShadow: '0 8px 25px rgba(255, 102, 0, 0.5), inset 0 2px 8px rgba(255, 102, 0, 0.2)'
                }}>
                  <div className="text-center font-mono text-lg uppercase tracking-wide mb-5" style={{
                    color: '#ff6600'
                  }}>
                    {selectedTradeForModal.strategy === 'setup' ? 'Setup Quality Score Breakdown' : 'Momentum-Volatility Score Breakdown'}
                  </div>

                  {selectedTradeForModal.strategy === 'setup' ? (
                    <div className="grid grid-cols-2 gap-x-8 gap-y-4 text-base font-mono">
                      <div className="flex justify-between items-center p-3 rounded" style={{ background: '#000000', border: '1px solid #333' }}>
                        <span style={{ color: '#FFD700', fontSize: '15px' }}>Setup Quality:</span>
                        <span className="font-bold" style={{ color: '#FFD700', fontSize: '16px' }}>{selectedTradeForModal.details.setupQuality?.toFixed(1) || 0}/25</span>
                      </div>
                      <div className="flex justify-between items-center p-3 rounded" style={{ background: '#000000', border: '1px solid #333' }}>
                        <span style={{ color: '#4ECDC4', fontSize: '15px' }}>Risk/Reward:</span>
                        <span className="font-bold" style={{ color: '#4ECDC4', fontSize: '16px' }}>{selectedTradeForModal.details.riskReward?.toFixed(1) || 0}/20</span>
                      </div>
                      <div className="flex justify-between items-center p-3 rounded" style={{ background: '#000000', border: '1px solid #333' }}>
                        <span style={{ color: '#95E1D3', fontSize: '15px' }}>Seasonal Alignment:</span>
                        <span className="font-bold" style={{ color: '#95E1D3', fontSize: '16px' }}>{selectedTradeForModal.details.seasonalAlignment?.toFixed(1) || 0}/15</span>
                      </div>
                      <div className="flex justify-between items-center p-3 rounded" style={{ background: '#000000', border: '1px solid #333' }}>
                        <span style={{ color: '#F38181', fontSize: '15px' }}>Momentum Health:</span>
                        <span className="font-bold" style={{ color: '#F38181', fontSize: '16px' }}>{selectedTradeForModal.details.momentumHealth?.toFixed(1) || 0}/20</span>
                      </div>
                      {selectedTradeForModal.details.seasonalDetails && (
                        <div className="col-span-2 p-4 rounded" style={{ background: '#0a0a0a', border: '1px solid #95E1D3' }}>
                          <div className="text-sm font-semibold mb-3" style={{ color: '#95E1D3' }}>
                            10-Year Seasonality Details
                          </div>
                          <div className="grid grid-cols-2 gap-3 text-xs font-mono">
                            {selectedTradeForModal.details.seasonalDetails.best30Day && (
                              <div className="p-3 rounded" style={{
                                background: selectedTradeForModal.details.seasonalDetails.inBest30 ? '#001a00' : '#000000',
                                border: selectedTradeForModal.details.seasonalDetails.inBest30 ? '1px solid #00ff00' : '1px solid #333'
                              }}>
                                <div className="flex items-center gap-2 mb-1">
                                  <span style={{ color: '#00ff00' }}>Best 30-Day</span>
                                  {selectedTradeForModal.details.seasonalDetails.inBest30 && (
                                    <span style={{ color: '#00ff00', fontSize: '16px' }}>âœ“</span>
                                  )}
                                </div>
                                <div style={{ color: '#888' }}>
                                  {selectedTradeForModal.details.seasonalDetails.best30Day.start} - {selectedTradeForModal.details.seasonalDetails.best30Day.end}
                                </div>
                                <div style={{ color: '#00ff00', fontWeight: 'bold' }}>
                                  +{(selectedTradeForModal.details.seasonalDetails.best30Day.avgReturn || 0).toFixed(2)}%
                                </div>
                              </div>
                            )}
                            {selectedTradeForModal.details.seasonalDetails.worst30Day && (
                              <div className="p-3 rounded" style={{
                                background: selectedTradeForModal.details.seasonalDetails.inWorst30 ? '#1a0000' : '#000000',
                                border: selectedTradeForModal.details.seasonalDetails.inWorst30 ? '1px solid #ff0000' : '1px solid #333'
                              }}>
                                <div className="flex items-center gap-2 mb-1">
                                  <span style={{ color: '#ff0000' }}>Worst 30-Day</span>
                                  {selectedTradeForModal.details.seasonalDetails.inWorst30 && (
                                    <span style={{ color: '#ff0000', fontSize: '16px' }}>âœ“</span>
                                  )}
                                </div>
                                <div style={{ color: '#888' }}>
                                  {selectedTradeForModal.details.seasonalDetails.worst30Day.start} - {selectedTradeForModal.details.seasonalDetails.worst30Day.end}
                                </div>
                                <div style={{ color: '#ff0000', fontWeight: 'bold' }}>
                                  {(selectedTradeForModal.details.seasonalDetails.worst30Day.avgReturn || 0).toFixed(2)}%
                                </div>
                              </div>
                            )}
                            {selectedTradeForModal.details.seasonalDetails.sweetSpot && (
                              <div className="p-3 rounded" style={{
                                background: selectedTradeForModal.details.seasonalDetails.inSweetSpot ? '#001a00' : '#000000',
                                border: selectedTradeForModal.details.seasonalDetails.inSweetSpot ? '1px solid #00ff00' : '1px solid #333'
                              }}>
                                <div className="flex items-center gap-2 mb-1">
                                  <span style={{ color: '#00ff00' }}>Sweet Spot</span>
                                  {selectedTradeForModal.details.seasonalDetails.inSweetSpot && (
                                    <span style={{ color: '#00ff00', fontSize: '16px' }}>âœ“</span>
                                  )}
                                </div>
                                <div style={{ color: '#888' }}>
                                  {selectedTradeForModal.details.seasonalDetails.sweetSpot.start} - {selectedTradeForModal.details.seasonalDetails.sweetSpot.end}
                                </div>
                                <div style={{ color: '#00ff00', fontWeight: 'bold' }}>
                                  +{(selectedTradeForModal.details.seasonalDetails.sweetSpot.avgReturn || 0).toFixed(2)}%
                                </div>
                              </div>
                            )}
                            {selectedTradeForModal.details.seasonalDetails.painPoint && (
                              <div className="p-3 rounded" style={{
                                background: selectedTradeForModal.details.seasonalDetails.inPainPoint ? '#1a0000' : '#000000',
                                border: selectedTradeForModal.details.seasonalDetails.inPainPoint ? '1px solid #ff0000' : '1px solid #333'
                              }}>
                                <div className="flex items-center gap-2 mb-1">
                                  <span style={{ color: '#ff0000' }}>Pain Point</span>
                                  {selectedTradeForModal.details.seasonalDetails.inPainPoint && (
                                    <span style={{ color: '#ff0000', fontSize: '16px' }}>âœ“</span>
                                  )}
                                </div>
                                <div style={{ color: '#888' }}>
                                  {selectedTradeForModal.details.seasonalDetails.painPoint.start} - {selectedTradeForModal.details.seasonalDetails.painPoint.end}
                                </div>
                                <div style={{ color: '#ff0000', fontWeight: 'bold' }}>
                                  {(selectedTradeForModal.details.seasonalDetails.painPoint.avgReturn || 0).toFixed(2)}%
                                </div>
                              </div>
                            )}
                          </div>
                        </div>
                      )}
                      <div className="flex items-center col-span-2 justify-center p-3 rounded" style={{ background: '#000000', border: '1px solid #333' }}>
                        <span style={{ color: '#AA96DA', fontSize: '15px' }}>Trend Strength:</span>
                        <span className="font-bold ml-3" style={{ color: '#AA96DA', fontSize: '16px' }}>{selectedTradeForModal.details.trendStrength?.toFixed(1) || 0}/20</span>
                      </div>
                    </div>
                  ) : (
                    <div className="grid grid-cols-2 gap-x-8 gap-y-4 text-base font-mono">
                      <div className="flex justify-between items-center p-3 rounded" style={{ background: '#000000', border: '1px solid #333' }}>
                        <span style={{ color: '#FF8C00', fontSize: '15px' }}>Support Strength:</span>
                        <span className="font-bold" style={{ color: '#FF8C00', fontSize: '16px' }}>{selectedTradeForModal.details.supportStrength?.toFixed(1) || 0}</span>
                      </div>
                      <div className="flex justify-between items-center p-3 rounded" style={{ background: '#000000', border: '1px solid #333' }}>
                        <span style={{ color: '#FFD700', fontSize: '15px' }}>Elite Resilience:</span>
                        <span className="font-bold" style={{ color: '#FFD700', fontSize: '16px' }}>{selectedTradeForModal.details.resilience?.toFixed(1) || 0}</span>
                      </div>
                      <div className="flex justify-between items-center p-3 rounded" style={{ background: '#000000', border: '1px solid #333' }}>
                        <span style={{ color: '#1E90FF', fontSize: '15px' }}>Retest Quality:</span>
                        <span className="font-bold" style={{ color: '#1E90FF', fontSize: '16px' }}>{selectedTradeForModal.details.retestQuality?.toFixed(1) || 0}</span>
                      </div>
                      <div className="flex justify-between items-center p-3 rounded" style={{ background: '#000000', border: '1px solid #333' }}>
                        <span style={{ color: '#32CD32', fontSize: '15px' }}>Seasonal Alignment:</span>
                        <span className="font-bold" style={{ color: '#32CD32', fontSize: '16px' }}>{selectedTradeForModal.details.seasonalAlignment?.toFixed(1) || 0}</span>
                      </div>
                      <div className="flex items-center col-span-2 justify-center p-3 rounded" style={{ background: '#000000', border: '1px solid #333' }}>
                        <span style={{ color: '#FF1493', fontSize: '15px' }}>Pullback Depth:</span>
                        <span className="font-bold ml-3" style={{ color: '#FF1493', fontSize: '16px' }}>{selectedTradeForModal.details.pullbackDepth?.toFixed(1) || 0}</span>
                      </div>
                    </div>
                  )}

                  {/* Seasonal Period Details - Only show if not expanded inline */}
                  {!expandedScoreComponent && selectedTradeForModal.details.seasonalDetails && (
                    <div className="mt-5 pt-4 border-t border-gray-700">
                      <div className="text-sm font-semibold mb-3" style={{ color: '#00FFFF' }}>
                        10-Year Seasonality Analysis
                      </div>
                      <div className="grid grid-cols-2 gap-3 text-xs font-mono">
                        {/* Best 30-Day Period */}
                        {selectedTradeForModal.details.seasonalDetails.best30Day && (
                          <div className="p-3 rounded" style={{
                            background: selectedTradeForModal.details.seasonalDetails.inBest30 ? '#001a00' : '#000000',
                            border: selectedTradeForModal.details.seasonalDetails.inBest30 ? '1px solid #00ff00' : '1px solid #333'
                          }}>
                            <div className="flex items-center gap-2 mb-1">
                              <span style={{ color: '#00ff00' }}>Best 30-Day</span>
                              {selectedTradeForModal.details.seasonalDetails.inBest30 && (
                                <span style={{ color: '#00ff00', fontSize: '16px' }}>âœ“</span>
                              )}
                            </div>
                            <div style={{ color: '#888' }}>
                              {selectedTradeForModal.details.seasonalDetails.best30Day.start} - {selectedTradeForModal.details.seasonalDetails.best30Day.end}
                            </div>
                            <div style={{ color: '#00ff00', fontWeight: 'bold' }}>
                              +{(selectedTradeForModal.details.seasonalDetails.best30Day.avgReturn || 0).toFixed(2)}%
                            </div>
                          </div>
                        )}

                        {/* Worst 30-Day Period */}
                        {selectedTradeForModal.details.seasonalDetails.worst30Day && (
                          <div className="p-3 rounded" style={{
                            background: selectedTradeForModal.details.seasonalDetails.inWorst30 ? '#1a0000' : '#000000',
                            border: selectedTradeForModal.details.seasonalDetails.inWorst30 ? '1px solid #ff0000' : '1px solid #333'
                          }}>
                            <div className="flex items-center gap-2 mb-1">
                              <span style={{ color: '#ff0000' }}>Worst 30-Day</span>
                              {selectedTradeForModal.details.seasonalDetails.inWorst30 && (
                                <span style={{ color: '#ff0000', fontSize: '16px' }}>âœ“</span>
                              )}
                            </div>
                            <div style={{ color: '#888' }}>
                              {selectedTradeForModal.details.seasonalDetails.worst30Day.start} - {selectedTradeForModal.details.seasonalDetails.worst30Day.end}
                            </div>
                            <div style={{ color: '#ff0000', fontWeight: 'bold' }}>
                              {(selectedTradeForModal.details.seasonalDetails.worst30Day.avgReturn || 0).toFixed(2)}%
                            </div>
                          </div>
                        )}

                        {/* Sweet Spot (50-90 day best window) */}
                        {selectedTradeForModal.details.seasonalDetails.sweetSpot && (
                          <div className="p-3 rounded" style={{
                            background: selectedTradeForModal.details.seasonalDetails.inSweetSpot ? '#001a00' : '#000000',
                            border: selectedTradeForModal.details.seasonalDetails.inSweetSpot ? '1px solid #00ff00' : '1px solid #333'
                          }}>
                            <div className="flex items-center gap-2 mb-1">
                              <span style={{ color: '#00ff00' }}>Sweet Spot</span>
                              {selectedTradeForModal.details.seasonalDetails.inSweetSpot && (
                                <span style={{ color: '#00ff00', fontSize: '16px' }}>âœ“</span>
                              )}
                            </div>
                            <div style={{ color: '#888' }}>
                              {selectedTradeForModal.details.seasonalDetails.sweetSpot.start} - {selectedTradeForModal.details.seasonalDetails.sweetSpot.end}
                            </div>
                            <div style={{ color: '#00ff00', fontWeight: 'bold' }}>
                              +{(selectedTradeForModal.details.seasonalDetails.sweetSpot.avgReturn || 0).toFixed(2)}%
                            </div>
                          </div>
                        )}

                        {/* Pain Point (50-90 day worst window) */}
                        {selectedTradeForModal.details.seasonalDetails.painPoint && (
                          <div className="p-3 rounded" style={{
                            background: selectedTradeForModal.details.seasonalDetails.inPainPoint ? '#1a0000' : '#000000',
                            border: selectedTradeForModal.details.seasonalDetails.inPainPoint ? '1px solid #ff0000' : '1px solid #333'
                          }}>
                            <div className="flex items-center gap-2 mb-1">
                              <span style={{ color: '#ff0000' }}>Pain Point</span>
                              {selectedTradeForModal.details.seasonalDetails.inPainPoint && (
                                <span style={{ color: '#ff0000', fontSize: '16px' }}>âœ“</span>
                              )}
                            </div>
                            <div style={{ color: '#888' }}>
                              {selectedTradeForModal.details.seasonalDetails.painPoint.start} - {selectedTradeForModal.details.seasonalDetails.painPoint.end}
                            </div>
                            <div style={{ color: '#ff0000', fontWeight: 'bold' }}>
                              {(selectedTradeForModal.details.seasonalDetails.painPoint.avgReturn || 0).toFixed(2)}%
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  )}

                  {/* Additional Context */}
                  <div className="mt-5 pt-4 border-t border-gray-700">
                    <div className="grid grid-cols-1 gap-4 text-xs font-mono text-gray-400">
                      <div>
                        <div className="text-gray-500">Current Price</div>
                        <div className="text-white font-bold">${selectedTradeForModal.details.currentPrice?.toFixed(2) || 'N/A'}</div>
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        )}
      </>
    );
  };

  // Main component return with all UI elements
  return (
    <>
      <style dangerouslySetInnerHTML={{
        __html: `
 .text-shadow-carved {
 text-shadow: 
 1px 1px 0px rgba(0, 0, 0, 0.9),
 -1px -1px 0px rgba(255, 255, 255, 0.1),
 0px -1px 0px rgba(255, 255, 255, 0.05),
 0px 1px 0px rgba(0, 0, 0, 0.8) !important;
 }
 
 .glow-yellow {
 text-shadow: 0 0 5px rgba(255, 255, 0, 0.5), 0 0 10px rgba(255, 255, 0, 0.3) !important;
 }
 
 .glow-green {
 text-shadow: 0 0 5px rgba(0, 255, 0, 0.5), 0 0 10px rgba(0, 255, 0, 0.3) !important;
 }
 
 .glow-red {
 text-shadow: 0 0 5px rgba(255, 0, 0, 0.5), 0 0 10px rgba(255, 0, 0, 0.3) !important;
 }
 
 /* Premium Navigation Animations */
 @keyframes premiumGlow {
 0% { box-shadow: 0 4px 20px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(128, 128, 128, 0.1), 0 0 15px rgba(64, 64, 64, 0.05); }
 50% { box-shadow: 0 4px 20px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(128, 128, 128, 0.2), 0 0 20px rgba(64, 64, 64, 0.1); }
 100% { box-shadow: 0 4px 20px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(128, 128, 128, 0.1), 0 0 15px rgba(64, 64, 64, 0.05); }
 }
 
 @keyframes grayBorderSweep {
 0% { background-position: -200% 0; }
 100% { background-position: 200% 0; }
 }
 
 @keyframes subtleShimmer {
 0% { opacity: 0.7; transform: translateX(-100%); }
 50% { opacity: 0.9; transform: translateX(0%); }
 100% { opacity: 0.7; transform: translateX(100%); }
 }
 
 /* Custom Scrollbar for Chat */
 .custom-scrollbar::-webkit-scrollbar {
 width: 6px;
 }
 
 .custom-scrollbar::-webkit-scrollbar-track {
 background: #0a0a0a;
 border-radius: 3px;
 }
 
 .custom-scrollbar::-webkit-scrollbar-thumb {
 background: linear-gradient(180deg, #3b82f6, #8b5cf6);
 border-radius: 3px;
 }
 
 .custom-scrollbar::-webkit-scrollbar-thumb:hover {
 background: linear-gradient(180deg, #2563eb, #7c3aed);
 }

 /* Elite Dark Theme Button System - Professional Trading Interface */
 .btn-3d-carved {
 background: 
 linear-gradient(to bottom, rgba(255, 255, 255, 0.02) 0%, transparent 50%, rgba(0, 0, 0, 0.3) 100%),
 #000000 !important;
 border: 1px solid rgba(50, 50, 50, 0.6) !important;
 position: relative !important;
 box-shadow: 
 0 1px 3px rgba(0, 0, 0, 0.8),
 inset 0 1px 0 rgba(255, 255, 255, 0.05),
 inset 0 -1px 0 rgba(0, 0, 0, 0.8) !important;
 color: #ffffff !important;
 font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;
 letter-spacing: 0.4px !important;
 text-transform: uppercase !important;
 font-size: 14px !important;
 font-weight: 600 !important;
 transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1) !important;
 border-radius: 4px !important;
 margin: 0 6px !important;
 opacity: 1 !important;
 }

 .btn-3d-carved::before {
 content: '';
 position: absolute;
 top: 0;
 left: 0;
 right: 0;
 bottom: 0;
 border-radius: 4px;
 background: 
 radial-gradient(circle at 50% 0%, rgba(255, 255, 255, 0.03), transparent 70%),
 repeating-linear-gradient(
 0deg,
 transparent,
 transparent 2px,
 rgba(255, 255, 255, 0.005) 2px,
 rgba(255, 255, 255, 0.005) 4px
 );
 pointer-events: none;
 }
 
 /* Active State - Elegant Orange */
 .btn-3d-carved.active {
 background: 
 linear-gradient(to bottom, rgba(255, 133, 0, 0.08) 0%, transparent 50%, rgba(0, 0, 0, 0.4) 100%),
 #000000 !important;
 border: 1px solid rgba(255, 133, 0, 0.6) !important;
 color: #ff8500 !important;
 box-shadow: 
 0 0 0 1px rgba(255, 133, 0, 0.3),
 0 2px 6px rgba(0, 0, 0, 0.8),
 inset 0 1px 0 rgba(255, 133, 0, 0.1),
 inset 0 -1px 0 rgba(0, 0, 0, 0.9) !important;
 }

 .btn-3d-carved.active::before {
 background: 
 radial-gradient(circle at 50% 0%, rgba(255, 133, 0, 0.05), transparent 70%),
 repeating-linear-gradient(
 0deg,
 transparent,
 transparent 2px,
 rgba(255, 133, 0, 0.008) 2px,
 rgba(255, 133, 0, 0.008) 4px
 );
 }
 
 .btn-3d-carved:hover {
 background: 
 linear-gradient(to bottom, rgba(255, 255, 255, 0.04) 0%, transparent 50%, rgba(0, 0, 0, 0.4) 100%),
 #000000 !important;
 border: 1px solid rgba(80, 80, 80, 0.8) !important;
 color: #ffffff !important;
 box-shadow: 
 0 2px 6px rgba(0, 0, 0, 0.9),
 inset 0 1px 0 rgba(255, 255, 255, 0.08),
 inset 0 -1px 0 rgba(0, 0, 0, 0.9) !important;
 transform: translateY(-2px) !important;
 }
 
 .btn-3d-carved.active:hover {
 background: 
 linear-gradient(to bottom, rgba(255, 160, 48, 0.1) 0%, transparent 50%, rgba(0, 0, 0, 0.5) 100%),
 #000000 !important;
 border: 1px solid rgba(255, 160, 48, 0.7) !important;
 color: #ffa030 !important;
 box-shadow: 
 0 0 0 1px rgba(255, 160, 48, 0.4),
 0 3px 8px rgba(0, 0, 0, 0.9),
 inset 0 1px 0 rgba(255, 160, 48, 0.15),
 inset 0 -1px 0 rgba(0, 0, 0, 0.95) !important;
 transform: translateY(-2px) !important;
 }
 
 .btn-3d-carved:active {
 background: 
 linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.2)),
 #000000 !important;
 box-shadow: 
 inset 0 2px 4px rgba(0, 0, 0, 0.9),
 inset 0 -1px 0 rgba(255, 255, 255, 0.02),
 0 1px 2px rgba(0, 0, 0, 0.7) !important;
 transform: translateY(0) !important;
 }

 .btn-3d-carved.active:active {
 background: 
 linear-gradient(to bottom, rgba(255, 133, 0, 0.03), rgba(0, 0, 0, 0.3)),
 #000000 !important;
 box-shadow: 
 0 0 0 1px rgba(255, 133, 0, 0.25),
 inset 0 2px 4px rgba(0, 0, 0, 0.95),
 inset 0 -1px 0 rgba(255, 133, 0, 0.02),
 0 1px 2px rgba(0, 0, 0, 0.7) !important;
 }

 /* Button Separator - Visual spacing between button groups */
 .ml-4 {
 position: relative;
 }

 .ml-4::before {
 content: '';
 position: absolute;
 left: -12px;
 top: 50%;
 transform: translateY(-50%);
 width: 1px;
 height: 60%;
 background: linear-gradient(
 to bottom,
 transparent,
 rgba(80, 80, 80, 0.3) 20%,
 rgba(80, 80, 80, 0.3) 80%,
 transparent
 );
 pointer-events: none;
 }
 
 /* Professional Search Bar */
 .search-bar-premium {
 background: linear-gradient(145deg, #0a0a0a 0%, #1a1a1a 100%) !important;
 border: 2px solid rgba(128, 128, 128, 0.3) !important;
 box-shadow: 
 inset 0 2px 4px rgba(0, 0, 0, 0.8),
 inset 0 -2px 4px rgba(128, 128, 128, 0.05),
 0 4px 12px rgba(0, 0, 0, 0.6),
 0 0 0 1px rgba(96, 96, 96, 0.2) !important;
 border-radius: 3px !important;
 transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
 }
 
 .search-bar-premium:focus-within {
 border: 2px solid rgba(160, 160, 160, 0.6) !important;
 box-shadow: 
 inset 0 2px 4px rgba(0, 0, 0, 0.8),
 inset 0 -2px 4px rgba(128, 128, 128, 0.1),
 0 4px 12px rgba(0, 0, 0, 0.6),
 0 0 15px rgba(128, 128, 128, 0.2),
 0 0 0 2px rgba(96, 96, 96, 0.1) !important;
 }
 
 /* Premium Navigation Container */
 .navigation-bar-premium {
 position: relative;
 overflow: hidden;
 }
 
 .navigation-bar-premium::before {
 content: '';
 position: absolute;
 top: 0;
 left: -100%;
 width: 100%;
 height: 100%;
 background: linear-gradient(90deg, transparent, rgba(128, 128, 128, 0.05), transparent);
 pointer-events: none;
 display: none;
 }
 
 @keyframes subtleSweep {
 0% { left: -100%; }
 50% { left: 100%; }
 100% { left: -100%; }
 }
 
 /* Sharp Corner Enhancements */
 .sharp-corners {
 border-radius: 0 !important;
 clip-path: polygon(0 0, calc(100% - 4px) 0, 100% 4px, 100% 100%, 4px 100%, 0 calc(100% - 4px));
 }
 `
      }} />

      <div className="w-full h-full flex">
        <div className={`${isGuideAIOpen ? 'w-[70%]' : 'w-full'} h-full rounded-lg overflow-hidden transition-all duration-300`} style={{ backgroundColor: colors.background }}>
          {/* Premium Bloomberg Terminal Top Bar with Solid Black & Gold */}
          <div
            className="h-14 border-b flex items-center justify-between px-6 relative navigation-bar-premium"
            style={{
              background: '#000000',
              backgroundSize: '400% 400%',
              borderColor: '#333333',
              boxShadow: 'inset 0 1px 0 rgba(128, 128, 128, 0.1)',
              backdropFilter: 'none',
              overflow: 'hidden',
              zIndex: 10000
            }}
          >
            {/* Premium Gray Border Animation */}
            <div
              className="absolute inset-0 pointer-events-none"
              style={{
                background: 'transparent',
                backgroundSize: '200% 100%',
                borderRadius: 'inherit',
                opacity: 0
              }}
            />

            {/* Premium Metallic Overlay */}
            <div
              className="absolute inset-0 pointer-events-none"
              style={{
                background: 'transparent',
                borderRadius: 'inherit'
              }}
            />

            {/* Drawing Tools Status Badge */}
            <div className="absolute top-2 left-4 z-20">
              <div
                className="flex items-center space-x-2 px-3 py-1 rounded-full bg-black bg-opacity-60 backdrop-blur border border-gray-600 border-opacity-50"
                style={{
                  background: 'linear-gradient(135deg, rgba(18, 18, 18, 0.9) 0%, rgba(12, 12, 12, 0.95) 100%)',
                  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1)',
                  fontSize: '11px',
                  display: 'none'
                }}
              >
              </div>
            </div>

            {/* Symbol and Price Info */}
            <div className="flex items-center w-full relative z-10">
              {/* Left side: Symbol Search + Price + Controls */}
              <div className="flex items-center space-x-8 flex-shrink-0">
                <div className="flex items-center space-x-3">
                  <div className="relative flex items-center">
                    <div className="search-bar-premium flex items-center space-x-2 px-3 py-2 rounded-md">
                      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" style={{ color: 'rgba(128, 128, 128, 0.5)' }}>
                        <circle cx="11" cy="11" r="8" stroke="currentColor" strokeWidth="2" />
                        <path d="m21 21-4.35-4.35" stroke="currentColor" strokeWidth="2" />
                      </svg>
                      <input
                        type="text"
                        value={searchQuery}
                        onChange={(e: React.ChangeEvent<HTMLInputElement>) => setSearchQuery(e.target.value)}
                        onKeyPress={handleSearchKeyPress}
                        className="bg-transparent border-0 outline-none w-28 text-lg font-bold"
                        style={{
                          color: '#ffffff',
                          textShadow: '0 0 5px rgba(128, 128, 128, 0.2), 0 1px 2px rgba(0, 0, 0, 0.8)',
                          fontFamily: 'system-ui, -apple-system, sans-serif',
                          letterSpacing: '0.8px'
                        }}
                        placeholder={isBenchmarkMode ? `${benchmarkSymbol1}/${benchmarkSymbol2}` : (symbol || "Search...")}
                      />
                      <svg width="12" height="12" viewBox="0 0 24 24" fill="none" style={{ color: '#666' }}>
                        <path d="M12 5v14l7-7-7-7z" fill="currentColor" />
                      </svg>
                    </div>
                  </div>
                </div>

                <div className="flex flex-col items-start space-y-1">
                  <span
                    className="font-mono text-xl font-bold leading-tight"
                    style={{
                      color: '#ffffff',
                      textShadow: '0 1px 2px rgba(0, 0, 0, 0.8), 0 0 8px rgba(255, 255, 255, 0.2)',
                      letterSpacing: '0.3px'
                    }}
                  >
                    ${currentPrice.toFixed(2)}
                  </span>
                  <span
                    className="font-mono text-xs font-semibold px-2 py-0.5 rounded"
                    style={{
                      color: priceChangePercent >= 0 ? '#10b981' : '#ef4444',
                      background: priceChangePercent >= 0
                        ? 'linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(16, 185, 129, 0.05) 100%)'
                        : 'linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.05) 100%)',
                      textShadow: `0 1px 1px rgba(0, 0, 0, 0.8), 0 0 6px ${priceChangePercent >= 0 ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)'}`,
                      border: `1px solid ${priceChangePercent >= 0 ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)'}`,
                      letterSpacing: '0.2px'
                    }}
                  >
                    {priceChangePercent >= 0 ? '+' : ''}{priceChange.toFixed(2)} ({priceChangePercent.toFixed(2)}%)
                  </span>
                </div>

                {/* Alert Placement Mode Indicator */}
                {isAlertPlacementMode && (
                  <div
                    className="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 pointer-events-none"
                    style={{
                      animation: 'pulse 2s ease-in-out infinite'
                    }}
                  >
                    <div className="bg-blue-600 text-white px-8 py-4 rounded-lg shadow-2xl border-2 border-blue-400">
                      <div className="flex items-center gap-3">
                        <TbBellRinging className="w-8 h-8 animate-bounce" />
                        <div>
                          <p className="text-xl font-bold">Click on Chart</p>
                          <p className="text-sm opacity-80">Click anywhere to place your alert</p>
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                {/* Timeframes - Moved closer to symbol/price */}
                <div
                  className="flex items-center timeframe-dropdown"
                  style={{
                    background: 'linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%)',
                    border: '2px solid rgba(255, 255, 255, 0.4)',
                    borderRadius: '8px',
                    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1)'
                  }}
                >
                  {/* Desktop Timeframes - Hidden on mobile */}
                  <div className="hidden md:flex">
                    {[
                      { label: '5M', value: '5m' },
                      { label: '1H', value: '1h' },
                      { label: 'D', value: '1d' }
                    ].map((tf, index) => (
                      <button
                        key={tf.label}
                        onClick={() => handleTimeframeChange(tf.value)}
                        className={`btn-3d-carved relative group ${config.timeframe === tf.value ? 'active' : ''}`}
                        style={{
                          padding: '10px 20px',
                          fontWeight: '700',
                          fontSize: '15px',
                          letterSpacing: '0.8px',
                          borderRadius: '4px',
                          color: 'white'
                        }}
                      >
                        {tf.label}
                      </button>
                    ))}

                    {/* More Timeframes Dropdown Button */}
                    <div className="relative inline-block">
                      <button
                        ref={timeframeButtonRef}
                        onClick={() => setIsTimeframeDropdownOpen(!isTimeframeDropdownOpen)}
                        className={`btn-3d-carved relative group ${['30m', '4h', '1w', '1mo', '1y'].includes(config.timeframe) ? 'active' : ''}`}
                        style={{
                          padding: '12px 12px',
                          fontWeight: '700',
                          fontSize: '15px',
                          letterSpacing: '0.8px',
                          borderRadius: '4px',
                          display: 'inline-flex',
                          alignItems: 'center',
                          gap: '4px'
                        }}
                        title="More timeframes"
                      >
                        {config.timeframe === '30m' ? <span>30M</span> : config.timeframe === '4h' ? <span>4H</span> : config.timeframe === '1w' ? <span>W</span> : config.timeframe === '1mo' ? <span>M</span> : config.timeframe === '1y' ? <span>1Y</span> : <span></span>}
                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{ strokeWidth: 3 }}>
                          <path strokeLinecap="round" strokeLinejoin="round" d="M19 9l-7 7-7-7" />
                        </svg>
                      </button>

                      {/* Timeframe Dropdown Menu */}
                      {isTimeframeDropdownOpen && createPortal(
                        <div
                          data-timeframe-dropdown
                          style={{
                            position: 'fixed',
                            top: timeframeButtonRef.current ? timeframeButtonRef.current.getBoundingClientRect().bottom + 10 : 0,
                            left: timeframeButtonRef.current ? timeframeButtonRef.current.getBoundingClientRect().left : 0,
                            zIndex: 100000,
                            background: '#000000',
                            border: '2px solid rgba(255, 133, 0, 0.3)',
                            borderRadius: '8px',
                            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.1)',
                            padding: '12px',
                            minWidth: '180px'
                          }}
                        >
                          <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                            <button
                              onClick={() => {
                                handleTimeframeChange('30m');
                                setIsTimeframeDropdownOpen(false);
                              }}
                              className={`btn-3d-carved ${config.timeframe === '30m' ? 'active' : ''}`}
                              style={{
                                padding: '10px 16px',
                                fontWeight: '700',
                                fontSize: '14px',
                                textAlign: 'left',
                                borderRadius: '4px',
                                width: '100%'
                              }}
                            >
                              30 Minutes (30M)
                            </button>
                            <button
                              onClick={() => {
                                handleTimeframeChange('4h');
                                setIsTimeframeDropdownOpen(false);
                              }}
                              className={`btn-3d-carved ${config.timeframe === '4h' ? 'active' : ''}`}
                              style={{
                                padding: '10px 16px',
                                fontWeight: '700',
                                fontSize: '14px',
                                textAlign: 'left',
                                borderRadius: '4px',
                                width: '100%'
                              }}
                            >
                              4 Hours (4H)
                            </button>
                            <button
                              onClick={() => {
                                handleTimeframeChange('1w');
                                setIsTimeframeDropdownOpen(false);
                              }}
                              className={`btn-3d-carved ${config.timeframe === '1w' ? 'active' : ''}`}
                              style={{
                                padding: '10px 16px',
                                fontWeight: '700',
                                fontSize: '14px',
                                textAlign: 'left',
                                borderRadius: '4px',
                                width: '100%'
                              }}
                            >
                              Weekly (1W)
                            </button>
                            <button
                              onClick={() => {
                                handleTimeframeChange('1mo');
                                setIsTimeframeDropdownOpen(false);
                              }}
                              className={`btn-3d-carved ${config.timeframe === '1mo' ? 'active' : ''}`}
                              style={{
                                padding: '10px 16px',
                                fontWeight: '700',
                                fontSize: '14px',
                                textAlign: 'left',
                                borderRadius: '4px',
                                width: '100%'
                              }}
                            >
                              Monthly (1M)
                            </button>
                            <button
                              onClick={() => {
                                handleTimeframeChange('1y');
                                setIsTimeframeDropdownOpen(false);
                              }}
                              className={`btn-3d-carved ${config.timeframe === '1y' ? 'active' : ''}`}
                              style={{
                                padding: '10px 16px',
                                fontWeight: '700',
                                fontSize: '14px',
                                textAlign: 'left',
                                borderRadius: '4px',
                                width: '100%'
                              }}
                            >
                              Yearly (1Y)
                            </button>
                          </div>
                        </div>,
                        document.body
                      )}
                    </div>
                  </div>

                  {/* Mobile Timeframe Dropdown - Visible only on mobile */}
                  <div className="md:hidden relative">
                    <select
                      value={config.timeframe}
                      onChange={(e) => handleTimeframeChange(e.target.value)}
                      className="btn-3d-carved text-white rounded-md px-3 py-2 text-sm font-bold focus:outline-none focus:ring-2 focus:ring-orange-500"
                      style={{
                        background: '#000000',
                        border: '1px solid rgba(255, 255, 255, 0.15)',
                        borderRadius: '4px',
                        boxShadow: '0 2px 8px rgba(0, 0, 0, 0.95), inset 0 1px 0 rgba(255, 255, 255, 0.05)',
                        outline: 'none'
                      }}
                    >
                      <option value="5m">5M</option>
                      <option value="30m">30M</option>
                      <option value="1h">1H</option>
                      <option value="4h">4H</option>
                      <option value="1d">D</option>
                      <option value="1w">Weekly</option>
                      <option value="1mo">Monthly</option>
                      <option value="1y">Yearly</option>
                    </select>
                  </div>
                </div>

                {/* Chart Type Selector - Moved to left side */}
                <div
                  className="flex items-center chart-type-dropdown"
                  style={{
                    background: '#000000',
                    border: '1px solid rgba(255, 255, 255, 0.15)',
                    borderRadius: '4px',
                    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.95), inset 0 1px 0 rgba(255, 255, 255, 0.05)'
                  }}
                >
                  {/* Desktop Chart Type Buttons - Hidden on mobile */}
                  <div className="hidden md:flex">
                    {MAIN_CHART_TYPES.map((type, index) => (
                      <button
                        key={type.value}
                        onClick={() => handleChartTypeChange(type.value as ChartConfig['chartType'])}
                        className={`btn-3d-carved relative group ${config.chartType === type.value ? 'active' : ''}`}
                        style={{
                          padding: '10px 14px',
                          fontSize: '16px',
                          fontWeight: '700',
                          borderRadius: '4px',
                          color: 'white'
                        }}
                        title={type.label}
                      >
                        {type.icon}
                      </button>
                    ))}
                  </div>

                  {/* Mobile Chart Type Button - Icon only for compact size */}
                  <div className="md:hidden relative">
                    <button
                      onClick={() => handleChartTypeChange(config.chartType === 'candlestick' ? 'line' : 'candlestick')}
                      className="btn-3d-carved font-bold focus:outline-none focus:ring-2 focus:ring-orange-500"
                      style={{
                        background: '#000000',
                        border: '1px solid rgba(255, 255, 255, 0.15)',
                        borderRadius: '4px',
                        boxShadow: '0 2px 8px rgba(0, 0, 0, 0.95), inset 0 1px 0 rgba(255, 255, 255, 0.05)',
                        color: '#ff6600',
                        padding: '6px',
                        minWidth: 'auto',
                        width: 'auto',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center'
                      }}
                      title={config.chartType === 'candlestick' ? 'Switch to Line Chart' : 'Switch to Candlestick Chart'}
                    >
                      {config.chartType === 'candlestick' ? (
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                          <line x1="3" y1="2" x2="3" y2="14" stroke="currentColor" strokeWidth="1" />
                          <rect x="2" y="4" width="2" height="4" fill="currentColor" />
                          <line x1="7" y1="1" x2="7" y2="13" stroke="currentColor" strokeWidth="1" />
                          <rect x="6" y="3" width="2" height="6" fill="none" stroke="currentColor" strokeWidth="1" />
                          <line x1="11" y1="3" x2="11" y2="15" stroke="currentColor" strokeWidth="1" />
                          <rect x="10" y="5" width="2" height="3" fill="currentColor" />
                        </svg>
                      ) : (
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                          <path
                            d="M1 13 L4 9 L7 11 L10 6 L13 8 L15 4"
                            stroke="currentColor"
                            strokeWidth="2"
                            fill="none"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                          />
                          <circle cx="1" cy="13" r="1.5" fill="currentColor" />
                          <circle cx="4" cy="9" r="1.5" fill="currentColor" />
                          <circle cx="7" cy="11" r="1.5" fill="currentColor" />
                          <circle cx="10" cy="6" r="1.5" fill="currentColor" />
                          <circle cx="13" cy="8" r="1.5" fill="currentColor" />
                          <circle cx="15" cy="4" r="1.5" fill="currentColor" />
                        </svg>
                      )}
                    </button>
                  </div>
                </div>

                {/* Expected Range Button - Standalone */}
                <div className="ml-4 relative">
                  <button
                    ref={expectedRangeButtonRef}
                    onClick={() => setIsExpectedRangeDropdownOpen(!isExpectedRangeDropdownOpen)}
                    className={`btn-3d-carved btn-expected-range relative group flex items-center space-x-2 ${isExpectedRangeActive ? 'active' : ''}`}
                    style={{
                      padding: '10px 14px',
                      fontWeight: '700',
                      fontSize: '13px',
                      borderRadius: '4px',
                      color: 'white'
                    }}
                  >
                    <span style={{ color: 'white' }}>EXPECTED RANGE</span>
                    <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                    </svg>
                    {isLoadingExpectedRange && (
                      <div className="animate-spin w-3 h-3 border border-white border-t-transparent rounded-full"></div>
                    )}
                  </button>

                  {/* Expected Range Dropdown */}
                  {isExpectedRangeDropdownOpen && createPortal(
                    <div
                      style={{
                        position: 'fixed',
                        top: expectedRangeButtonRef.current ? expectedRangeButtonRef.current.getBoundingClientRect().bottom + 10 : 0,
                        left: expectedRangeButtonRef.current ? expectedRangeButtonRef.current.getBoundingClientRect().left : 0,
                        zIndex: 100000,
                        background: '#000000',
                        border: '2px solid rgba(255, 133, 0, 0.3)',
                        borderRadius: '8px',
                        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.1)',
                        padding: '12px',
                        minWidth: '180px'
                      }}
                    >
                      <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                        <button
                          onClick={() => {
                            setIsWeeklyActive(!isWeeklyActive);
                            if (!isWeeklyActive && !expectedRangeLevels && !isLoadingExpectedRange) {
                              setIsLoadingExpectedRange(true);
                              calculateExpectedRangeLevels(symbol).then(result => {
                                if (result) {
                                  setExpectedRangeLevels(result.levels);
                                }
                                setIsLoadingExpectedRange(false);
                              });
                            }
                            if (!isWeeklyActive || isMonthlyActive || isCustomActive) setIsExpectedRangeActive(true);
                            else if (isWeeklyActive && !isMonthlyActive && !isCustomActive) setIsExpectedRangeActive(false);
                            setIsExpectedRangeDropdownOpen(false);
                          }}
                          className={`btn-3d-carved ${isWeeklyActive ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          Weekly Range
                        </button>
                        <button
                          onClick={() => {
                            setIsMonthlyActive(!isMonthlyActive);
                            if (!isMonthlyActive && !expectedRangeLevels && !isLoadingExpectedRange) {
                              setIsLoadingExpectedRange(true);
                              calculateExpectedRangeLevels(symbol).then(result => {
                                if (result) {
                                  setExpectedRangeLevels(result.levels);
                                }
                                setIsLoadingExpectedRange(false);
                              });
                            }
                            if (!isMonthlyActive || isWeeklyActive || isCustomActive) setIsExpectedRangeActive(true);
                            else if (isMonthlyActive && !isWeeklyActive && !isCustomActive) setIsExpectedRangeActive(false);
                            setIsExpectedRangeDropdownOpen(false);
                          }}
                          className={`btn-3d-carved ${isMonthlyActive ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          Monthly Range
                        </button>
                        <button
                          onClick={() => {
                            setShowCustomDatePicker(!showCustomDatePicker);
                          }}
                          className={`btn-3d-carved ${isCustomActive ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          Custom Range
                        </button>

                        {/* Custom Date Picker */}
                        {showCustomDatePicker && (
                          <div style={{
                            marginTop: '8px',
                            padding: '12px',
                            background: '#0a0a0a',
                            borderRadius: '4px',
                            border: '1px solid rgba(255, 133, 0, 0.3)',
                            maxWidth: '200px'
                          }}>
                            <label style={{ display: 'block', color: '#ff8500', fontSize: '12px', fontWeight: '700', marginBottom: '8px' }}>
                              Select Expiration Date:
                            </label>
                            <input
                              type="date"
                              value={pendingCustomDate}
                              onChange={(e) => setPendingCustomDate(e.target.value)}
                              min={new Date().toISOString().split('T')[0]}
                              style={{
                                width: '100%',
                                padding: '10px',
                                background: '#000000',
                                border: '1px solid rgba(255, 133, 0, 0.5)',
                                borderRadius: '4px',
                                color: 'white',
                                fontSize: '14px',
                                fontWeight: '600',
                                cursor: 'pointer',
                                colorScheme: 'dark'
                              }}
                            />
                            <button
                              onClick={() => {
                                if (pendingCustomDate) {
                                  setCustomExpirationDate(pendingCustomDate);
                                  setIsLoadingExpectedRange(true);
                                  setIsCustomActive(true);
                                  setIsExpectedRangeActive(true);
                                  calculateExpectedRangeLevels(symbol, pendingCustomDate).then(result => {
                                    if (result) {
                                      setExpectedRangeLevels(result.levels);
                                    }
                                    setIsLoadingExpectedRange(false);
                                  });
                                  setIsExpectedRangeDropdownOpen(false);
                                  setShowCustomDatePicker(false);
                                }
                              }}
                              disabled={!pendingCustomDate}
                              className="btn-3d-carved"
                              style={{
                                width: '100%',
                                padding: '10px',
                                marginTop: '10px',
                                background: pendingCustomDate ? 'linear-gradient(135deg, rgba(255, 133, 0, 0.2) 0%, rgba(255, 133, 0, 0.1) 100%)' : '#1a1a1a',
                                border: pendingCustomDate ? '1px solid rgba(255, 133, 0, 0.5)' : '1px solid #333',
                                borderRadius: '4px',
                                color: pendingCustomDate ? '#ff8500' : '#666',
                                fontSize: '14px',
                                fontWeight: '700',
                                cursor: pendingCustomDate ? 'pointer' : 'not-allowed',
                                opacity: pendingCustomDate ? 1 : 0.5
                              }}
                            >
                              SCAN
                            </button>
                          </div>
                        )}
                      </div>
                    </div>,
                    document.body
                  )}

                  {/* Click outside to close dropdown */}
                  {isExpectedRangeDropdownOpen && createPortal(
                    <div
                      className="fixed inset-0"
                      style={{ zIndex: 99998 }}
                      onClick={() => setIsExpectedRangeDropdownOpen(false)}
                    />,
                    document.body
                  )}
                </div>

                {/* Seasonal Button with Dropdown */}
                <div className="ml-4 relative">
                  <button
                    ref={seasonalButtonRef}
                    onClick={() => setIsSeasonalDropdownOpen(!isSeasonalDropdownOpen)}
                    className={`btn-3d-carved btn-seasonal relative group flex items-center space-x-2 ${isSeasonalActive ? 'active' : ''}`}
                    style={{
                      padding: '10px 14px',
                      fontWeight: '700',
                      fontSize: '13px',
                      borderRadius: '4px',
                      transition: 'all 0.2s ease'
                    }}
                  >
                    <span>SEASONAL</span>
                    <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                    </svg>
                  </button>

                  {/* Seasonal Dropdown */}
                  {isSeasonalDropdownOpen && createPortal(
                    <div
                      style={{
                        position: 'fixed',
                        top: seasonalButtonRef.current ? seasonalButtonRef.current.getBoundingClientRect().bottom + 10 : 0,
                        left: seasonalButtonRef.current ? seasonalButtonRef.current.getBoundingClientRect().left : 0,
                        zIndex: 100000,
                        background: '#000000',
                        border: '2px solid rgba(255, 133, 0, 0.3)',
                        borderRadius: '8px',
                        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.1)',
                        padding: '12px',
                        minWidth: '180px'
                      }}
                    >
                      <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                        <button
                          onClick={async () => {
                            const newState = !isSeasonal20YActive;
                            setIsSeasonal20YActive(newState);

                            if (newState) {
                              // Load data if not already loaded
                              if (!seasonal20YData) {
                                setIsLoadingSeasonalProjection(true);
                                const projection = await calculateSeasonalityProjection(symbol, 20, data);
                                setSeasonal20YData(projection);
                                setIsLoadingSeasonalProjection(false);
                              }
                              setIsSeasonalActive(true);
                            } else {
                              // Check if any seasonal is still active
                              if (!isSeasonal15YActive && !isSeasonal10YActive && !isSeasonalElectionActive) {
                                setIsSeasonalActive(false);
                              }
                            }
                          }}
                          className={`btn-3d-carved ${isSeasonal20YActive ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          20 Y
                        </button>
                        <button
                          onClick={async () => {
                            const newState = !isSeasonal15YActive;
                            setIsSeasonal15YActive(newState);

                            if (newState) {
                              // Load data if not already loaded
                              if (!seasonal15YData) {
                                setIsLoadingSeasonalProjection(true);
                                const projection = await calculateSeasonalityProjection(symbol, 15, data);
                                setSeasonal15YData(projection);
                                setIsLoadingSeasonalProjection(false);
                              }
                              setIsSeasonalActive(true);
                            } else {
                              // Check if any seasonal is still active
                              if (!isSeasonal20YActive && !isSeasonal10YActive && !isSeasonalElectionActive) {
                                setIsSeasonalActive(false);
                              }
                            }
                          }}
                          className={`btn-3d-carved ${isSeasonal15YActive ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          15 Y
                        </button>
                        <button
                          onClick={async () => {
                            const newState = !isSeasonal10YActive;
                            setIsSeasonal10YActive(newState);

                            if (newState) {
                              // Load data if not already loaded
                              if (!seasonal10YData) {
                                setIsLoadingSeasonalProjection(true);
                                const projection = await calculateSeasonalityProjection(symbol, 10, data);
                                setSeasonal10YData(projection);
                                setIsLoadingSeasonalProjection(false);
                              }
                              setIsSeasonalActive(true);
                            } else {
                              // Check if any seasonal is still active
                              if (!isSeasonal20YActive && !isSeasonal15YActive && !isSeasonalElectionActive) {
                                setIsSeasonalActive(false);
                              }
                            }
                          }}
                          className={`btn-3d-carved ${isSeasonal10YActive ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          10 Y
                        </button>
                        <button
                          onClick={async () => {
                            const newState = !isSeasonalElectionActive;
                            setIsSeasonalElectionActive(newState);

                            if (newState) {
                              // Load data if not already loaded
                              if (!seasonalElectionData) {
                                setIsLoadingSeasonalProjection(true);
                                const currentCycle = getCurrentElectionCycle();
                                console.log(`ðŸ“Š Using current election cycle: ${currentCycle}`);
                                const projection = await calculateSeasonalityProjection(symbol, 20, data, currentCycle);
                                setSeasonalElectionData(projection);
                                setIsLoadingSeasonalProjection(false);
                              }
                              setIsSeasonalActive(true);
                            } else {
                              // Check if any seasonal is still active
                              if (!isSeasonal20YActive && !isSeasonal15YActive && !isSeasonal10YActive) {
                                setIsSeasonalActive(false);
                              }
                            }
                          }}
                          className={`btn-3d-carved ${isSeasonalElectionActive ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          Election
                        </button>
                        <button
                          onClick={() => {
                            setIsEventDropdownOpen(!isEventDropdownOpen);
                          }}
                          className={`btn-3d-carved ${isSeasonalEventActive ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center'
                          }}
                        >
                          <span>Event Seasonal</span>
                          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                          </svg>
                        </button>
                      </div>
                    </div>,
                    document.body
                  )}

                  {/* Event Seasonal Sub-Dropdown */}
                  {isEventDropdownOpen && createPortal(
                    <div
                      style={{
                        position: 'fixed',
                        top: seasonalButtonRef.current ? seasonalButtonRef.current.getBoundingClientRect().bottom + 10 : 0,
                        left: seasonalButtonRef.current ? seasonalButtonRef.current.getBoundingClientRect().right + 10 : 0,
                        zIndex: 100001,
                        background: '#000000',
                        border: '2px solid rgba(255, 133, 0, 0.3)',
                        borderRadius: '8px',
                        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.1)',
                        padding: '12px',
                        minWidth: '200px',
                        maxHeight: '400px',
                        overflowY: 'auto'
                      }}
                    >
                      <div style={{ display: 'flex', flexDirection: 'column', gap: '6px' }}>
                        <div style={{ color: '#ff8500', fontSize: '11px', fontWeight: 'bold', marginBottom: '4px', textTransform: 'uppercase' }}>Holidays</div>
                        {['Thanksgiving', 'Christmas', 'New Year', 'Presidents Day', 'MLK Day', 'Memorial Day', 'July 4th', 'Labor Day'].map(event => (
                          <button
                            key={event}
                            onClick={() => {
                              const eventKey = event.toLowerCase().replace(/\s+/g, '');
                              setSelectedSeasonalEvent(eventKey);
                              calculateEventSeasonal(eventKey, data);
                              setIsEventDropdownOpen(false);
                              setIsSeasonalDropdownOpen(false);
                            }}
                            className="btn-3d-carved"
                            style={{ padding: '8px 12px', fontSize: '12px', textAlign: 'left', borderRadius: '4px', width: '100%' }}
                          >
                            {event}
                          </button>
                        ))}

                        <div style={{ color: '#ff8500', fontSize: '11px', fontWeight: 'bold', margin: '8px 0 4px', textTransform: 'uppercase' }}>Options</div>
                        {['Quad Witching Mar', 'Quad Witching Jun', 'Quad Witching Sep', 'Quad Witching Dec', 'Monthly OpEx'].map(event => (
                          <button
                            key={event}
                            onClick={() => {
                              const eventKey = event.toLowerCase().replace(/\s+/g, '-');
                              setSelectedSeasonalEvent(eventKey);
                              calculateEventSeasonal(eventKey, data);
                              setIsEventDropdownOpen(false);
                            }}
                            className="btn-3d-carved"
                            style={{ padding: '8px 12px', fontSize: '12px', textAlign: 'left', borderRadius: '4px', width: '100%' }}
                          >
                            {event}
                          </button>
                        ))}

                        <div style={{ color: '#ff8500', fontSize: '11px', fontWeight: 'bold', margin: '8px 0 4px', textTransform: 'uppercase' }}>Rallies</div>
                        {['Year End Rally', 'Halloween Rally', 'Santa Rally'].map(event => (
                          <button
                            key={event}
                            onClick={() => {
                              const eventKey = event.toLowerCase().replace(/\s+/g, '');
                              setSelectedSeasonalEvent(eventKey);
                              calculateEventSeasonal(eventKey, data);
                              setIsEventDropdownOpen(false);
                            }}
                            className="btn-3d-carved"
                            style={{ padding: '8px 12px', fontSize: '12px', textAlign: 'left', borderRadius: '4px', width: '100%' }}
                          >
                            {event}
                          </button>
                        ))}

                        <div style={{ color: '#ff8500', fontSize: '11px', fontWeight: 'bold', margin: '8px 0 4px', textTransform: 'uppercase' }}>Earnings</div>
                        {['Q1 Earnings', 'Q2 Earnings', 'Q3 Earnings', 'Q4 Earnings'].map(event => (
                          <button
                            key={event}
                            onClick={() => {
                              const eventKey = event.toLowerCase().replace(/\s+/g, '-');
                              setSelectedSeasonalEvent(eventKey);
                              calculateEventSeasonal(eventKey, data);
                              setIsEventDropdownOpen(false);
                              setIsSeasonalDropdownOpen(false);
                            }}
                            className="btn-3d-carved"
                            style={{ padding: '8px 12px', fontSize: '12px', textAlign: 'left', borderRadius: '4px', width: '100%' }}
                          >
                            {event}
                          </button>
                        ))}
                      </div>
                    </div>,
                    document.body
                  )}

                  {/* Click outside to close event dropdown */}
                  {isEventDropdownOpen && createPortal(
                    <div
                      className="fixed inset-0"
                      style={{ zIndex: 100000 }}
                      onClick={() => setIsEventDropdownOpen(false)}
                    />,
                    document.body
                  )}

                  {/* Click outside to close dropdown */}
                  {isSeasonalDropdownOpen && createPortal(
                    <div
                      className="fixed inset-0"
                      style={{ zIndex: 99998 }}
                      onClick={() => setIsSeasonalDropdownOpen(false)}
                    />,
                    document.body
                  )}
                </div>

                {/* GEX Button with Dropdown - Next to Expected Range */}
                <div className="ml-4 relative">
                  <button
                    ref={gexButtonRef}
                    onClick={() => setIsGexDropdownOpen(!isGexDropdownOpen)}
                    disabled={isGexLoading}
                    className={`btn-3d-carved btn-gex relative group flex items-center space-x-2 ${isGexActive ? 'active' : ''}`}
                    style={{
                      padding: '10px 14px',
                      fontWeight: '700',
                      fontSize: '13px',
                      borderRadius: '4px',
                      opacity: isGexLoading ? 0.6 : 1
                    }}
                  >
                    <span>{isGexLoading ? `SCANNING ${gexProgress}%` : 'GEX'}</span>
                    <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                    </svg>
                  </button>

                  {/* GEX Dropdown Menu - Using Portal */}
                  {isGexDropdownOpen && createPortal(
                    <div
                      style={{
                        position: 'fixed',
                        top: gexButtonRef.current ? gexButtonRef.current.getBoundingClientRect().bottom + 10 : 0,
                        left: gexButtonRef.current ? gexButtonRef.current.getBoundingClientRect().left : 0,
                        zIndex: 100000,
                        background: '#000000',
                        border: '2px solid rgba(255, 133, 0, 0.3)',
                        borderRadius: '8px',
                        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.1)',
                        padding: '12px',
                        minWidth: '180px'
                      }}
                    >
                      <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                        <button
                          onClick={() => {
                            setIsLiveGexActive(!isLiveGexActive);
                            if (!isLiveGexActive) handleLiveGEXClick();
                            if (!isLiveGexActive || isOiGexActive) setIsGexActive(true);
                            else if (isLiveGexActive && !isOiGexActive) setIsGexActive(false);
                            setIsGexDropdownOpen(false);
                          }}
                          className={`btn-3d-carved ${isLiveGexActive ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          Live GEX
                        </button>
                        <button
                          onClick={() => {
                            setIsOiGexActive(!isOiGexActive);
                            if (!isOiGexActive) handleOIGEXClick();
                            if (!isOiGexActive || isLiveGexActive) setIsGexActive(true);
                            else if (isOiGexActive && !isLiveGexActive) setIsGexActive(false);
                            setIsGexDropdownOpen(false);
                          }}
                          className={`btn-3d-carved ${isOiGexActive ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          OI GEX
                        </button>
                      </div>
                    </div>,
                    document.body
                  )}

                  {/* Click outside to close dropdown */}
                  {isGexDropdownOpen && createPortal(
                    <div
                      className="fixed inset-0"
                      style={{ zIndex: 99998 }}
                      onClick={() => setIsGexDropdownOpen(false)}
                    />,
                    document.body
                  )}
                </div>

                {/* IV & HV Button with Dropdown */}
                <div className="ml-4 relative">
                  <button
                    ref={ivhvButtonRef}
                    onClick={() => setIsIVHVDropdownOpen(!isIVHVDropdownOpen)}
                    disabled={isIVLoading}
                    className={`btn-3d-carved btn-ivhv relative group flex items-center space-x-2 ${isAnyIVHVActive ? 'active' : ''}`}
                    style={{
                      padding: '10px 14px',
                      fontWeight: '700',
                      fontSize: '13px',
                      borderRadius: '4px',
                      opacity: isIVLoading ? 0.6 : 1
                    }}
                  >
                    <span>{isIVLoading ? `LOADING ${ivProgress}%` : 'IV & HV'}</span>
                    <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                    </svg>
                    {isAnyIVHVActive && (
                      <div
                        className="absolute -top-1 -right-1 w-3 h-3 bg-orange-400 rounded-full"
                        style={{
                          boxShadow: '0 0 6px rgba(255, 140, 0, 0.8)',
                          animation: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite'
                        }}
                      />
                    )}
                  </button>

                  {/* IV & HV Dropdown Menu - Using Portal */}
                  {isIVHVDropdownOpen && createPortal(
                    <div
                      style={{
                        position: 'fixed',
                        top: ivhvButtonRef.current ? ivhvButtonRef.current.getBoundingClientRect().bottom + 10 : 0,
                        left: ivhvButtonRef.current ? ivhvButtonRef.current.getBoundingClientRect().left : 0,
                        zIndex: 100000,
                        background: '#000000',
                        border: '2px solid rgba(255, 133, 0, 0.3)',
                        borderRadius: '8px',
                        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.1)',
                        padding: '12px',
                        minWidth: '220px'
                      }}
                    >
                      {/* Header */}
                      <div style={{
                        borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
                        paddingBottom: '6px',
                        marginBottom: '6px'
                      }}>
                        <span style={{ color: '#ff8c00', fontWeight: '700', fontSize: '12px', letterSpacing: '0.5px' }}>
                          VOLATILITY INDICATORS
                        </span>
                      </div>

                      <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                        {/* Implied Volatility - Single toggle, line options inside panel */}
                        <button
                          onClick={() => {
                            setShowIVPanel(!showIVPanel);
                            if (!showIVPanel && ivData.length === 0) {
                              fetchIVData();
                            }
                          }}
                          className={`btn-3d-carved ${showIVPanel ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          Implied Volatility
                        </button>

                        {/* IV Rank */}
                        <button
                          onClick={() => {
                            setShowIVRankIndicator(!showIVRankIndicator);
                            if (!showIVRankIndicator && ivData.length === 0) {
                              fetchIVData();
                            }
                          }}
                          className={`btn-3d-carved ${showIVRankIndicator ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          IV Rank
                        </button>

                        {/* IV Percentile */}
                        <button
                          onClick={() => {
                            setShowIVPercentileIndicator(!showIVPercentileIndicator);
                            if (!showIVPercentileIndicator && ivData.length === 0) {
                              fetchIVData();
                            }
                          }}
                          className={`btn-3d-carved ${showIVPercentileIndicator ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          IV Percentile
                        </button>

                        {/* Historical Volatility */}
                        <button
                          onClick={() => {
                            setShowHVIndicator(!showHVIndicator);
                            if (!showHVIndicator && ivData.length === 0) {
                              fetchIVData();
                            }
                          }}
                          className={`btn-3d-carved ${showHVIndicator ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          Historical Volatility
                        </button>

                        {/* HV Window Selection (only visible when HV is active) */}
                        {showHVIndicator && (
                          <div style={{
                            marginTop: '8px',
                            paddingTop: '8px',
                            borderTop: '1px solid rgba(255, 255, 255, 0.1)',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'space-between'
                          }}>
                            <span style={{ color: 'rgba(255, 255, 255, 0.6)', fontSize: '11px' }}>HV Window:</span>
                            <div style={{ display: 'flex', gap: '4px' }}>
                              {[10, 20, 30, 60].map((window) => (
                                <button
                                  key={window}
                                  onClick={() => {
                                    setHVWindow(window);
                                    recalculateHV(window);
                                  }}
                                  style={{
                                    padding: '4px 8px',
                                    background: hvWindow === window ? '#00d4ff' : 'rgba(255, 255, 255, 0.1)',
                                    border: 'none',
                                    borderRadius: '4px',
                                    color: hvWindow === window ? '#000' : '#fff',
                                    fontSize: '11px',
                                    fontWeight: '600',
                                    cursor: 'pointer'
                                  }}
                                >
                                  {window}D
                                </button>
                              ))}
                            </div>
                          </div>
                        )}

                        {/* Divider */}
                        <div style={{ borderTop: '1px solid rgba(255, 255, 255, 0.1)', margin: '8px 0' }}></div>

                        {/* Lookback Period */}
                        <div style={{
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'space-between',
                          padding: '4px 0'
                        }}>
                          <span style={{ color: 'rgba(255, 255, 255, 0.6)', fontSize: '11px' }}>Lookback:</span>
                          <select
                            value={ivLookbackPeriod}
                            onChange={(e) => {
                              setIVLookbackPeriod(Number(e.target.value));
                              // Refetch data with new lookback period
                              if (isAnyIVHVActive) {
                                setIVData([]); // Clear existing data to trigger refetch
                              }
                            }}
                            style={{
                              background: 'rgba(255, 255, 255, 0.1)',
                              border: 'none',
                              borderRadius: '4px',
                              color: '#fff',
                              padding: '4px 8px',
                              fontSize: '11px',
                              cursor: 'pointer'
                            }}
                          >
                            <option value={365}>1 Year</option>
                            <option value={730}>2 Years</option>
                            <option value={1095}>3 Years</option>
                            <option value={1460}>4 Years</option>
                          </select>
                        </div>

                        {/* Refresh Button */}
                        {isAnyIVHVActive && (
                          <button
                            onClick={() => {
                              setIVData([]);
                              fetchIVData();
                            }}
                            disabled={isIVLoading}
                            style={{
                              marginTop: '8px',
                              padding: '8px 12px',
                              background: 'linear-gradient(145deg, #ff8c00 0%, #ff6b00 100%)',
                              border: 'none',
                              borderRadius: '4px',
                              color: '#000',
                              fontSize: '12px',
                              fontWeight: '700',
                              cursor: isIVLoading ? 'not-allowed' : 'pointer',
                              opacity: isIVLoading ? 0.6 : 1
                            }}
                          >
                            {isIVLoading ? `LOADING ${ivProgress}%...` : 'â†» REFRESH DATA'}
                          </button>
                        )}
                      </div>
                    </div>,
                    document.body
                  )}

                  {/* Click outside to close dropdown */}
                  {isIVHVDropdownOpen && createPortal(
                    <div
                      className="fixed inset-0"
                      style={{ zIndex: 99998 }}
                      onClick={() => setIsIVHVDropdownOpen(false)}
                    />,
                    document.body
                  )}
                </div>

                {/* Technalysis Button */}
                <div className="ml-4 relative">
                  <button
                    ref={technalysisButtonRef}
                    onClick={() => setIsTechnalysisDropdownOpen(!isTechnalysisDropdownOpen)}
                    className={`btn-3d-carved relative group flex items-center space-x-2 ${technalysisActive ? 'active' : ''}`}
                    style={{
                      padding: '10px 16px',
                      fontWeight: '700',
                      fontSize: '13px',
                      borderRadius: '4px',
                      color: 'white'
                    }}
                  >
                    <span style={{ color: 'white' }}>TECHNALYSIS</span>
                    <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                    </svg>
                    {technalysisActive && (
                      <div
                        className="absolute -top-1 -right-1 w-3 h-3 bg-blue-400 rounded-full"
                        style={{
                          boxShadow: '0 0 6px rgba(33, 150, 243, 0.8)',
                          animation: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite'
                        }}
                      />
                    )}
                  </button>

                  {/* Technalysis Dropdown Menu */}
                  {isTechnalysisDropdownOpen && createPortal(
                    <div
                      onClick={(e) => e.stopPropagation()}
                      className="absolute w-48"
                      style={{
                        top: technalysisButtonRef.current ? technalysisButtonRef.current.getBoundingClientRect().bottom + 10 : 100,
                        left: technalysisButtonRef.current ? technalysisButtonRef.current.getBoundingClientRect().left : 400,
                        zIndex: 100000,
                        background: '#000000',
                        border: '2px solid rgba(255, 133, 0, 0.3)',
                        borderRadius: '8px',
                        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.1)',
                        padding: '12px'
                      }}
                    >
                      <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                        <button
                          onClick={() => {
                            setTechnalysisActive(!technalysisActive);
                            setIsTechnalysisDropdownOpen(false);
                          }}
                          className={`btn-3d-carved ${technalysisActive ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          Enable All
                        </button>

                        <div style={{ borderTop: '1px solid rgba(255, 255, 255, 0.1)', margin: '4px 0' }}></div>

                        <button
                          onClick={() => {
                            setTechnalysisFeatures(prev => ({ ...prev, orderBlocks: !prev.orderBlocks }));
                          }}
                          className={`btn-3d-carved ${technalysisFeatures.orderBlocks ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          Zones
                        </button>

                        <button
                          onClick={() => {
                            setTechnalysisFeatures(prev => ({ ...prev, fvg: !prev.fvg }));
                          }}
                          className={`btn-3d-carved ${technalysisFeatures.fvg ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          Fills
                        </button>

                        <button
                          onClick={() => {
                            setTechnalysisFeatures(prev => ({ ...prev, liquidity: !prev.liquidity }));
                          }}
                          className={`btn-3d-carved ${technalysisFeatures.liquidity ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          Hunting
                        </button>

                        <button
                          onClick={() => {
                            setTechnalysisFeatures(prev => ({ ...prev, structure: !prev.structure }));
                          }}
                          className={`btn-3d-carved ${technalysisFeatures.structure ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          Trend
                        </button>

                        <button
                          onClick={() => {
                            setTechnalysisFeatures(prev => ({ ...prev, premiumDiscount: !prev.premiumDiscount }));
                          }}
                          className={`btn-3d-carved ${technalysisFeatures.premiumDiscount ? 'active' : ''}`}
                          style={{
                            padding: '10px 16px',
                            fontWeight: '700',
                            fontSize: '14px',
                            textAlign: 'left',
                            borderRadius: '4px',
                            width: '100%'
                          }}
                        >
                          Premium/Discount
                        </button>
                      </div>
                    </div>,
                    document.body
                  )}

                  {/* Click outside to close dropdown */}
                  {isTechnalysisDropdownOpen && createPortal(
                    <div
                      className="fixed inset-0"
                      style={{ zIndex: 99998 }}
                      onClick={() => setIsTechnalysisDropdownOpen(false)}
                    />,
                    document.body
                  )}
                </div>
              </div>

              {/* Live FlowMoves Button with Dropdown */}
              <div className="ml-4 relative">
                <button
                  ref={flowMovesButtonRef}
                  onClick={() => setIsFlowMovesDropdownOpen(!isFlowMovesDropdownOpen)}
                  className={`btn-3d-carved btn-drawings relative group flex items-center space-x-2 ${isFlowChartActive ? 'active' : ''}`}
                  style={{
                    padding: '10px 14px',
                    fontWeight: '700',
                    fontSize: '13px',
                    borderRadius: '4px'
                  }}
                  title="Live FlowMoves"
                >
                  <span>Live FlowMoves {isFlowChartActive ? `(${flowMovesTimeframe})` : ''}</span>
                  {isFlowChartActive && <span style={{ color: '#22c55e', fontSize: '16px', marginLeft: '8px' }}>âœ“</span>}
                  <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                  </svg>
                </button>

                {/* FlowMoves Timeframe Dropdown - Using Portal */}
                {isFlowMovesDropdownOpen && createPortal(
                  <div
                    className="absolute w-48"
                    style={{
                      top: flowMovesButtonRef.current ? flowMovesButtonRef.current.getBoundingClientRect().bottom + 10 : 0,
                      left: flowMovesButtonRef.current ? flowMovesButtonRef.current.getBoundingClientRect().left : 0,
                      zIndex: 100000,
                      background: '#000000',
                      border: '2px solid rgba(255, 133, 0, 0.3)',
                      borderRadius: '8px',
                      boxShadow: '0 8px 32px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.1)',
                      padding: '12px'
                    }}
                  >
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                      <button
                        onClick={() => {
                          setFlowMovesTimeframe('1D');
                          setIsFlowMovesDropdownOpen(false);
                          setIsFlowChartActive(true);
                          handleLiveFlowMovesClick('1D');
                        }}
                        className={`btn-3d-carved ${flowMovesTimeframe === '1D' ? 'active' : ''}`}
                        style={{
                          padding: '10px 16px',
                          fontWeight: '700',
                          fontSize: '14px',
                          textAlign: 'left',
                          borderRadius: '4px',
                          width: '100%'
                        }}
                      >
                        1 Day
                      </button>

                      <button
                        onClick={() => {
                          setFlowMovesTimeframe('3D');
                          setIsFlowMovesDropdownOpen(false);
                          setIsFlowChartActive(true);
                          handleLiveFlowMovesClick('3D');
                        }}
                        className={`btn-3d-carved ${flowMovesTimeframe === '3D' ? 'active' : ''}`}
                        style={{
                          padding: '10px 16px',
                          fontWeight: '700',
                          fontSize: '14px',
                          textAlign: 'left',
                          borderRadius: '4px',
                          width: '100%'
                        }}
                      >
                        3 Days
                      </button>

                      <button
                        onClick={() => {
                          setFlowMovesTimeframe('1W');
                          setIsFlowMovesDropdownOpen(false);
                          setIsFlowChartActive(true);
                          handleLiveFlowMovesClick('1W');
                        }}
                        className={`btn-3d-carved ${flowMovesTimeframe === '1W' ? 'active' : ''}`}
                        style={{
                          padding: '10px 16px',
                          fontWeight: '700',
                          fontSize: '14px',
                          textAlign: 'left',
                          borderRadius: '4px',
                          width: '100%'
                        }}
                      >
                        1 Week
                      </button>
                    </div>
                  </div>,
                  document.body
                )}
              </div>

              {/* RRG Candle Button with Dropdown */}
              <div className="ml-4 relative">
                <button
                  ref={rrgButtonRef}
                  onClick={() => setIsRrgDropdownOpen(!isRrgDropdownOpen)}
                  className={`btn-3d-carved btn-drawings relative group flex items-center space-x-2 ${isRRGCandleActive ? 'active' : ''}`}
                  style={{
                    padding: '10px 14px',
                    fontWeight: '700',
                    fontSize: '13px',
                    borderRadius: '4px'
                  }}
                  title="RRG Candle - Color code candles by RRG quadrants"
                >
                  <span>RRG Candle {isRRGCandleActive ? `(${rrgMode.toUpperCase()} ${rrgLookbackPeriod}d)` : ''}</span>
                  {isRRGCandleActive && <span style={{ color: '#22c55e', fontSize: '16px', marginLeft: '8px' }}>âœ“</span>}
                  <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                  </svg>
                </button>

                {/* RRG Dropdown Menu - Using Portal */}
                {isRrgDropdownOpen && createPortal(
                  <div
                    data-rrg-dropdown
                    style={{
                      position: 'fixed',
                      top: rrgButtonRef.current ? rrgButtonRef.current.getBoundingClientRect().bottom + 10 : 0,
                      left: rrgButtonRef.current ? rrgButtonRef.current.getBoundingClientRect().left : 0,
                      zIndex: 100000,
                      background: '#000000',
                      border: '2px solid rgba(255, 133, 0, 0.3)',
                      borderRadius: '8px',
                      boxShadow: '0 8px 32px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.1)',
                      padding: '12px',
                      minWidth: '200px'
                    }}>
                    {/* Mode Selection */}
                    <div style={{ marginBottom: '12px' }}>
                      <div style={{
                        fontSize: '11px',
                        color: '#ffffff',
                        marginBottom: '6px',
                        fontWeight: '600',
                        textTransform: 'uppercase',
                        letterSpacing: '0.5px',
                        textAlign: 'center'
                      }}>
                        Mode
                      </div>
                      <div style={{ display: 'flex', gap: '6px' }}>
                        <button
                          onClick={() => {
                            setRrgMode('price');
                            if (isRRGCandleActive) handleRRGCandleClick(rrgLookbackPeriod, 'price');
                          }}
                          style={{
                            flex: 1,
                            padding: '8px 12px',
                            fontSize: '12px',
                            fontWeight: '600',
                            borderRadius: '4px',
                            border: `2px solid ${rrgMode === 'price' ? '#ffffff' : '#444'}`,
                            background: 'transparent',
                            color: rrgMode === 'price' ? '#ffffff' : '#ffffff',
                            cursor: 'pointer'
                          }}
                        >
                          Price
                        </button>
                        <button
                          onClick={() => {
                            setRrgMode('iv');
                            if (isRRGCandleActive) handleRRGCandleClick(rrgIvLookbackPeriod, 'iv');
                          }}
                          style={{
                            flex: 1,
                            padding: '8px 12px',
                            fontSize: '12px',
                            fontWeight: '600',
                            borderRadius: '4px',
                            border: `2px solid ${rrgMode === 'iv' ? '#a855f7' : '#444'}`,
                            background: 'transparent',
                            color: rrgMode === 'iv' ? '#a855f7' : '#ffffff',
                            cursor: 'pointer'
                          }}
                        >
                          IV
                        </button>
                        <button
                          onClick={() => {
                            setRrgMode('ivspy');
                            if (isRRGCandleActive) handleRRGCandleClick(rrgIvLookbackPeriod, 'ivspy');
                          }}
                          style={{
                            flex: 1,
                            padding: '8px 12px',
                            fontSize: '12px',
                            fontWeight: '600',
                            borderRadius: '4px',
                            border: `2px solid ${rrgMode === 'ivspy' ? '#ff8500' : '#444'}`,
                            background: 'transparent',
                            color: rrgMode === 'ivspy' ? '#ff8500' : '#ffffff',
                            cursor: 'pointer'
                          }}
                        >
                          IV/SPY
                        </button>
                      </div>
                    </div>

                    {/* Period Selection */}
                    <div style={{ marginBottom: '12px' }}>
                      <div style={{
                        fontSize: '11px',
                        color: '#ffffff',
                        marginBottom: '6px',
                        fontWeight: '600',
                        textTransform: 'uppercase',
                        letterSpacing: '0.5px'
                      }}>
                        Lookback Period
                      </div>
                      <div style={{ display: 'flex', gap: '6px' }}>
                        {rrgMode === 'price' ? (
                          // Price mode: 10d, 31d, 87d
                          [
                            { value: 10, label: '10d' },
                            { value: 31, label: '31d' },
                            { value: 87, label: '87d' }
                          ].map(({ value, label }) => (
                            <button
                              key={value}
                              onClick={() => {
                                setRrgLookbackPeriod(value as 10 | 31 | 87);
                                if (isRRGCandleActive) handleRRGCandleClick(value, rrgMode);
                              }}
                              style={{
                                flex: 1,
                                padding: '8px',
                                fontSize: '12px',
                                fontWeight: '600',
                                borderRadius: '4px',
                                border: `2px solid ${rrgLookbackPeriod === value ? '#ff8500' : '#444'}`,
                                background: 'transparent',
                                color: rrgLookbackPeriod === value ? '#ff8500' : '#ffffff',
                                cursor: 'pointer'
                              }}
                            >
                              {label}
                            </button>
                          ))
                        ) : (
                          // IV mode: 1mo, 4mo, 1yr
                          [
                            { value: 30, label: '1mo' },
                            { value: 120, label: '4mo' },
                            { value: 365, label: '1yr' }
                          ].map(({ value, label }) => (
                            <button
                              key={value}
                              onClick={() => {
                                setRrgIvLookbackPeriod(value as 30 | 120 | 365);
                                if (isRRGCandleActive) handleRRGCandleClick(value, rrgMode);
                              }}
                              style={{
                                flex: 1,
                                padding: '8px',
                                fontSize: '12px',
                                fontWeight: '600',
                                borderRadius: '4px',
                                border: `2px solid ${rrgIvLookbackPeriod === value ? '#ff8500' : '#444'}`,
                                background: 'transparent',
                                color: rrgIvLookbackPeriod === value ? '#ff8500' : '#ffffff',
                                cursor: 'pointer'
                              }}
                            >
                              {label}
                            </button>
                          ))
                        )}
                      </div>
                    </div>

                    {/* Apply/Toggle Button */}
                    <button
                      onClick={() => {
                        if (!isRRGCandleActive) {
                          const period = (rrgMode === 'iv' || rrgMode === 'ivspy') ? rrgIvLookbackPeriod : rrgLookbackPeriod;
                          handleRRGCandleClick(period, rrgMode);
                        } else {
                          console.log('ðŸ”´ Turning OFF RRG Candle mode');
                          setRrgCandleColors(new Map());
                          setIsRRGCandleActive(false);
                          setRrgIvStartTimestamp(null);
                          // Force immediate re-render
                          setTimeout(() => {
                            if (chartCanvasRef.current) {
                              renderChart();
                            }
                          }, 10);
                        }
                        setIsRrgDropdownOpen(false);
                      }}
                      style={{
                        width: '100%',
                        padding: '10px',
                        fontSize: '13px',
                        fontWeight: '700',
                        borderRadius: '4px',
                        border: 'none',
                        background: isRRGCandleActive
                          ? 'linear-gradient(145deg, #ef4444 0%, #dc2626 100%)'
                          : 'linear-gradient(145deg, #ff8500 0%, #ff6500 100%)',
                        color: '#fff',
                        cursor: 'pointer',
                        textTransform: 'uppercase',
                        letterSpacing: '0.5px'
                      }}
                    >
                      {isRRGCandleActive ? 'Turn Off' : 'Apply'}
                    </button>
                  </div>,
                  document.body
                )}
              </div>

              {/* Drawing Tools - Individual Buttons */}
              <div className="ml-4 flex items-center space-x-2" style={{
                padding: '6px 10px'
              }}>
                <button
                  onClick={() => {
                    setCurrentDrawingTool(currentDrawingTool === 'trendline' ? 'select' : 'trendline');
                  }}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: currentDrawingTool === 'trendline' ? 'rgba(255, 133, 0, 0.3) !important' : 'transparent',
                    border: currentDrawingTool === 'trendline' ? '2px solid #FF8500' : '1px solid #444',
                    color: 'white',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                  title="Trendline"
                >
                  <TbLine className="w-5 h-5" />
                </button>

                <button
                  onClick={() => {
                    setCurrentDrawingTool(currentDrawingTool === 'horizontal' ? 'select' : 'horizontal');
                  }}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: currentDrawingTool === 'horizontal' ? 'rgba(255, 133, 0, 0.3) !important' : 'transparent',
                    border: currentDrawingTool === 'horizontal' ? '2px solid #FF8500' : '1px solid #444',
                    color: 'white',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                  title="Horizontal Line"
                >
                  <TbMinus className="w-5 h-5" />
                </button>

                <button
                  onClick={() => {
                    setCurrentDrawingTool(currentDrawingTool === 'vertical' ? 'select' : 'vertical');
                  }}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: currentDrawingTool === 'vertical' ? 'rgba(255, 133, 0, 0.3) !important' : 'transparent',
                    border: currentDrawingTool === 'vertical' ? '2px solid #FF8500' : '1px solid #444',
                    color: 'white',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                  title="Vertical Line"
                >
                  <TbArrowsVertical className="w-5 h-5" />
                </button>

                <button
                  onClick={() => {
                    setCurrentDrawingTool(currentDrawingTool === 'parallelChannel' ? 'select' : 'parallelChannel');
                  }}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: currentDrawingTool === 'parallelChannel' ? 'rgba(255, 133, 0, 0.3) !important' : 'transparent',
                    border: currentDrawingTool === 'parallelChannel' ? '2px solid #FF8500' : '1px solid #444',
                    color: 'white',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                  title="Parallel Channel"
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <line x1="3" y1="6" x2="21" y2="6" />
                    <line x1="3" y1="18" x2="21" y2="18" />
                  </svg>
                </button>

                <button
                  onClick={() => {
                    setCurrentDrawingTool(currentDrawingTool === 'rectangle' ? 'select' : 'rectangle');
                  }}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: currentDrawingTool === 'rectangle' ? 'rgba(255, 133, 0, 0.3) !important' : 'transparent',
                    border: currentDrawingTool === 'rectangle' ? '2px solid #FF8500' : '1px solid #444',
                    color: 'white',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                  title="Rectangle"
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <rect x="4" y="6" width="16" height="12" />
                  </svg>
                </button>

                <button
                  onClick={() => {
                    setCurrentDrawingTool(currentDrawingTool === 'buyZone' ? 'select' : 'buyZone');
                  }}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: currentDrawingTool === 'buyZone' ? 'rgba(34, 197, 94, 0.3) !important' : 'transparent',
                    border: currentDrawingTool === 'buyZone' ? '2px solid #22c55e' : '1px solid #444',
                    color: '#22c55e',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                  title="Buy Zone"
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="#22c55e" stroke="#22c55e" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <rect x="4" y="6" width="16" height="12" />
                  </svg>
                </button>

                <button
                  onClick={() => {
                    setCurrentDrawingTool(currentDrawingTool === 'sellZone' ? 'select' : 'sellZone');
                  }}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: currentDrawingTool === 'sellZone' ? 'rgba(239, 68, 68, 0.3) !important' : 'transparent',
                    border: currentDrawingTool === 'sellZone' ? '2px solid #ef4444' : '1px solid #444',
                    color: '#ef4444',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                  title="Sell Zone"
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="#ef4444" stroke="#ef4444" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <rect x="4" y="6" width="16" height="12" />
                  </svg>
                </button>

                <button
                  onClick={() => {
                    setCurrentDrawingTool(currentDrawingTool === 'priceRange' ? 'select' : 'priceRange');
                  }}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: currentDrawingTool === 'priceRange' ? 'rgba(255, 133, 0, 0.3) !important' : 'transparent',
                    border: currentDrawingTool === 'priceRange' ? '2px solid #FF8500' : '1px solid #444',
                    color: 'white',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                  title="Price Range"
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <line x1="4" y1="6" x2="20" y2="6" />
                    <line x1="12" y1="6" x2="12" y2="18" />
                    <line x1="4" y1="18" x2="20" y2="18" />
                  </svg>
                </button>

                <button
                  onClick={() => setCurrentDrawingTool(currentDrawingTool === 'brush' ? 'select' : 'brush')}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: currentDrawingTool === 'brush' ? 'rgba(255, 133, 0, 0.3) !important' : 'transparent',
                    border: currentDrawingTool === 'brush' ? '2px solid #FF8500' : '1px solid #444',
                    color: 'white',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                  title="Brush Tool"
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M9.06 11.9l8.07-8.06a1.5 1.5 0 1 1 2.12 2.12l-8.06 8.08" />
                    <path d="M7.07 14.94c-1.66 0-3 1.35-3 3.02 0 1.33-2.5 1.52-2 2.02 1.08 1.1 2.49 2.02 4 2.02 2.2 0 4-1.8 4-4.04a3.01 3.01 0 0 0-3-3.02z" />
                  </svg>
                </button>

                <button
                  onClick={() => setCurrentDrawingTool(currentDrawingTool === 'text' ? 'select' : 'text')}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: currentDrawingTool === 'text' ? 'rgba(255, 133, 0, 0.3) !important' : 'transparent',
                    border: currentDrawingTool === 'text' ? '2px solid #FF8500' : '1px solid #444',
                    color: 'white',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                  title="Text Note Tool"
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <polyline points="4 7 4 4 20 4 20 7" />
                    <line x1="9" y1="20" x2="15" y2="20" />
                    <line x1="12" y1="4" x2="12" y2="20" />
                  </svg>
                </button>

                <div style={{ width: '1px', height: '32px', background: '#444', margin: '0 6px' }} />

                <button
                  onClick={() => setIsDrawingToolLocked(!isDrawingToolLocked)}
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: isDrawingToolLocked ? '#FFD700' : 'transparent',
                    border: isDrawingToolLocked ? '2px solid #FFD700' : '1px solid #444',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '6px',
                    justifyContent: 'center',
                    boxShadow: 'inset 0 2px 4px rgba(0, 0, 0, 0.3), inset 0 -2px 4px rgba(255, 255, 255, 0.05), 0 4px 8px rgba(0, 0, 0, 0.4)'
                  }}
                  title={isDrawingToolLocked ? 'Drawing Lock: ON (Infinite Use)' : 'Drawing Lock: OFF (Single Use)'}
                >
                  {isDrawingToolLocked ? (
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#000" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                      <rect x="5" y="11" width="14" height="10" rx="2" ry="2" />
                      <path d="M7 11V7a5 5 0 0 1 10 0v4" />
                    </svg>
                  ) : (
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                      <rect x="5" y="11" width="14" height="10" rx="2" ry="2" />
                      <path d="M7 11V7a5 5 0 0 1 9.9-1" />
                    </svg>
                  )}
                </button>

                {/* Undo Button */}
                <button
                  onClick={() => {
                    if (historyIndex > 0) {
                      const newIndex = historyIndex - 1;
                      setHistoryIndex(newIndex);
                      setLwChartDrawings(drawingHistory[newIndex]);
                    }
                  }}
                  disabled={historyIndex <= 0}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: historyIndex <= 0 ? '#1e293b' : 'transparent',
                    cursor: historyIndex <= 0 ? 'not-allowed' : 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    opacity: historyIndex <= 0 ? 0.5 : 1
                  }}
                  title="Undo"
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M9 14L4 9L9 4" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                    <path d="M4 9H16C18.2091 9 20 10.7909 20 13C20 15.2091 18.2091 17 16 17H13" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                  </svg>
                </button>

                {/* Redo Button */}
                <button
                  onClick={() => {
                    if (historyIndex < drawingHistory.length - 1) {
                      const newIndex = historyIndex + 1;
                      setHistoryIndex(newIndex);
                      setLwChartDrawings(drawingHistory[newIndex]);
                    }
                  }}
                  disabled={historyIndex >= drawingHistory.length - 1}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: historyIndex >= drawingHistory.length - 1 ? '#1e293b' : 'transparent',
                    cursor: historyIndex >= drawingHistory.length - 1 ? 'not-allowed' : 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    opacity: historyIndex >= drawingHistory.length - 1 ? 0.5 : 1
                  }}
                  title="Redo"
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M15 14L20 9L15 4" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                    <path d="M20 9H8C5.79086 9 4 10.7909 4 13C4 15.2091 5.79086 17 8 17H11" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                  </svg>
                </button>

                {/* Background Toggle Button */}
                <button
                  onClick={() => setIsBackgroundVisible(!isBackgroundVisible)}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    background: isBackgroundVisible ? '#22c55e' : 'transparent',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                  title={isBackgroundVisible ? "Hide Drawings" : "Show Drawings"}
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    {isBackgroundVisible ? (
                      <>
                        <path d="M2 12C2 12 5 5 12 5C19 5 22 12 22 12C22 12 19 19 12 19C5 19 2 12 2 12Z" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                        <circle cx="12" cy="12" r="3" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                      </>
                    ) : (
                      <>
                        <path d="M3 3L21 21" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
                        <path d="M10.5 10.5C10.1872 10.8128 10 11.2448 10 11.7C10 12.7046 10.8954 13.5 12 13.5C12.5552 13.5 12.9872 13.3128 13.3 13" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
                        <path d="M7.36 7.36C5.68 8.68 4.5 10.5 4.5 12C4.5 12 7 17 12 17C13.5 17 14.82 16.64 15.64 16.36" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
                        <path d="M12 7C17 7 19.5 12 19.5 12C19.5 12 19 13.18 17.88 14.5" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
                      </>
                    )}
                  </svg>
                </button>

                <button
                  onClick={() => {
                    updateDrawingsWithHistory([]);
                    setCurrentDrawingTool('select');
                    if (typeof window !== 'undefined') {
                      localStorage.removeItem('lwChartDrawings');
                    }
                  }}
                  className="btn-3d-carved"
                  style={{
                    padding: '8px 12px',
                    fontWeight: '600',
                    fontSize: '14px',
                    borderRadius: '4px',
                    border: '1px solid #DC143C',
                    background: 'transparent',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '6px',
                    justifyContent: 'center'
                  }}
                  title="Clear All Drawings"
                >
                  <TbX className="w-4 h-4" style={{ color: '#DC143C' }} />
                  <span style={{ color: '#DC143C' }}>Clear</span>
                </button>
              </div>



              {/* Spacer to push remaining items to the right */}
              <div className="flex-1"></div>

              {/* Remaining Controls on the Right */}
              <div className="flex items-center flex-shrink-0">

                {/* Enhanced Action Buttons */}
                <div className="flex items-center space-x-4">

                </div>

                {/* GUIDE AI Button - Matches toolbar button style */}
                <button
                  onClick={() => setGuideAIOpen(!isGuideAIOpen)}
                  className={`btn-3d-carved relative group ${isGuideAIOpen ? 'active' : ''}`}
                  style={{
                    padding: '10px 14px',
                    fontWeight: '700',
                    fontSize: '13px',
                    borderRadius: '4px',
                    color: isGuideAIOpen ? '#FF8833' : '#888',
                    marginRight: '12px'
                  }}
                  title="Toggle Guide AI Panel"
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
                  </svg>
                </button>

                {/* MULTICHART LAYOUT Button - Matches toolbar button style */}
                <div className="relative group" style={{ marginRight: '12px' }}>
                  <button
                    onClick={() => {
                      const layouts: ('1x1' | '1x2' | '2x2')[] = ['1x1', '1x2', '2x2'];
                      const currentIndex = layouts.indexOf(chartLayout);
                      const nextIndex = (currentIndex + 1) % layouts.length;
                      changeChartLayout(layouts[nextIndex]);
                    }}
                    className="btn-3d-carved relative group"
                    style={{
                      padding: '10px 14px',
                      fontWeight: '700',
                      fontSize: '13px',
                      borderRadius: '4px',
                      color: chartLayout !== '1x1' ? '#00D9FF' : '#888'
                    }}
                    title={`Current: ${chartLayout} - Click to cycle layouts`}
                  >
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                      {chartLayout === '1x1' ? (
                        <rect x="3" y="3" width="18" height="18" rx="2" />
                      ) : chartLayout === '1x2' ? (
                        <>
                          <rect x="3" y="3" width="8" height="18" rx="2" />
                          <rect x="13" y="3" width="8" height="18" rx="2" />
                        </>
                      ) : (
                        <>
                          <rect x="3" y="3" width="8" height="8" rx="2" />
                          <rect x="13" y="3" width="8" height="8" rx="2" />
                          <rect x="3" y="13" width="8" height="8" rx="2" />
                          <rect x="13" y="13" width="8" height="8" rx="2" />
                        </>
                      )}
                    </svg>
                  </button>
                </div>

                {/* SETTINGS Button - Matches toolbar button style */}
                <button
                  onClick={() => setShowSettings(!showSettings)}
                  className={`btn-3d-carved relative group ${showSettings ? 'active' : ''}`}
                  style={{
                    padding: '10px 14px',
                    fontWeight: '700',
                    fontSize: '13px',
                    borderRadius: '4px',
                    color: '#FFD700'
                  }}
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path>
                    <circle cx="12" cy="12" r="3"></circle>
                  </svg>
                </button>
              </div>
            </div>
          </div>

          {/* Settings Panel */}
          {showSettings && (
            <div className="absolute top-22 right-4 bg-black border-2 border-gray-800 rounded-xl p-6 w-80 shadow-2xl" style={{ zIndex: 99999, boxShadow: '0 25px 50px rgba(0, 0, 0, 0.9), 0 0 100px rgba(41, 98, 255, 0.15)' }}>
              <div className="flex items-center justify-between mb-6 pb-4 border-b border-gray-800">
                <h3 className="text-white font-bold text-lg">Chart Settings</h3>
                <button
                  onClick={() => setShowSettings(false)}
                  className="text-gray-500 hover:text-white text-2xl transition-colors hover:bg-gray-900 rounded-lg w-8 h-8 flex items-center justify-center"
                >

                </button>
              </div>

              {/* Y-Axis Settings */}
              <div className="mb-6 pb-6 border-b border-gray-800">
                <label className="block text-white text-base font-semibold mb-4">Y-Axis (Price)</label>
                <div className="space-y-4">
                  <div className="flex items-center justify-between group">
                    <span className="text-gray-400 text-sm group-hover:text-white transition-colors">Text Size</span>
                    <div className="flex items-center space-x-3">
                      <input
                        type="range"
                        min="8"
                        max="20"
                        value={config.axisStyle.yAxis.textSize}
                        onChange={(e: React.ChangeEvent<HTMLInputElement>) => setConfig(prev => ({
                          ...prev,
                          axisStyle: {
                            ...prev.axisStyle,
                            yAxis: { ...prev.axisStyle.yAxis, textSize: parseInt(e.target.value) }
                          }
                        }))}
                        className="w-24 h-2 bg-gray-800 rounded-lg appearance-none cursor-pointer slider-thumb"
                        style={{
                          background: `linear-gradient(to right, #2962ff 0%, #2962ff ${((config.axisStyle.yAxis.textSize - 8) / 12) * 100}%, #1f2937 ${((config.axisStyle.yAxis.textSize - 8) / 12) * 100}%, #1f2937 100%)`
                        }}
                      />
                      <span className="text-white text-xs font-semibold w-8">{config.axisStyle.yAxis.textSize}px</span>
                    </div>
                  </div>

                  <div className="flex items-center justify-between group">
                    <span className="text-gray-400 text-sm group-hover:text-white transition-colors">Text Color</span>
                    <input
                      type="color"
                      value={config.axisStyle.yAxis.textColor}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setConfig(prev => ({
                        ...prev,
                        axisStyle: {
                          ...prev.axisStyle,
                          yAxis: { ...prev.axisStyle.yAxis, textColor: e.target.value }
                        }
                      }))}
                      className="w-12 h-10 rounded-lg cursor-pointer border-2 border-gray-700 hover:border-blue-500 transition-colors"
                    />
                  </div>
                </div>
              </div>

              {/* X-Axis Settings */}
              <div className="mb-6 pb-6 border-b border-gray-800">
                <label className="block text-white text-base font-semibold mb-4">X-Axis (Time)</label>
                <div className="space-y-4">
                  <div className="flex items-center justify-between group">
                    <span className="text-gray-400 text-sm group-hover:text-white transition-colors">Text Size</span>
                    <div className="flex items-center space-x-3">
                      <input
                        type="range"
                        min="8"
                        max="20"
                        value={config.axisStyle.xAxis.textSize}
                        onChange={(e: React.ChangeEvent<HTMLInputElement>) => setConfig(prev => ({
                          ...prev,
                          axisStyle: {
                            ...prev.axisStyle,
                            xAxis: { ...prev.axisStyle.xAxis, textSize: parseInt(e.target.value) }
                          }
                        }))}
                        className="w-24 h-2 bg-gray-800 rounded-lg appearance-none cursor-pointer slider-thumb"
                        style={{
                          background: `linear-gradient(to right, #2962ff 0%, #2962ff ${((config.axisStyle.xAxis.textSize - 8) / 12) * 100}%, #1f2937 ${((config.axisStyle.xAxis.textSize - 8) / 12) * 100}%, #1f2937 100%)`
                        }}
                      />
                      <span className="text-white text-xs font-semibold w-8">{config.axisStyle.xAxis.textSize}px</span>
                    </div>
                  </div>

                  <div className="flex items-center justify-between group">
                    <span className="text-gray-400 text-sm group-hover:text-white transition-colors">Text Color</span>
                    <input
                      type="color"
                      value={config.axisStyle.xAxis.textColor}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setConfig(prev => ({
                        ...prev,
                        axisStyle: {
                          ...prev.axisStyle,
                          xAxis: { ...prev.axisStyle.xAxis, textColor: e.target.value }
                        }
                      }))}
                      className="w-12 h-10 rounded-lg cursor-pointer border-2 border-gray-700 hover:border-blue-500 transition-colors"
                    />
                  </div>
                </div>
              </div>

              {/* Theme Selection */}
              <div className="mb-6 pb-6 border-b border-gray-800">
                <label className="block text-white text-base font-semibold mb-3">Theme</label>
                <div className="flex space-x-3">
                  <button
                    onClick={() => setConfig(prev => ({ ...prev, theme: 'dark' }))}
                    className={`flex-1 px-4 py-2.5 rounded-lg text-sm font-medium transition-all ${config.theme === 'dark'
                      ? 'bg-blue-600 text-white shadow-lg shadow-blue-500/50'
                      : 'bg-gray-900 text-gray-400 hover:text-white hover:bg-gray-800 border border-gray-700'
                      }`}
                  >
                    ðŸŒ™ Dark
                  </button>
                  <button
                    onClick={() => setConfig(prev => ({ ...prev, theme: 'light' }))}
                    className={`flex-1 px-4 py-2.5 rounded-lg text-sm font-medium transition-all ${config.theme === 'light'
                      ? 'bg-blue-600 text-white shadow-lg shadow-blue-500/50'
                      : 'bg-gray-900 text-gray-400 hover:text-white hover:bg-gray-800 border border-gray-700'
                      }`}
                  >
                    â˜€ï¸ Light
                  </button>
                </div>
              </div>

              {/* Body Colors */}
              <div className="mb-6 pb-6 border-b border-gray-800">
                <label className="block text-white text-base font-semibold mb-4">ðŸ“Š Body</label>
                <div className="space-y-4">
                  <div className="flex items-center justify-between group">
                    <span className="text-gray-400 text-sm group-hover:text-white transition-colors">Bullish</span>
                    <input
                      type="color"
                      value={config.colors.bullish.body}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setConfig(prev => ({
                        ...prev,
                        colors: {
                          ...prev.colors,
                          bullish: { ...prev.colors.bullish, body: e.target.value }
                        }
                      }))}
                      className="w-12 h-10 rounded-lg cursor-pointer border-2 border-gray-700 hover:border-green-500 transition-colors"
                    />
                  </div>

                  <div className="flex items-center justify-between group">
                    <span className="text-gray-400 text-sm group-hover:text-white transition-colors">Bearish</span>
                    <input
                      type="color"
                      value={config.colors.bearish.body}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setConfig(prev => ({
                        ...prev,
                        colors: {
                          ...prev.colors,
                          bearish: { ...prev.colors.bearish, body: e.target.value }
                        }
                      }))}
                      className="w-12 h-10 rounded-lg cursor-pointer border-2 border-gray-700 hover:border-red-500 transition-colors"
                    />
                  </div>
                </div>
              </div>

              {/* Border Colors */}
              <div className="mb-6 pb-6 border-b border-gray-800">
                <label className="block text-white text-base font-semibold mb-4">ðŸ”² Borders</label>
                <div className="space-y-4">
                  <div className="flex items-center justify-between group">
                    <span className="text-gray-400 text-sm group-hover:text-white transition-colors">Bullish</span>
                    <input
                      type="color"
                      value={config.colors.bullish.border}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setConfig(prev => ({
                        ...prev,
                        colors: {
                          ...prev.colors,
                          bullish: { ...prev.colors.bullish, border: e.target.value }
                        }
                      }))}
                      className="w-12 h-10 rounded-lg cursor-pointer border-2 border-gray-700 hover:border-green-500 transition-colors"
                    />
                  </div>

                  <div className="flex items-center justify-between group">
                    <span className="text-gray-400 text-sm group-hover:text-white transition-colors">Bearish</span>
                    <input
                      type="color"
                      value={config.colors.bearish.border}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setConfig(prev => ({
                        ...prev,
                        colors: {
                          ...prev.colors,
                          bearish: { ...prev.colors.bearish, border: e.target.value }
                        }
                      }))}
                      className="w-12 h-10 rounded-lg cursor-pointer border-2 border-gray-700 hover:border-red-500 transition-colors"
                    />
                  </div>
                </div>
              </div>

              {/* Wick Colors */}
              <div className="mb-6 pb-6 border-b border-gray-800">
                <label className="block text-white text-base font-semibold mb-4">ðŸ“ Wick</label>
                <div className="space-y-4">
                  <div className="flex items-center justify-between group">
                    <span className="text-gray-400 text-sm group-hover:text-white transition-colors">Bullish</span>
                    <input
                      type="color"
                      value={config.colors.bullish.wick}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setConfig(prev => ({
                        ...prev,
                        colors: {
                          ...prev.colors,
                          bullish: { ...prev.colors.bullish, wick: e.target.value }
                        }
                      }))}
                      className="w-12 h-10 rounded-lg cursor-pointer border-2 border-gray-700 hover:border-green-500 transition-colors"
                    />
                  </div>

                  <div className="flex items-center justify-between group">
                    <span className="text-gray-400 text-sm group-hover:text-white transition-colors">Bearish</span>
                    <input
                      type="color"
                      value={config.colors.bearish.wick}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setConfig(prev => ({
                        ...prev,
                        colors: {
                          ...prev.colors,
                          bearish: { ...prev.colors.bearish, wick: e.target.value }
                        }
                      }))}
                      className="w-12 h-10 rounded-lg cursor-pointer border-2 border-gray-700 hover:border-red-500 transition-colors"
                    />
                  </div>
                </div>
              </div>

              {/* Volume Colors */}
              <div className="mb-6 pb-6 border-b border-gray-800">
                <label className="block text-white text-base font-semibold mb-4">ðŸ“Š Volume Bars</label>
                <div className="space-y-4">
                  <div className="flex items-center justify-between group">
                    <span className="text-gray-400 text-sm group-hover:text-white transition-colors">Bullish Volume</span>
                    <input
                      type="color"
                      value={config.colors.volume.bullish}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setConfig(prev => ({
                        ...prev,
                        colors: {
                          ...prev.colors,
                          volume: { ...prev.colors.volume, bullish: e.target.value }
                        }
                      }))}
                      className="w-12 h-10 rounded-lg cursor-pointer border-2 border-gray-700 hover:border-green-500 transition-colors"
                    />
                  </div>

                  <div className="flex items-center justify-between group">
                    <span className="text-gray-400 text-sm group-hover:text-white transition-colors">Bearish Volume</span>
                    <input
                      type="color"
                      value={config.colors.volume.bearish}
                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setConfig(prev => ({
                        ...prev,
                        colors: {
                          ...prev.colors,
                          volume: { ...prev.colors.volume, bearish: e.target.value }
                        }
                      }))}
                      className="w-12 h-10 rounded-lg cursor-pointer border-2 border-gray-700 hover:border-red-500 transition-colors"
                    />
                  </div>
                </div>
              </div>

              {/* Apply Button */}
              <button
                onClick={() => setShowSettings(false)}
                className="w-full px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-all font-semibold shadow-lg shadow-blue-500/50 hover:shadow-blue-500/70 transform hover:scale-105"
              >
                Apply Settings
              </button>
            </div>
          )}

          {/* Chart Container with Sidebar */}
          <div className="flex flex-1 bg-[#0a0a0a]">
            {/* Clean Professional Sidebar */}
            <div className="sidebar-container w-[100px] md:w-[100px] sm:w-[80px] bg-black/95 border-r border-gray-800/50 backdrop-blur-sm relative overflow-y-auto mobile-sidebar">

              <div className="relative z-10 flex flex-col items-center py-3 h-full gap-4">
                {/* Sidebar Buttons */}
                {[
                  { id: 'liquid', icon: TbBoxMultiple, label: 'LIQUID', accent: 'orange' },
                  { id: 'watchlist', icon: TbChartLine, label: 'WATCH', accent: 'blue' },
                  { id: 'regimes', icon: TbTrendingUp, label: 'MARKETS', accent: 'emerald' },
                  { id: 'news', icon: TbNews, label: 'NEWS', accent: 'amber' },
                  { id: 'alerts', icon: TbBellRinging, label: 'ALERTS', accent: 'red' },

                  { id: 'chain', icon: TbLink, label: 'CHAIN', accent: 'cyan' },
                  { id: 'plan', icon: TbChartLine, label: 'PLAN', accent: 'purple' },
                  { id: 'trades', icon: TbActivity, label: 'TRADES', accent: 'green' },
                  { id: 'calendar', icon: TbCalendar, label: 'SEASONALITY', accent: 'pink' },
                  { id: 'flow', icon: TbArrowsShuffle, label: 'FLOW', accent: 'lime' },
                  { id: 'screeners', icon: TbFilter, label: 'SCREENERS', accent: 'teal' },
                  { id: 'rrg', icon: TbChartDots, label: 'RRG', accent: 'rose' }
                ].map((item, index) => {
                  const IconComponent = item.icon;
                  const accentColors: { [key: string]: string } = {
                    blue: '#3B82F6',
                    emerald: '#10B981',
                    amber: '#F59E0B',
                    red: '#EF4444',
                    violet: '#8B5CF6',
                    cyan: '#06B6D4',
                    purple: '#A855F7',
                    orange: '#F97316',
                    green: '#22C55E',
                    indigo: '#6366F1',
                    pink: '#EC4899',
                    lime: '#84CC16',
                    teal: '#14B8A6',
                    rose: '#F43F5E'
                  };

                  const isActive = activeSidebarPanel === item.id;

                  return (
                    <div key={item.id} className="flex flex-col items-center w-full px-2 mb-2">
                      <button
                        className="group relative w-full md:py-8 py-4 flex flex-col items-center justify-center md:gap-2.5 gap-1
 transition-all duration-500 ease-out active:scale-95 rounded-lg overflow-hidden backdrop-blur-xl"
                        style={{
                          background: isActive
                            ? `linear-gradient(135deg, 
                                ${accentColors[item.accent]}18 0%, 
                                rgba(15, 15, 15, 0.98) 40%, 
                                rgba(10, 10, 10, 0.98) 60%,
                                ${accentColors[item.accent]}15 100%)`
                            : `linear-gradient(135deg, 
                                rgba(20, 20, 20, 0.85) 0%, 
                                rgba(15, 15, 15, 0.9) 50%, 
                                rgba(10, 10, 10, 0.95) 100%)`,
                          boxShadow: isActive
                            ? `
                              0 0 40px ${accentColors[item.accent]}50,
                              0 0 80px ${accentColors[item.accent]}25,
                              inset 0 1px 2px rgba(255, 255, 255, 0.2),
                              inset 0 -1px 2px rgba(0, 0, 0, 0.8),
                              0 10px 40px rgba(0, 0, 0, 0.9),
                              0 4px 12px rgba(0, 0, 0, 0.95)
                            `
                            : `
                              0 6px 20px rgba(0, 0, 0, 0.8),
                              inset 0 1px 1px rgba(255, 255, 255, 0.1),
                              inset 0 -1px 1px rgba(0, 0, 0, 0.9)
                            `,
                          border: isActive
                            ? `1px solid ${accentColors[item.accent]}90`
                            : '1px solid rgba(50, 50, 50, 0.6)',
                          borderLeft: isActive ? `4px solid ${accentColors[item.accent]}` : `4px solid ${accentColors[item.accent]}30`,
                          position: 'relative',
                          transform: isActive ? 'translateX(3px) scale(1.02)' : 'translateX(0)'
                        }}
                        onMouseEnter={(e) => {
                          if (!isActive) {
                            e.currentTarget.style.background = `
                              linear-gradient(135deg, 
                                ${accentColors[item.accent]}12 0%, 
                                rgba(20, 20, 20, 0.95) 40%, 
                                rgba(15, 15, 15, 0.95) 60%,
                                ${accentColors[item.accent]}10 100%)
                            `;
                            e.currentTarget.style.boxShadow = `
                              0 0 30px ${accentColors[item.accent]}35,
                              0 8px 30px rgba(0, 0, 0, 0.85),
                              inset 0 1px 2px rgba(255, 255, 255, 0.15),
                              inset 0 -1px 2px rgba(0, 0, 0, 0.9)
                            `;
                            e.currentTarget.style.borderLeft = `4px solid ${accentColors[item.accent]}70`;
                            e.currentTarget.style.transform = 'translateX(2px) scale(1.01)';
                          }
                        }}
                        onMouseLeave={(e) => {
                          if (!isActive) {
                            e.currentTarget.style.background = `
                              linear-gradient(135deg, 
                                rgba(20, 20, 20, 0.85) 0%, 
                                rgba(15, 15, 15, 0.9) 50%, 
                                rgba(10, 10, 10, 0.95) 100%)
                            `;
                            e.currentTarget.style.boxShadow = `
                              0 6px 20px rgba(0, 0, 0, 0.8),
                              inset 0 1px 1px rgba(255, 255, 255, 0.1),
                              inset 0 -1px 1px rgba(0, 0, 0, 0.9)
                            `;
                            e.currentTarget.style.borderLeft = `4px solid ${accentColors[item.accent]}30`;
                            e.currentTarget.style.transform = 'translateX(0)';
                          }
                        }}
                        onClick={() => handleSidebarClick(item.id)}
                        title={item.label}
                      >
                        {/* Mobile label above icon */}
                        <span className="md:hidden text-[8px] font-bold uppercase tracking-tight relative z-10" style={{ color: isActive ? accentColors[item.accent] : '#FFFFFF' }}>
                          {item.label}
                        </span>
                        {/* Premium glass overlay with color tint */}
                        <div
                          className="absolute inset-0 pointer-events-none rounded-lg"
                          style={{
                            background: `linear-gradient(180deg, 
                              rgba(255, 255, 255, 0.12) 0%, 
                              ${accentColors[item.accent]}08 20%,
                              transparent 50%, 
                              transparent 80%, 
                              rgba(0, 0, 0, 0.4) 100%)`
                          }}
                        ></div>

                        {/* Accent glow bar - active state */}
                        {isActive && (
                          <>
                            <div
                              className="absolute top-0 left-0 right-0 h-1 opacity-90"
                              style={{
                                background: `linear-gradient(90deg, 
                                  transparent 0%, 
                                  ${accentColors[item.accent]} 50%, 
                                  transparent 100%)`,
                                boxShadow: `0 0 15px ${accentColors[item.accent]}, 0 0 30px ${accentColors[item.accent]}70`
                              }}
                            ></div>
                            <div
                              className="absolute inset-0 pointer-events-none rounded-lg"
                              style={{
                                background: `radial-gradient(circle at 50% 0%, ${accentColors[item.accent]}12 0%, transparent 60%)`
                              }}
                            ></div>
                          </>
                        )}

                        {/* Icon with dynamic color and glow */}
                        <span
                          className="relative md:text-4xl text-2xl transition-all duration-500 group-hover:scale-115 group-hover:rotate-6"
                          style={{
                            color: isActive ? accentColors[item.accent] : `${accentColors[item.accent]}B3`,
                            filter: isActive
                              ? `drop-shadow(0 0 16px ${accentColors[item.accent]}A0) drop-shadow(0 0 8px ${accentColors[item.accent]}) brightness(1.3)`
                              : `drop-shadow(0 0 8px ${accentColors[item.accent]}60) brightness(1.1)`,
                            transition: 'all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)'
                          }}
                        >
                          <IconComponent strokeWidth={isActive ? 3 : 2.5} />
                        </span>

                        {/* Label with premium typography */}
                        <span
                          className="relative text-[10px] font-bold uppercase tracking-[0.15em] transition-all duration-500 hidden md:block"
                          style={{
                            color: '#FFFFFF',
                            opacity: 1,
                            fontFamily: 'system-ui, -apple-system, sans-serif',
                            fontWeight: isActive ? 700 : 600,
                            letterSpacing: '0.12em',
                            textShadow: isActive
                              ? `0 0 25px ${accentColors[item.accent]}70, 0 2px 6px rgba(0, 0, 0, 0.95), 0 0 10px ${accentColors[item.accent]}40`
                              : `0 2px 4px rgba(0, 0, 0, 0.9), 0 0 8px ${accentColors[item.accent]}30`,
                            textRendering: 'optimizeLegibility',
                            WebkitFontSmoothing: 'antialiased'
                          }}
                        >
                          {item.label}
                        </span>

                        {/* Bottom accent line with glow */}
                        <div
                          className="absolute bottom-0 left-0 right-0 h-px opacity-60"
                          style={{
                            background: isActive
                              ? `linear-gradient(90deg, transparent 0%, ${accentColors[item.accent]}80 50%, transparent 100%)`
                              : `linear-gradient(90deg, transparent 0%, ${accentColors[item.accent]}30 50%, transparent 100%)`,
                            boxShadow: isActive ? `0 0 8px ${accentColors[item.accent]}60` : 'none'
                          }}
                        ></div>
                      </button>
                    </div>
                  );
                })}

                {/* Bottom spacer */}
                <div className="flex-1"></div>

                {/* Bottom branding - 3D carved */}
                <div className="pb-3 flex flex-col items-center gap-2">
                  <div
                    className="w-16 h-px rounded-full"
                    style={{
                      background: 'linear-gradient(to right, transparent, rgba(80, 80, 80, 0.4), transparent)',
                      boxShadow: '0 1px 0 rgba(0, 0, 0, 0.8), 0 -1px 0 rgba(60, 60, 60, 0.3)'
                    }}
                  ></div>
                  <span
                    className="text-[8px] text-gray-500 font-mono tracking-widest font-bold"
                    style={{
                      textShadow: '0 -1px 1px rgba(0, 0, 0, 0.9), 0 1px 1px rgba(60, 60, 60, 0.3)'
                    }}
                  >
                    EFI
                  </span>
                </div>
              </div>
            </div>

            {/* Main Chart Area */}
            <div
              ref={containerRef}
              className="relative flex-1"
              style={{ height: height - 100 }}
            >
              {/* Loading Overlay */}
              {loading && (
                <div className="absolute inset-0 z-50 bg-black bg-opacity-80 flex items-center justify-center">
                  <div className="bg-[#1e222d] border border-[#2a2e39] rounded-lg p-6 flex items-center space-x-3">
                    <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-[#2962ff]"></div>
                    <span className="text-white text-lg">Loading {config.timeframe} data for {symbol}...</span>
                  </div>
                </div>
              )}

              {/* Error Message */}
              {error && (
                <div className="absolute inset-0 z-50 bg-black bg-opacity-80 flex items-center justify-center">
                  <div className="bg-[#1e222d] border border-red-500 rounded-lg p-6">
                    <span className="text-red-400">Error: {error}</span>
                  </div>
                </div>
              )}

              {/* Multichart View */}
              {chartLayout !== '1x1' ? (
                <MultiChartView
                  layout={chartLayout}
                  instances={chartInstances}
                  activeChartId={activeChartId}
                  onActiveChartChange={setActiveChartId}
                  config={config}
                  colors={colors}
                  isSeasonalActive={isSeasonalActive}
                  seasonal20YData={seasonal20YData}
                  seasonal15YData={seasonal15YData}
                  seasonal10YData={seasonal10YData}
                  seasonalElectionData={seasonalElectionData}
                  isSeasonal20YActive={isSeasonal20YActive}
                  isSeasonal15YActive={isSeasonal15YActive}
                  isSeasonal10YActive={isSeasonal10YActive}
                  isSeasonalElectionActive={isSeasonalElectionActive}
                  isGexActive={isGexActive}
                  liveGexData={liveGexData}
                  gexData={gexData}
                  isExpectedRangeActive={isExpectedRangeActive}
                  expectedRangeLevels={expectedRangeLevels}
                  isWeeklyActive={isWeeklyActive}
                  isMonthlyActive={isMonthlyActive}
                  isExpansionLiquidationActive={isExpansionLiquidationActive}
                  technalysisActive={technalysisActive}
                  technalysisFeatures={technalysisFeatures}
                  isFlowChartActive={isFlowChartActive}
                  flowChartData={flowChartData}
                  flowChartHeight={flowChartHeight}
                  isIVRankActive={showIVRankIndicator}
                  isIVPercentileActive={showIVPercentileIndicator}
                  isHVActive={showHVIndicator}
                  ivPanelHeight={ivPanelHeight}
                  showIVPanel={showIVPanel}
                  ivData={ivData}
                  isIVLoading={isIVLoading}
                  showCallIVLine={showCallIVLine}
                  showPutIVLine={showPutIVLine}
                  showNetIVLine={showNetIVLine}
                  hvWindow={hvWindow}
                  dimensions={dimensions}
                  data={data}
                  scrollOffset={scrollOffset}
                  visibleCandleCount={visibleCandleCount}
                  priceRange={priceRange}
                  crosshair={crosshairPosition}
                  symbol={symbol}
                  isDragging={isDragging}
                  isAutoScale={isAutoScale}
                  manualPriceRange={manualPriceRange}
                  setScrollOffset={setScrollOffset}
                  setVisibleCandleCount={setVisibleCandleCount}
                  setManualPriceRange={setManualPriceRange}
                  setIsAutoScale={setIsAutoScale}
                  setIsDragging={setIsDragging}
                  handleTimeframeChange={handleTimeframeChange}
                  handleMouseMove={handleMouseMove}
                  drawings={drawings}
                  activeTool={activeTool}
                  renderExpectedRangeLines={renderExpectedRangeLines}
                  renderGEXLevels={renderGEXLevels}
                  detectExpansionLiquidation={detectExpansionLiquidation}
                  invalidateTouchedZones={invalidateTouchedZones}
                  renderExpansionLiquidationZone={renderExpansionLiquidationZone}
                  renderTechnalysisIndicators={renderTechnalysisIndicators}
                  handleUnifiedMouseDown={handleUnifiedMouseDown}
                  handleCanvasMouseMove={handleCanvasMouseMove}
                  handleMouseLeave={handleMouseLeave}
                  isDraggingYAxis={isDraggingYAxisZoom}
                  setIsDraggingYAxis={setIsDraggingYAxisZoom}
                />
              ) : (
                <>
                  {/* Y-Axis Auto-Scale Toggle Button - Removed as auto-scale is always enabled by default */}

                  {/* Main Chart Canvas */}
                  <canvas
                    ref={chartCanvasRef}
                    className="absolute top-0 left-0 z-10"
                    style={{ height: chartHeight }}
                  />

                  {/* Crosshair and Interaction Overlay */}
                  <canvas
                    ref={overlayCanvasRef}
                    className="absolute inset-0 z-20"
                    tabIndex={0}
                    style={{
                      cursor: activeTool ? 'crosshair' :
                        isDragging ? 'grabbing' : 'crosshair',
                      transition: 'cursor 0.1s ease',
                      outline: 'none',
                      touchAction: 'none'
                    }}
                    onMouseDown={handleUnifiedMouseDown}
                    onContextMenu={(e: React.MouseEvent<HTMLCanvasElement>) => {
                      e.preventDefault();
                      const x = e.nativeEvent.offsetX;
                      const y = e.nativeEvent.offsetY;

                      // Check if right-clicking on a drawing
                      for (const drawing of drawings) {
                        const startPoint = drawing.startPoint || (drawing.startX !== undefined && drawing.startY !== undefined ? { x: drawing.startX, y: drawing.startY } : null);
                        const endPoint = drawing.endPoint || (drawing.endX !== undefined && drawing.endY !== undefined ? { x: drawing.endX, y: drawing.endY } : null);

                        if (startPoint && endPoint && isPointNearLine(x, y, startPoint, endPoint, 10)) {
                          setSelectedDrawing(drawing);

                          // Drawing editor removed - drawing tools were removed as requested
                          console.log('Drawing editor removed - drawing tools were removed');
                          break;
                        }
                      }
                    }}
                    onMouseMove={activeTool ? handleCanvasMouseMove : handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={(e: React.MouseEvent<HTMLCanvasElement>) => {
                      handleMouseUp();
                      handleMouseLeave();
                    }}
                    // Touch Events for Mobile Support
                    onTouchStart={(e: React.TouchEvent<HTMLCanvasElement>) => {
                      e.preventDefault();
                      const touch = e.touches[0];
                      if (!touch) return;

                      const rect = e.currentTarget.getBoundingClientRect();
                      const mouseEvent = {
                        currentTarget: e.currentTarget,
                        button: 0,
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        ctrlKey: false,
                        metaKey: false,
                        preventDefault: () => e.preventDefault()
                      } as unknown as React.MouseEvent<HTMLCanvasElement>;

                      handleUnifiedMouseDown(mouseEvent);
                    }}
                    onTouchMove={(e: React.TouchEvent<HTMLCanvasElement>) => {
                      // Handle pinch-to-zoom gesture
                      if (e.touches.length === 2) {
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];

                        // Calculate distance between two touches
                        const dx = touch2.clientX - touch1.clientX;
                        const dy = touch2.clientY - touch1.clientY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (lastTouchDistance !== null) {
                          // Calculate zoom factor based on distance change
                          const distanceChange = distance - lastTouchDistance;
                          const scaleFactor = distanceChange > 0 ? 0.95 : 1.05;

                          const newCount = Math.max(20, Math.min(300, Math.round(visibleCandleCount * scaleFactor)));
                          setVisibleCandleCount(newCount);
                        }

                        setLastTouchDistance(distance);
                        return;
                      }

                      // Single touch - pan/draw
                      setLastTouchDistance(null);
                      e.preventDefault();
                      const touch = e.touches[0];
                      if (!touch) return;

                      const rect = e.currentTarget.getBoundingClientRect();
                      const mouseEvent = {
                        currentTarget: e.currentTarget,
                        clientX: touch.clientX,
                        clientY: touch.clientY
                      } as unknown as React.MouseEvent<HTMLCanvasElement>;

                      if (activeTool) {
                        handleCanvasMouseMove(mouseEvent);
                      } else {
                        handleMouseMove(mouseEvent);
                      }
                    }}
                    onTouchEnd={(e: React.TouchEvent<HTMLCanvasElement>) => {
                      e.preventDefault();
                      setLastTouchDistance(null);
                      handleMouseUp();
                    }}
                    // Enhanced zoom support
                    onWheel={(e: React.WheelEvent<HTMLCanvasElement>) => {
                      if (e.ctrlKey) {
                        // Pinch-to-zoom gesture (Ctrl + wheel) - X-axis zoom
                        e.preventDefault();
                        const delta = e.deltaY;
                        const scaleFactor = delta > 0 ? 1.1 : 0.9;

                        const newCount = Math.max(20, Math.min(300, Math.round(visibleCandleCount * scaleFactor)));
                        setVisibleCandleCount(newCount);
                      }
                    }}
                    onDoubleClick={handleDoubleClick}
                  />

                  {/* Lightweight Charts Drawing Tools Overlay */}
                  {isBackgroundVisible && (
                    <LWChartDrawingTools
                      width={dimensions.width}
                      height={dimensions.height}
                      isActive={true}
                      onClose={() => setCurrentDrawingTool('select')}
                      drawings={lwChartDrawings}
                      setDrawings={updateDrawingsWithHistory}
                      currentTool={currentDrawingTool}
                      setCurrentTool={setCurrentDrawingTool}
                      isToolLocked={isDrawingToolLocked}
                      priceToScreen={priceToScreen}
                      screenToPrice={screenToPrice}
                      timeToScreen={(index) => {
                        const candleWidth = (dimensions.width - 100) / visibleCandleCount;
                        const startIndex = Math.max(0, Math.floor(scrollOffset));
                        const relativeIndex = index - startIndex;
                        return 40 + (relativeIndex * candleWidth);
                      }}
                      screenToTime={(x) => {
                        const candleWidth = (dimensions.width - 100) / visibleCandleCount;
                        const startIndex = Math.max(0, Math.floor(scrollOffset));
                        const relativeX = x - 40;
                        const relativeIndex = Math.floor(relativeX / candleWidth);
                        // Allow future indices beyond data.length for drawing tools
                        return Math.max(0, startIndex + relativeIndex);
                      }}
                    />
                  )}

                  {/* Flow Chart Resize Handle */}
                  {isFlowChartActive && (
                    <div
                      onMouseDown={handleFlowChartDragStart}
                      style={{
                        position: 'absolute',
                        left: 0,
                        right: 0,
                        bottom: `${flowChartHeight + 80 + 25}px`,
                        height: '3px',
                        cursor: 'ns-resize',
                        backgroundColor: isDraggingFlowChart ? '#666666' : 'rgba(128, 128, 128, 0.3)',
                        transition: isDraggingFlowChart ? 'none' : 'background-color 0.2s',
                        zIndex: 1000,
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.backgroundColor = '#888888';
                      }}
                      onMouseLeave={(e) => {
                        if (!isDraggingFlowChart) {
                          e.currentTarget.style.backgroundColor = 'rgba(128, 128, 128, 0.3)';
                        }
                      }}
                    >
                      <div style={{
                        position: 'absolute',
                        top: '50%',
                        left: '50%',
                        transform: 'translate(-50%, -50%)',
                        width: '40px',
                        height: '2px',
                        backgroundColor: '#999999',
                        borderRadius: '1px',
                      }} />
                    </div>
                  )}

                  {/* IV Panel Resize Handle - TradingView style drag to resize */}
                  {activeIVPanelCount > 0 && (
                    <div
                      onMouseDown={handleIVPanelDragStart}
                      style={{
                        position: 'absolute',
                        left: 0,
                        right: 0,
                        bottom: `${(isFlowChartActive ? flowChartHeight : 0) + ivPanelHeight * activeIVPanelCount + 80 + 25}px`,
                        height: '4px',
                        cursor: 'ns-resize',
                        backgroundColor: isDraggingIVPanel ? '#FF9500' : 'rgba(255, 149, 0, 0.3)',
                        transition: isDraggingIVPanel ? 'none' : 'background-color 0.2s',
                        zIndex: 1000,
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.backgroundColor = '#FF9500';
                      }}
                      onMouseLeave={(e) => {
                        if (!isDraggingIVPanel) {
                          e.currentTarget.style.backgroundColor = 'rgba(255, 149, 0, 0.3)';
                        }
                      }}
                    >
                      <div style={{
                        position: 'absolute',
                        top: '50%',
                        left: '50%',
                        transform: 'translate(-50%, -50%)',
                        width: '40px',
                        height: '2px',
                        backgroundColor: '#FF9500',
                        borderRadius: '1px',
                      }} />
                    </div>
                  )}

                  {/* Flow Chart View Mode Toggle - FIXED: Always visible at stable position */}
                  {isFlowChartActive && (
                    <div
                      className="absolute flex flex-col z-[1001]"
                      style={{
                        left: '60px',
                        bottom: `${flowChartHeight - 120}px`,
                        transition: isDraggingFlowChart ? 'none' : 'bottom 0.1s ease-out',
                        gap: '8px'
                      }}
                    >
                      <button
                        onClick={() => setFlowChartViewMode('net')}
                        className="text-2xl font-semibold px-4 py-2 rounded transition-all"
                        style={{
                          backgroundColor: '#000000',
                          color: flowChartViewMode === 'net' ? '#FF8800' : '#ffffff',
                          border: '1px solid rgba(255, 255, 255, 0.3)'
                        }}
                        title="Show 1 line: Net Flow (combines all bullish and bearish flows)"
                      >
                        Net Flow
                      </button>
                      <button
                        onClick={() => setFlowChartViewMode('simplified')}
                        className="text-2xl font-semibold px-4 py-2 rounded transition-all"
                        style={{
                          backgroundColor: '#000000',
                          color: flowChartViewMode === 'simplified' ? '#FF8800' : '#ffffff',
                          border: '1px solid rgba(255, 255, 255, 0.3)'
                        }}
                        title="Show 2 lines: Bullish Total (positive) and Bearish Total (negative)"
                      >
                        Simplified
                      </button>
                      <button
                        onClick={() => setFlowChartViewMode('detailed')}
                        className="text-2xl font-semibold px-4 py-2 rounded transition-all"
                        style={{
                          backgroundColor: '#000000',
                          color: flowChartViewMode === 'detailed' ? '#FF8800' : '#ffffff',
                          border: '1px solid rgba(255, 255, 255, 0.3)'
                        }}
                        title="Show all 4 lines: Bullish Calls, Bearish Calls, Bullish Puts, Bearish Puts"
                      >
                        Detailed
                      </button>
                    </div>
                  )}

                  {/* IV Panel Line Toggle Controls - Below the IMPLIED VOLATILITY title */}
                  {showIVPanel && (
                    <div
                      className="absolute flex gap-2 z-[1001]"
                      style={{
                        left: '50px',
                        bottom: `${(isFlowChartActive ? flowChartHeight : 0) + ivPanelHeight * activeIVPanelCount + 80 + 25 - 35}px`,
                        transition: 'bottom 0.1s ease-out',
                      }}
                    >
                      <button
                        onClick={() => {
                          setShowCallIVLine(prev => !prev);
                        }}
                        className="text-xs font-semibold px-3 py-1 rounded transition-all cursor-pointer"
                        style={{
                          backgroundColor: showCallIVLine ? 'rgba(0, 255, 0, 0.2)' : 'rgba(0, 0, 0, 0.8)',
                          color: showCallIVLine ? '#00FF00' : 'rgba(255, 255, 255, 0.5)',
                          border: showCallIVLine ? '1px solid #00FF00' : '1px solid rgba(255, 255, 255, 0.2)'
                        }}
                        title="Toggle Call IV line"
                      >
                        Call IV
                      </button>
                      <button
                        onClick={() => {
                          setShowPutIVLine(prev => !prev);
                        }}
                        className="text-xs font-semibold px-3 py-1 rounded transition-all cursor-pointer"
                        style={{
                          backgroundColor: showPutIVLine ? 'rgba(255, 0, 0, 0.2)' : 'rgba(0, 0, 0, 0.8)',
                          color: showPutIVLine ? '#FF0000' : 'rgba(255, 255, 255, 0.5)',
                          border: showPutIVLine ? '1px solid #FF0000' : '1px solid rgba(255, 255, 255, 0.2)'
                        }}
                        title="Toggle Put IV line"
                      >
                        Put IV
                      </button>
                      <button
                        onClick={() => {
                          setShowNetIVLine(prev => !prev);
                        }}
                        className="text-xs font-semibold px-3 py-1 rounded transition-all cursor-pointer"
                        style={{
                          backgroundColor: showNetIVLine ? 'rgba(255, 149, 0, 0.2)' : 'rgba(0, 0, 0, 0.8)',
                          color: showNetIVLine ? '#FF9500' : 'rgba(255, 255, 255, 0.5)',
                          border: showNetIVLine ? '1px solid #FF9500' : '1px solid rgba(255, 255, 255, 0.2)'
                        }}
                        title="Toggle Net IV (average of Call and Put)"
                      >
                        Net IV
                      </button>
                    </div>
                  )}

                  {/* Close buttons for each active IV/HV panel - TradingView style X button */}
                  {showIVPanel && (
                    <button
                      onClick={() => setShowIVPanel(false)}
                      className="absolute z-[1001] flex items-center justify-center cursor-pointer hover:bg-red-500/30 transition-all"
                      style={{
                        right: '85px',
                        bottom: `${(isFlowChartActive ? flowChartHeight : 0) + ivPanelHeight * activeIVPanelCount + 80 + 25 - 18}px`,
                        width: '18px',
                        height: '18px',
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        borderRadius: '3px',
                        border: '1px solid rgba(255, 255, 255, 0.2)',
                        color: 'rgba(255, 255, 255, 0.6)',
                        fontSize: '14px',
                        fontWeight: 'bold',
                        lineHeight: '1',
                      }}
                      title="Close Implied Volatility panel"
                    >
                      Ã—
                    </button>
                  )}

                  {showIVRankIndicator && (
                    <button
                      onClick={() => setShowIVRankIndicator(false)}
                      className="absolute z-[1001] flex items-center justify-center cursor-pointer hover:bg-red-500/30 transition-all"
                      style={{
                        right: '85px',
                        bottom: `${(isFlowChartActive ? flowChartHeight : 0) + ivPanelHeight * (activeIVPanelCount - (showIVPanel ? 1 : 0)) + 80 + 25 - 18}px`,
                        width: '18px',
                        height: '18px',
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        borderRadius: '3px',
                        border: '1px solid rgba(255, 255, 255, 0.2)',
                        color: 'rgba(255, 255, 255, 0.6)',
                        fontSize: '14px',
                        fontWeight: 'bold',
                        lineHeight: '1',
                      }}
                      title="Close IV Rank panel"
                    >
                      Ã—
                    </button>
                  )}

                  {showIVPercentileIndicator && (
                    <button
                      onClick={() => setShowIVPercentileIndicator(false)}
                      className="absolute z-[1001] flex items-center justify-center cursor-pointer hover:bg-red-500/30 transition-all"
                      style={{
                        right: '85px',
                        bottom: `${(isFlowChartActive ? flowChartHeight : 0) + ivPanelHeight * (activeIVPanelCount - (showIVPanel ? 1 : 0) - (showIVRankIndicator ? 1 : 0)) + 80 + 25 - 18}px`,
                        width: '18px',
                        height: '18px',
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        borderRadius: '3px',
                        border: '1px solid rgba(255, 255, 255, 0.2)',
                        color: 'rgba(255, 255, 255, 0.6)',
                        fontSize: '14px',
                        fontWeight: 'bold',
                        lineHeight: '1',
                      }}
                      title="Close IV Percentile panel"
                    >
                      Ã—
                    </button>
                  )}

                  {showHVIndicator && (
                    <button
                      onClick={() => setShowHVIndicator(false)}
                      className="absolute z-[1001] flex items-center justify-center cursor-pointer hover:bg-red-500/30 transition-all"
                      style={{
                        right: '85px',
                        bottom: `${(isFlowChartActive ? flowChartHeight : 0) + ivPanelHeight + 80 + 25 - 18}px`,
                        width: '18px',
                        height: '18px',
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        borderRadius: '3px',
                        border: '1px solid rgba(255, 255, 255, 0.2)',
                        color: 'rgba(255, 255, 255, 0.6)',
                        fontSize: '14px',
                        fontWeight: 'bold',
                        lineHeight: '1',
                      }}
                      title="Close Historical Volatility panel"
                    >
                      Ã—
                    </button>
                  )}

                  {/* Close button for Live FlowMoves panel - TradingView style X button */}
                  {isFlowChartActive && (
                    <button
                      onClick={() => {
                        setIsFlowChartActive(false);
                        setFlowChartData([]);
                      }}
                      className="absolute z-[1001] flex items-center justify-center cursor-pointer hover:bg-red-500/30 transition-all"
                      style={{
                        right: '85px',
                        bottom: `${flowChartHeight + 80 + 25 - 18}px`,
                        width: '18px',
                        height: '18px',
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        borderRadius: '3px',
                        border: '1px solid rgba(255, 255, 255, 0.2)',
                        color: 'rgba(255, 255, 255, 0.6)',
                        fontSize: '14px',
                        fontWeight: 'bold',
                        lineHeight: '1',
                      }}
                      title="Close Live FlowMoves panel"
                    >
                      Ã—
                    </button>
                  )}
                </>
              )}
            </div>

            {/* Text Input Modal for Drawing Tools */}
            {showTextInput && textInputPosition && (
              <div
                className="absolute z-[10000] bg-[#1e222d] border border-[#2a2e39] rounded-lg p-4 shadow-xl"
                style={{
                  left: (textInputPosition?.x || 0) + 10,
                  top: (textInputPosition?.y || 0) - 10,
                  minWidth: '200px'
                }}
              >
                <div className="mb-3">
                  <label className="block text-white text-sm font-medium mb-2">
                    {activeTool === 'text' ? 'Add Text' :
                      activeTool === 'note' ? 'Add Note' :
                        activeTool === 'callout' ? 'Add Callout' :
                          activeTool === 'price_label' ? 'Price Label' :
                            'Add Text'}
                  </label>
                  <input
                    type="text"
                    value={drawingText}
                    onChange={(e: React.ChangeEvent<HTMLInputElement>) => setDrawingText(e.target.value)}
                    onKeyPress={(e: React.KeyboardEvent<HTMLInputElement>) => e.key === 'Enter' && handleTextSubmit()}
                    className="w-full px-3 py-2 bg-[#131722] border border-[#3a3e47] rounded text-white text-sm focus:outline-none focus:border-[#2962ff]"
                    placeholder="Enter text..."
                    autoFocus
                  />
                </div>
                <div className="flex space-x-2">
                  <button
                    onClick={handleTextSubmit}
                    className="px-3 py-1 bg-[#2962ff] text-white rounded text-sm hover:bg-[#1e4db7] transition-colors"
                  >
                    Add
                  </button>
                  <button
                    onClick={() => {
                      setShowTextInput(false);
                      setDrawingText('');
                      setTextInputPosition(null);
                      setActiveTool(null);
                    }}
                    className="px-3 py-1 bg-[#131722] text-[#787b86] rounded text-sm hover:text-white transition-colors"
                  >
                    Cancel
                  </button>
                </div>
              </div>
            )}

            {/* Property Editor removed - drawing tools were removed as requested */}
          </div>

          {/* Sidebar Panels */}
          {activeSidebarPanel && (
            <div
              className={`fixed top-38 md:top-45 bottom-4 left-0 md:left-[100px] w-full md:w-[1200px] bg-[#0a0a0a] border-r border-[#1a1a1a] shadow-2xl z-40 transform transition-transform duration-300 ease-out rounded-lg ${activeSidebarPanel === 'trades' ? '' : 'overflow-hidden'}`}
              data-sidebar-panel={activeSidebarPanel}
            >
              {/* Sidebar panel debugging */}

              {/* Panel Content */}
              <div className={`h-full ${activeSidebarPanel === 'trades' ? '' : 'overflow-hidden'}`}>
                {activeSidebarPanel === 'liquid' && (
                  <DealerAttraction onClose={() => setActiveSidebarPanel(null)} />
                )}
                {activeSidebarPanel === 'watchlist' && (
                  <WatchlistPanel
                    activeTab={watchlistTab}
                    setActiveTab={setWatchlistTab}
                  />
                )}
                {activeSidebarPanel === 'regimes' && (
                  <RegimesPanel
                    activeTab={regimesTab}
                    setActiveTab={setRegimesTab}
                    highlightFilter={highlightFilter}
                    setHighlightFilter={setHighlightFilter}
                  />
                )}
                {activeSidebarPanel === 'flow' && (
                  <FlowPanel
                    flowData={flowData}
                    flowSummary={flowSummary}
                    flowMarketInfo={flowMarketInfo}
                    flowLoading={flowLoading}
                    flowSelectedTicker={flowSelectedTicker}
                    flowStreamingStatus={flowStreamingStatus}
                    flowStreamingProgress={flowStreamingProgress}
                    flowStreamError={flowStreamError}
                    setFlowData={setFlowData}
                    setFlowSummary={setFlowSummary}
                    setFlowMarketInfo={setFlowMarketInfo}
                    setFlowLoading={setFlowLoading}
                    setFlowSelectedTicker={setFlowSelectedTicker}
                    setFlowStreamingStatus={setFlowStreamingStatus}
                    setFlowStreamingProgress={setFlowStreamingProgress}
                    setFlowStreamError={setFlowStreamError}
                    setActiveSidebarPanel={setActiveSidebarPanel}
                  />
                )}
                {activeSidebarPanel === 'news' && (
                  <NewsPanel symbol={config.symbol} onClose={() => setActiveSidebarPanel(null)} />
                )}
                {activeSidebarPanel === 'screeners' && (
                  <div className="h-full flex flex-col bg-black text-white">
                    {/* Bloomberg-style Header */}
                    <div className="p-3 border-b border-yellow-500 bg-black relative">
                      {/* Close button - mobile and desktop */}
                      <button
                        onClick={() => setActiveSidebarPanel(null)}
                        className="absolute top-3 right-3 text-gray-400 hover:text-white transition-colors z-50"
                        aria-label="Close panel"
                      >
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                          <line x1="18" y1="6" x2="6" y2="18"></line>
                          <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                      </button>
                      {/* Tab Navigation */}
                      <div className="flex border-2 border-yellow-500/30 rounded-md overflow-hidden shadow-lg">
                        {['HV', 'RS', 'Leadership'].map(tab => (
                          <button
                            key={tab}
                            onClick={() => setScreenersTab(tab)}
                            style={{
                              flex: 1,
                              padding: '12px 24px',
                              fontSize: '20px',
                              fontWeight: '900',
                              fontFamily: 'monospace',
                              letterSpacing: '1px',
                              textTransform: 'uppercase',
                              border: 'none',
                              borderRight: screenersTab === tab ? 'none' : '1px solid #333',
                              cursor: 'pointer',
                              transition: 'all 0.3s',
                              background: 'linear-gradient(135deg, #1a1a1a 0%, #000000 50%, #1a1a1a 100%)',
                              color: screenersTab === tab ? '#ff8844' : '#ffffff',
                              boxShadow: 'inset 0 2px 4px rgba(255, 255, 255, 0.1), inset 0 -2px 4px rgba(0, 0, 0, 0.5)',
                              opacity: 1,
                              filter: 'contrast(1.1) brightness(1.1)'
                            }}
                            onMouseEnter={(e) => {
                              e.currentTarget.style.background = 'linear-gradient(135deg, #252525 0%, #0a0a0a 50%, #252525 100%)';
                            }}
                            onMouseLeave={(e) => {
                              e.currentTarget.style.background = 'linear-gradient(135deg, #1a1a1a 0%, #000000 50%, #1a1a1a 100%)';
                            }}
                          >
                            {tab}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Screener Content */}
                    <div
                      ref={screenersPanelScrollRef}
                      onScroll={() => {
                        if (screenersPanelScrollRef.current) {
                          savedScreenersScrollPos.current = screenersPanelScrollRef.current.scrollTop;
                        }
                      }}
                      className="flex-1 overflow-y-auto"
                    >
                      {screenersTab === 'HV' && <HVScreener />}
                      {screenersTab === 'RS' && <RSScreener />}
                      {screenersTab === 'Leadership' && <LeadershipScan />}
                    </div>
                  </div>
                )}
                {activeSidebarPanel === 'alerts' && (
                  <div className="h-full flex flex-col bg-black">
                    {/* Mobile Title and X Button */}
                    <div className="md:hidden px-6 py-1 border-b border-gray-800 bg-black relative">
                      <button
                        onClick={() => setActiveSidebarPanel(null)}
                        className="absolute top-1 right-3 text-gray-400 hover:text-white transition-colors z-50"
                        aria-label="Close panel"
                      >
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                          <line x1="18" y1="6" x2="6" y2="18"></line>
                          <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                      </button>
                      <div className="text-center">
                        <h1 className="font-black text-white tracking-wider uppercase"
                          style={{
                            fontSize: '45px',
                            lineHeight: '1',
                            marginBottom: '5px',
                            textShadow: `
 2px 2px 0px rgba(0, 0, 0, 0.9),
 -1px -1px 0px rgba(255, 255, 255, 0.1),
 0px -2px 0px rgba(255, 255, 255, 0.05),
 0px 2px 0px rgba(0, 0, 0, 0.8),
 inset 0 2px 4px rgba(0, 0, 0, 0.5)
 `,
                            background: 'linear-gradient(to bottom, #ffffff 0%, #cccccc 50%, #999999 100%)',
                            WebkitBackgroundClip: 'text',
                            WebkitTextFillColor: 'transparent',
                            fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif'
                          }}>
                          Alerts
                        </h1>
                      </div>
                    </div>
                    <div
                      ref={alertsPanelScrollRef}
                      onScroll={() => {
                        if (alertsPanelScrollRef.current) {
                          savedAlertsScrollPos.current = alertsPanelScrollRef.current.scrollTop;
                        }
                      }}
                      className="p-4 space-y-4"
                      style={{
                        maxHeight: '100%',
                        overflow: 'auto',
                        background: '#000000'
                      }}
                    >
                      <div className="flex items-center justify-between mb-5" style={{
                        borderBottom: '1px solid rgba(255, 107, 0, 0.25)',
                        paddingBottom: '12px'
                      }}>
                        <div className="flex items-center gap-2">
                          <TbBellRinging style={{ color: '#ff6b00', fontSize: '22px', strokeWidth: 2.5 }} />
                          <h3 style={{
                            color: '#ff6b00',
                            fontWeight: '700',
                            fontSize: '14px',
                            textTransform: 'uppercase',
                            letterSpacing: '1.5px',
                            fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                            WebkitFontSmoothing: 'antialiased'
                          }}>Price Alerts</h3>
                        </div>
                        <button
                          onClick={() => {
                            setIsAlertPlacementMode(!isAlertPlacementMode);
                            if (!isAlertPlacementMode) {
                              setShowAlertDialog(false);
                            }
                          }}
                          style={{
                            padding: '8px 16px',
                            borderRadius: '2px',
                            fontSize: '11px',
                            fontWeight: '700',
                            textTransform: 'uppercase',
                            letterSpacing: '1.2px',
                            fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                            WebkitFontSmoothing: 'antialiased',
                            background: isAlertPlacementMode
                              ? 'linear-gradient(135deg, #ff6b00 0%, #ff8533 100%)'
                              : 'linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%)',
                            color: isAlertPlacementMode ? '#000' : '#ff6b00',
                            border: isAlertPlacementMode ? '1px solid #ff8533' : '1px solid rgba(255, 107, 0, 0.4)',
                            cursor: 'pointer',
                            transition: 'all 0.2s',
                            boxShadow: isAlertPlacementMode ? '0 4px 12px rgba(255, 107, 0, 0.4)' : '0 2px 4px rgba(0, 0, 0, 0.3)'
                          }}
                          onMouseEnter={(e) => {
                            if (!isAlertPlacementMode) {
                              e.currentTarget.style.background = 'linear-gradient(135deg, #252525 0%, #1a1a1a 100%)';
                              e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.6)';
                            }
                          }}
                          onMouseLeave={(e) => {
                            if (!isAlertPlacementMode) {
                              e.currentTarget.style.background = 'linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%)';
                              e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.4)';
                            }
                          }}
                        >
                          {isAlertPlacementMode ? 'âœ“ Click Chart' : '+ New Alert'}
                        </button>
                      </div>

                      {/* Alert Type Tabs */}
                      <div className="flex gap-2 mb-5">
                        {(['price', 'options', 'technical'] as const).map(type => (
                          <button
                            key={type}
                            onClick={() => setSelectedAlertType(type)}
                            style={{
                              flex: 1,
                              padding: '10px 12px',
                              borderRadius: '4px',
                              fontSize: '11px',
                              fontWeight: '700',
                              textTransform: 'uppercase',
                              letterSpacing: '1px',
                              fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                              WebkitFontSmoothing: 'antialiased',
                              background: selectedAlertType === type
                                ? 'linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%)'
                                : 'linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%)',
                              color: selectedAlertType === type ? '#ff6b00' : '#ff6b00',
                              border: selectedAlertType === type
                                ? '1px solid rgba(255, 107, 0, 0.5)'
                                : '1px solid rgba(255, 255, 255, 0.1)',
                              cursor: 'pointer',
                              transition: 'all 0.2s',
                              boxShadow: selectedAlertType === type
                                ? 'inset 0 2px 4px rgba(0, 0, 0, 0.5), 0 1px 0 rgba(255, 255, 255, 0.1), 0 4px 12px rgba(255, 107, 0, 0.3)'
                                : 'inset 0 2px 4px rgba(0, 0, 0, 0.5), 0 1px 0 rgba(255, 255, 255, 0.05)',
                              display: 'flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              gap: '6px',
                              position: 'relative',
                              overflow: 'hidden'
                            }}
                            onMouseEnter={(e) => {
                              if (selectedAlertType !== type) {
                                e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.3)';
                                e.currentTarget.style.boxShadow = 'inset 0 2px 4px rgba(0, 0, 0, 0.5), 0 1px 0 rgba(255, 255, 255, 0.1), 0 2px 8px rgba(255, 107, 0, 0.2)';
                              }
                            }}
                            onMouseLeave={(e) => {
                              if (selectedAlertType !== type) {
                                e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)';
                                e.currentTarget.style.boxShadow = 'inset 0 2px 4px rgba(0, 0, 0, 0.5), 0 1px 0 rgba(255, 255, 255, 0.05)';
                              }
                            }}
                          >
                            <span style={{
                              position: 'absolute',
                              top: 0,
                              left: 0,
                              right: 0,
                              height: '50%',
                              background: 'linear-gradient(180deg, rgba(255, 255, 255, 0.08) 0%, transparent 100%)',
                              pointerEvents: 'none'
                            }} />
                            {type === 'price' && <TbCurrencyDollar style={{ fontSize: '16px', strokeWidth: 2.5, position: 'relative', zIndex: 1 }} />}
                            {type === 'options' && <TbChartCandle style={{ fontSize: '16px', strokeWidth: 2.5, position: 'relative', zIndex: 1 }} />}
                            {type === 'technical' && <TbChartInfographic style={{ fontSize: '16px', strokeWidth: 2.5, position: 'relative', zIndex: 1 }} />}
                            <span style={{ position: 'relative', zIndex: 1 }}>{type.charAt(0).toUpperCase() + type.slice(1)}</span>
                          </button>
                        ))}
                      </div>

                      {/* Active Alerts List */}
                      <div className="space-y-3">
                        {alerts.filter(a => !a.triggered).length === 0 ? (
                          <div className="text-center py-10" style={{
                            background: '#0a0a0a',
                            border: '1px solid rgba(255, 255, 255, 0.08)',
                            borderRadius: '2px'
                          }}>
                            <TbBellOff style={{
                              width: '48px',
                              height: '48px',
                              margin: '0 auto 12px',
                              color: '#ff6b00',
                              opacity: 0.3,
                              strokeWidth: 1.5
                            }} />
                            <p style={{
                              fontSize: '13px',
                              color: '#999',
                              fontWeight: '600',
                              fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                              WebkitFontSmoothing: 'antialiased'
                            }}>No active alerts</p>
                            <p style={{
                              fontSize: '11px',
                              marginTop: '6px',
                              color: '#666',
                              fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                              WebkitFontSmoothing: 'antialiased'
                            }}>Click "New Alert" and then click on the chart to set a price level</p>
                          </div>
                        ) : (
                          alerts.filter(a => !a.triggered).map(alert => (
                            <div
                              key={alert.id}
                              style={{
                                background: '#0a0a0a',
                                border: '1px solid rgba(255, 255, 255, 0.1)',
                                borderRadius: '2px',
                                padding: '12px',
                                transition: 'all 0.2s',
                                boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
                              }}
                              onMouseEnter={(e) => {
                                e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.4)';
                                e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.4)';
                              }}
                              onMouseLeave={(e) => {
                                e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)';
                                e.currentTarget.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.3)';
                              }}
                            >
                              <div className="flex items-start justify-between">
                                <div className="flex-1">
                                  <div className="flex items-center gap-2 mb-2">
                                    {alert.type === 'price' && <TbCurrencyDollar style={{ color: '#ff6b00', fontSize: '18px', strokeWidth: 2.5 }} />}
                                    {alert.type === 'options' && <TbChartCandle style={{ color: '#ff6b00', fontSize: '18px', strokeWidth: 2.5 }} />}
                                    {alert.type === 'technical' && <TbChartInfographic style={{ color: '#ff6b00', fontSize: '18px', strokeWidth: 2.5 }} />}
                                    <span style={{
                                      color: '#fff',
                                      fontWeight: '700',
                                      fontSize: '13px',
                                      fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                                      WebkitFontSmoothing: 'antialiased'
                                    }}>{alert.symbol}</span>
                                    <span style={{
                                      fontSize: '10px',
                                      padding: '3px 8px',
                                      borderRadius: '2px',
                                      background: 'rgba(255, 107, 0, 0.15)',
                                      color: '#ff6b00',
                                      border: '1px solid rgba(255, 107, 0, 0.3)',
                                      fontWeight: '600',
                                      textTransform: 'uppercase',
                                      letterSpacing: '0.5px',
                                      fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                                      WebkitFontSmoothing: 'antialiased'
                                    }}>
                                      {alert.condition === 'above' && 'Above'}
                                      {alert.condition === 'below' && 'Below'}
                                      {alert.condition === 'crossesAbove' && 'Crosses â†‘'}
                                      {alert.condition === 'crossesBelow' && 'Crosses â†“'}
                                    </span>
                                  </div>
                                  <div style={{
                                    fontSize: '20px',
                                    fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                                    fontWeight: '700',
                                    color: '#ff6b00',
                                    letterSpacing: '-0.5px',
                                    textShadow: '0 0 10px rgba(255, 107, 0, 0.3)',
                                    WebkitFontSmoothing: 'antialiased'
                                  }}>
                                    ${alert.price.toFixed(2)}
                                  </div>
                                  {alert.message && (
                                    <p style={{
                                      fontSize: '11px',
                                      color: '#999',
                                      marginTop: '6px',
                                      fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                                      WebkitFontSmoothing: 'antialiased'
                                    }}>{alert.message}</p>
                                  )}
                                  {alert.optionsData && (
                                    <div style={{
                                      fontSize: '10px',
                                      color: '#999',
                                      marginTop: '6px',
                                      padding: '6px 10px',
                                      background: 'rgba(255, 107, 0, 0.1)',
                                      border: '1px solid rgba(255, 107, 0, 0.2)',
                                      borderRadius: '2px',
                                      fontWeight: '600',
                                      fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                                      WebkitFontSmoothing: 'antialiased'
                                    }}>
                                      {alert.optionsData.strike} {alert.optionsData.optionType.toUpperCase()} - {alert.optionsData.expiration}
                                    </div>
                                  )}
                                  <div className="flex items-center gap-2 mt-3">
                                    {alert.soundEnabled && <TbBell style={{ fontSize: '14px', color: '#ff6b00', strokeWidth: 2 }} />}
                                    {alert.emailEnabled && <TbMail style={{ fontSize: '14px', color: '#ff6b00', strokeWidth: 2 }} />}
                                    {alert.once && (
                                      <span style={{
                                        fontSize: '10px',
                                        color: '#666',
                                        padding: '2px 6px',
                                        background: 'rgba(255, 107, 0, 0.1)',
                                        border: '1px solid rgba(255, 107, 0, 0.2)',
                                        borderRadius: '2px',
                                        fontWeight: '600',
                                        fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                                        WebkitFontSmoothing: 'antialiased'
                                      }}>ONCE</span>
                                    )}
                                  </div>
                                </div>
                                <button
                                  onClick={() => setAlerts(alerts.filter(a => a.id !== alert.id))}
                                  style={{
                                    color: '#666',
                                    fontSize: '18px',
                                    marginLeft: '8px',
                                    padding: '4px',
                                    background: 'transparent',
                                    border: 'none',
                                    cursor: 'pointer',
                                    transition: 'color 0.2s'
                                  }}
                                  onMouseEnter={(e) => e.currentTarget.style.color = '#ff6b00'}
                                  onMouseLeave={(e) => e.currentTarget.style.color = '#666'}
                                >
                                  <TbX style={{ strokeWidth: 2.5 }} />
                                </button>
                              </div>
                            </div>
                          ))
                        )}
                      </div>

                      {/* Triggered Alerts History */}
                      {alerts.filter(a => a.triggered).length > 0 && (
                        <div className="mt-6" style={{
                          borderTop: '2px solid rgba(255, 107, 0, 0.2)',
                          paddingTop: '16px'
                        }}>
                          <h4 style={{
                            color: '#ff6b00',
                            fontSize: '11px',
                            fontWeight: '700',
                            marginBottom: '12px',
                            textTransform: 'uppercase',
                            letterSpacing: '1.5px',
                            fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                            WebkitFontSmoothing: 'antialiased'
                          }}>Triggered Alerts</h4>
                          <div className="space-y-2">
                            {alerts.filter(a => a.triggered).slice(0, 5).map(alert => (
                              <div
                                key={alert.id}
                                style={{
                                  background: 'linear-gradient(135deg, rgba(255, 107, 0, 0.08) 0%, rgba(255, 107, 0, 0.03) 100%)',
                                  border: '1px solid rgba(255, 107, 0, 0.2)',
                                  borderRadius: '2px',
                                  padding: '10px 12px',
                                  opacity: 0.7
                                }}
                              >
                                <div className="flex items-center justify-between">
                                  <div className="flex items-center gap-2">
                                    <TbCheck style={{ color: '#10b981', fontSize: '16px', strokeWidth: 2.5 }} />
                                    <span style={{
                                      color: '#fff',
                                      fontSize: '12px',
                                      fontWeight: '600',
                                      fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                                      WebkitFontSmoothing: 'antialiased'
                                    }}>{alert.symbol}</span>
                                    <span style={{
                                      color: '#999',
                                      fontSize: '11px',
                                      fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                                      WebkitFontSmoothing: 'antialiased'
                                    }}>${alert.price.toFixed(2)}</span>
                                  </div>
                                  <button
                                    onClick={() => setAlerts(alerts.filter(a => a.id !== alert.id))}
                                    className="text-gray-600 hover:text-gray-500 text-xs"
                                  >
                                    âœ•
                                  </button>
                                </div>
                              </div>
                            ))}
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                )}
                {activeSidebarPanel === 'chain' && (
                  <OptionsChain symbol={config.symbol} currentPrice={0} onClose={() => setActiveSidebarPanel(null)} />
                )}
                {activeSidebarPanel === 'plan' && (
                  <TradingPlan />
                )}
                {activeSidebarPanel === 'rrg' && (
                  <div className="h-full flex flex-col bg-black text-white">
                    {/* Bloomberg-style Header */}
                    <div className="p-3 border-b border-rose-500 bg-black relative">
                      {/* Close button */}
                      <button
                        onClick={() => setActiveSidebarPanel(null)}
                        className="absolute top-3 right-3 text-gray-400 hover:text-white transition-colors z-50"
                        aria-label="Close panel"
                      >
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                          <line x1="18" y1="6" x2="6" y2="18"></line>
                          <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                      </button>
                      {/* Tab Navigation */}
                      <div className="flex border-2 border-rose-500/30 rounded-md overflow-hidden shadow-lg">
                        {['Price', 'IV', 'Screener'].map(tab => (
                          <button
                            key={tab}
                            onClick={() => setRrgTab(tab)}
                            style={{
                              flex: 1,
                              padding: '12px 24px',
                              fontSize: '20px',
                              fontWeight: '900',
                              fontFamily: 'monospace',
                              letterSpacing: '1px',
                              textTransform: 'uppercase',
                              border: 'none',
                              borderRight: rrgTab === tab ? 'none' : '1px solid #333',
                              cursor: 'pointer',
                              transition: 'all 0.3s',
                              background: 'linear-gradient(135deg, #1a1a1a 0%, #000000 50%, #1a1a1a 100%)',
                              color: rrgTab === tab ? '#ff8844' : '#ffffff',
                              boxShadow: 'inset 0 2px 4px rgba(255, 255, 255, 0.1), inset 0 -2px 4px rgba(0, 0, 0, 0.5)',
                              opacity: 1,
                              filter: 'contrast(1.1) brightness(1.1)'
                            }}
                            onMouseEnter={(e) => {
                              e.currentTarget.style.background = 'linear-gradient(135deg, #252525 0%, #0a0a0a 50%, #252525 100%)';
                            }}
                            onMouseLeave={(e) => {
                              e.currentTarget.style.background = 'linear-gradient(135deg, #1a1a1a 0%, #000000 50%, #1a1a1a 100%)';
                            }}
                          >
                            {tab === 'Screener' ? tab : `${tab} RRG`}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* RRG Content */}
                    <div className="flex-1 overflow-hidden">
                      {rrgTab === 'Price' && <RRGAnalytics />}
                      {rrgTab === 'IV' && <IVRRGAnalytics />}
                      {rrgTab === 'Screener' && <RRGScreener hideTitle={true} sectorUnderTicker={true} compactLayout={true} />}
                    </div>
                  </div>
                )}
                {activeSidebarPanel === 'calendar' && (
                  <div className="h-full flex flex-col bg-black text-white">
                    {/* Bloomberg-style Header */}
                    <div className="p-3 border-b border-pink-500 bg-black relative">
                      {/* Close button */}
                      <button
                        onClick={() => setActiveSidebarPanel(null)}
                        className="absolute top-3 right-3 text-gray-400 hover:text-white transition-colors z-50"
                        aria-label="Close panel"
                      >
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                          <line x1="18" y1="6" x2="6" y2="18"></line>
                          <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                      </button>
                      {/* Tab Navigation */}
                      <div className="flex border-2 border-pink-500/30 rounded-md overflow-hidden shadow-lg">
                        {['Chart', 'Screener'].map(tab => (
                          <button
                            key={tab}
                            onClick={() => setCalendarTab(tab)}
                            style={{
                              flex: 1,
                              padding: '12px 24px',
                              fontSize: '20px',
                              fontWeight: '900',
                              fontFamily: 'monospace',
                              letterSpacing: '1px',
                              textTransform: 'uppercase',
                              border: 'none',
                              borderRight: calendarTab === tab ? 'none' : '1px solid #333',
                              cursor: 'pointer',
                              transition: 'all 0.3s',
                              background: 'linear-gradient(135deg, #1a1a1a 0%, #000000 50%, #1a1a1a 100%)',
                              color: calendarTab === tab ? '#ff8844' : '#ffffff',
                              boxShadow: 'inset 0 2px 4px rgba(255, 255, 255, 0.1), inset 0 -2px 4px rgba(0, 0, 0, 0.5)',
                              opacity: 1,
                              filter: 'contrast(1.1) brightness(1.1)'
                            }}
                            onMouseEnter={(e) => {
                              e.currentTarget.style.background = 'linear-gradient(135deg, #252525 0%, #0a0a0a 50%, #252525 100%)';
                            }}
                            onMouseLeave={(e) => {
                              e.currentTarget.style.background = 'linear-gradient(135deg, #1a1a1a 0%, #000000 50%, #1a1a1a 100%)';
                            }}
                          >
                            {tab}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Seasonality Content */}
                    <div className="flex-1 overflow-hidden" style={{ background: '#000' }}>
                      {calendarTab === 'Chart' && (
                        <div style={{ height: '100%', display: 'flex', flexDirection: 'column', background: '#000', padding: '16px' }}>
                          {/* Hide old controls from SeasonalityChart */}
                          <style>{`
                            /* Hide the top header controls */
                            .seasonality-custom-panel .seasonax-header {
                              display: none !important;
                            }
                            
                            /* Hide the grid layout's right column (screener) */
                            .seasonality-custom-panel .seasonax-container > div[style*="grid-template-columns"] {
                              display: grid !important;
                              grid-template-columns: 1fr !important;
                            }
                            
                            .seasonality-custom-panel .seasonax-container > div[style*="grid"] > div:nth-child(2) {
                              display: none !important;
                            }
                            
                            /* Ensure proper spacing */
                            .seasonality-custom-panel .seasonax-container {
                              padding: 0 !important;
                              margin: 0 !important;
                            }
                            
                            /* ONLY FOR SEASONALITY SIDEBAR: Chart heights */
                            .seasonality-custom-panel .almanac-daily-chart {
                              min-height: 525px !important;
                              max-height: 625px !important;
                            }
                            
                            .seasonality-custom-panel .chart-container {
                              min-height: 525px !important;
                              max-height: 625px !important;
                              height: 525px !important;
                            }
                            
                            .seasonality-custom-panel .chart-container canvas {
                              max-height: 525px !important;
                              height: 525px !important;
                            }
                            
                            /* ONLY FOR SEASONALITY SIDEBAR: Navy-green background container for ALL buttons in ONE ROW */
                            .seasonality-custom-panel .chart-header-row {
                              background: linear-gradient(135deg, #0a1628 0%, #001a0a 50%, #0a1628 100%) !important;
                              padding: 0px 20px !important;
                              border-radius: 4px !important;
                              margin-bottom: 12px !important;
                              border: 1px solid rgba(0, 255, 102, 0.2) !important;
                              box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.05), inset 0 -2px 4px rgba(0, 0, 0, 0.5) !important;
                              display: flex !important;
                              flex-wrap: nowrap !important;
                              align-items: center !important;
                              overflow-x: auto !important;
                            }
                            
                            .seasonality-custom-panel .chart-controls-row {
                              display: flex !important;
                              flex-wrap: nowrap !important;
                              gap: 12px !important;
                              flex-shrink: 0 !important;
                            }
                            
                            /* FORCE Normal/Election buttons to be HORIZONTAL */
                            .seasonality-custom-panel .chart-header-row > div:last-child {
                              display: flex !important;
                              flex-direction: row !important;
                              gap: 16px !important;
                              margin-left: auto !important;
                              flex-wrap: nowrap !important;
                            }
                            
                            .seasonality-custom-panel .chart-header-row > div:last-child > div,
                            .seasonality-custom-panel .chart-header-row > div:last-child > button {
                              display: inline-flex !important;
                              flex-direction: row !important;
                              white-space: nowrap !important;
                              align-items: center !important;
                              gap: 8px !important;
                            }
                            
                            /* GLOSSY 3D BLACK DROPDOWN/SELECT FOR MONTH SELECTOR */
                            .seasonality-custom-panel .month-selector {
                              background: linear-gradient(145deg, #2a2a2a 0%, #000000 50%, #1a1a1a 100%) !important;
                              color: #ffffff !important;
                              border: 1px solid rgba(255, 255, 255, 0.2) !important;
                              font-size: 13px !important;
                              min-width: 120px !important;
                              height: 42px !important;
                              padding: 0 18px !important;
                              font-weight: 600 !important;
                              box-shadow: 
                                0 2px 4px rgba(0, 0, 0, 0.8),
                                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                                inset 0 -1px 2px rgba(0, 0, 0, 0.6) !important;
                              border-radius: 4px !important;
                              transition: all 0.2s ease !important;
                              cursor: pointer !important;
                            }
                            
                            /* GLOSSY 3D BLACK BUTTONS FOR HEADER (Chart, Calendar, etc) */
                            .seasonality-custom-panel .toggle-btn {
                              background: linear-gradient(145deg, #2a2a2a 0%, #000000 50%, #1a1a1a 100%) !important;
                              color: #ff6600 !important;
                              border: 1px solid rgba(255, 255, 255, 0.2) !important;
                              font-size: 12px !important;
                              padding: 0 16px !important;
                              min-width: 100px !important;
                              height: 42px !important;
                              font-weight: 600 !important;
                              white-space: nowrap !important;
                              box-shadow: 
                                0 2px 4px rgba(0, 0, 0, 0.8),
                                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                                inset 0 -1px 2px rgba(0, 0, 0, 0.6) !important;
                              border-radius: 4px !important;
                              transition: all 0.2s ease !important;
                              cursor: pointer !important;
                            }
                            
                            .seasonality-custom-panel .toggle-btn:hover {
                              background: linear-gradient(145deg, #333333 0%, #111111 50%, #222222 100%) !important;
                              border-color: rgba(255, 255, 255, 0.3) !important;
                              color: #ff8833 !important;
                              box-shadow: 
                                0 3px 6px rgba(0, 0, 0, 0.9),
                                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                                inset 0 -1px 2px rgba(0, 0, 0, 0.7) !important;
                              transform: translateY(-1px) !important;
                            }
                            
                            .seasonality-custom-panel .toggle-btn.active {
                              background: linear-gradient(145deg, #1a1a1a 0%, #000000 50%, #0d0d0d 100%) !important;
                              border-color: rgba(255, 102, 0, 0.8) !important;
                              box-shadow: 
                                inset 0 2px 4px rgba(0, 0, 0, 0.9),
                                inset 0 1px 2px rgba(0, 0, 0, 0.8),
                                0 0 8px rgba(255, 102, 0, 0.3) !important;
                              color: #ff9944 !important;
                              transform: translateY(0px) !important;
                            }
                            
                            /* Fix legend - move to TOP CENTER of chart */
                            .seasonality-custom-panel .legend-row {
                              position: absolute !important;
                              top: 60px !important;
                              left: 50% !important;
                              transform: translateX(-50%) !important;
                              background: rgba(0, 0, 0, 0.8) !important;
                              padding: 8px 12px !important;
                              display: flex !important;
                              flex-direction: row !important;
                              gap: 16px !important;
                              justify-content: center !important;
                              align-items: center !important;
                              border: 1px solid rgba(255, 255, 255, 0.2) !important;
                              border-radius: 4px !important;
                              z-index: 10 !important;
                            }
                            
                            .seasonality-custom-panel .chart-container {
                              position: relative !important;
                            }
                            
                            .seasonality-custom-panel .legend-item {
                              display: flex !important;
                              align-items: center !important;
                              gap: 8px !important;
                              background: transparent !important;
                            }
                            
                            .seasonality-custom-panel .legend-item span:first-child {
                              color: #ffffff !important;
                              font-size: 11px !important;
                              font-weight: 600 !important;
                              background: transparent !important;
                            }
                            
                            .seasonality-custom-panel .legend-line {
                              display: inline-block !important;
                              width: 30px !important;
                              height: 2px !important;
                              opacity: 1 !important;
                            }
                            
                            /* Fix Normal/Election text to be HORIZONTAL side by side */
                            .seasonality-custom-panel .almanac-daily-chart > div:last-child {
                              display: flex !important;
                              flex-direction: row !important;
                              gap: 20px !important;
                              justify-content: center !important;
                              align-items: center !important;
                              flex-wrap: nowrap !important;
                            }
                            
                            .seasonality-custom-panel .almanac-daily-chart > div:last-child > div {
                              display: inline-block !important;
                              white-space: nowrap !important;
                            }
                            
                            /* Clean almanac header styling for seasonality panel */
                            .seasonality-custom-panel .almanac-daily-chart .chart-header-row {
                              background: #0a0a0a !important;
                              padding: 8px 16px !important;
                              border: 1px solid rgba(255, 107, 0, 0.3) !important;
                              border-radius: 4px !important;
                              margin-bottom: 12px !important;
                              display: flex !important;
                              align-items: center !important;
                              gap: 12px !important;
                              position: relative !important;
                              z-index: 5000 !important;
                              overflow: visible !important;
                            }
                            
                            .seasonality-custom-panel .almanac-daily-chart .month-selector {
                              padding: 8px 12px !important;
                              background: #000000 !important;
                              border: 1px solid rgba(255, 107, 0, 0.4) !important;
                              border-radius: 3px !important;
                              color: #ffffff !important;
                              font-size: 12px !important;
                              font-weight: 600 !important;
                              cursor: pointer !important;
                              min-width: 120px !important;
                            }
                            
                            .seasonality-custom-panel .almanac-daily-chart .toggle-btn {
                              padding: 8px 16px !important;
                              background: #000000 !important;
                              border: 1px solid rgba(255, 107, 0, 0.4) !important;
                              border-radius: 3px !important;
                              color: #ff6b00 !important;
                              font-size: 11px !important;
                              font-weight: 700 !important;
                              text-transform: uppercase !important;
                              cursor: pointer !important;
                              letter-spacing: 0.5px !important;
                              transition: all 0.2s ease !important;
                              box-shadow: none !important;
                              position: relative !important;
                              z-index: 5001 !important;
                            }
                            
                            .seasonality-custom-panel .almanac-daily-chart .toggle-btn:hover {
                              background: #1a1a1a !important;
                              border-color: rgba(255, 107, 0, 0.6) !important;
                            }
                            
                            .seasonality-custom-panel .almanac-daily-chart .toggle-btn.active {
                              background: #ff6b00 !important;
                              border-color: #ff6b00 !important;
                              color: #000000 !important;
                            }
                            
                            /* Dropdown menus appear above everything */
                            .seasonality-custom-panel .almanac-daily-chart .chart-header-row > div {
                              position: relative !important;
                              z-index: 10000 !important;
                            }
                          `}</style>

                          {/* Row 1: Controls */}
                          <div style={{
                            display: 'flex',
                            alignItems: 'center',
                            gap: '12px',
                            marginBottom: '12px',
                            padding: '12px 16px',
                            background: 'linear-gradient(135deg, #0a1628 0%, #000000 50%, #0a1628 100%)',
                            border: '1px solid rgba(255, 107, 0, 0.3)',
                            borderRadius: '4px',
                            boxShadow: 'inset 0 2px 4px rgba(255, 255, 255, 0.05), inset 0 -2px 4px rgba(0, 0, 0, 0.5)'
                          }}>
                            {/* Search Bar */}
                            <input
                              type="text"
                              placeholder="SPY"
                              value={seasonalSymbol}
                              onChange={(e) => setSeasonalSymbol(e.target.value.toUpperCase())}
                              style={{
                                width: '120px',
                                padding: '8px 12px',
                                background: '#0a0a0a',
                                border: '1px solid rgba(255, 107, 0, 0.4)',
                                borderRadius: '3px',
                                color: '#fff',
                                fontSize: '13px',
                                fontWeight: '600',
                                textTransform: 'uppercase'
                              }}
                            />

                            {/* Compare Button */}
                            <button
                              onClick={() => {
                                // TODO: Implement compare functionality
                                console.log('Compare clicked');
                              }}
                              style={{
                                padding: '8px 16px',
                                background: 'linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%)',
                                border: '1px solid rgba(255, 107, 0, 0.4)',
                                borderRadius: '3px',
                                color: '#ff6b00',
                                fontSize: '11px',
                                fontWeight: '700',
                                textTransform: 'uppercase',
                                cursor: 'pointer',
                                letterSpacing: '0.5px',
                                transition: 'all 0.2s ease'
                              }}
                              onMouseEnter={(e) => {
                                e.currentTarget.style.background = 'linear-gradient(135deg, #2a2a2a 0%, #1f1f1f 100%)';
                                e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.6)';
                              }}
                              onMouseLeave={(e) => {
                                e.currentTarget.style.background = 'linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%)';
                                e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.4)';
                              }}>
                              + COMPARE
                            </button>

                            {/* Election Dropdown */}
                            <select
                              value={seasonalElectionMode}
                              onChange={(e) => setSeasonalElectionMode(e.target.value)}
                              style={{
                                padding: '8px 12px',
                                background: '#0a0a0a',
                                border: '1px solid rgba(255, 107, 0, 0.4)',
                                borderRadius: '3px',
                                color: '#fff',
                                fontSize: '12px',
                                fontWeight: '600',
                                maxWidth: '140px'
                              }}
                            >
                              <option>Normal Mode</option>
                              <option>Election Year</option>
                              <option>Post-Election</option>
                              <option>Mid-Term</option>
                              <option>Pre-Election</option>
                            </select>

                            {/* Year Selector */}
                            <select
                              value={seasonalYears}
                              onChange={(e) => setSeasonalYears(Number(e.target.value))}
                              style={{
                                padding: '8px 12px',
                                background: '#0a0a0a',
                                border: '1px solid rgba(255, 107, 0, 0.4)',
                                borderRadius: '3px',
                                color: '#fff',
                                fontSize: '12px',
                                fontWeight: '600',
                                maxWidth: '130px'
                              }}
                            >
                              <option value={5}>5 Years</option>
                              <option value={10}>10 Years</option>
                              <option value={15}>15 Years</option>
                              <option value={20}>20 Years (Max)</option>
                            </select>

                            {/* Sweet Spot Button */}
                            <button
                              onClick={() => {
                                const newState = !seasonalSweetSpotActive;
                                setSeasonalSweetSpotActive(newState);

                                // Trigger sweet spot calculation in the chart below
                                const chartContainer = document.querySelector('.seasonality-custom-panel .seasonax-container');
                                if (chartContainer) {
                                  const sweetSpotBtn = chartContainer.querySelector('.sweet-spot-btn') as HTMLButtonElement;
                                  if (sweetSpotBtn) sweetSpotBtn.click();
                                }
                              }}
                              style={{
                                padding: '8px 16px',
                                background: seasonalSweetSpotActive
                                  ? 'linear-gradient(135deg, #00aa00 0%, #006d00 100%)'
                                  : 'linear-gradient(135deg, #004d00 0%, #002600 100%)',
                                border: seasonalSweetSpotActive
                                  ? '1px solid rgba(0, 255, 100, 0.8)'
                                  : '1px solid rgba(0, 255, 100, 0.4)',
                                borderRadius: '3px',
                                color: '#00ff66',
                                fontSize: '11px',
                                fontWeight: '700',
                                textTransform: 'uppercase',
                                cursor: 'pointer',
                                letterSpacing: '0.5px',
                                transition: 'all 0.2s ease',
                                boxShadow: seasonalSweetSpotActive ? '0 0 15px rgba(0, 255, 100, 0.4)' : 'none'
                              }}
                              onMouseEnter={(e) => {
                                if (!seasonalSweetSpotActive) {
                                  e.currentTarget.style.background = 'linear-gradient(135deg, #006d00 0%, #003600 100%)';
                                  e.currentTarget.style.borderColor = 'rgba(0, 255, 100, 0.6)';
                                }
                              }}
                              onMouseLeave={(e) => {
                                if (!seasonalSweetSpotActive) {
                                  e.currentTarget.style.background = 'linear-gradient(135deg, #004d00 0%, #002600 100%)';
                                  e.currentTarget.style.borderColor = 'rgba(0, 255, 100, 0.4)';
                                }
                              }}>
                              {seasonalSweetSpotActive ? 'âœ“ ' : ''}Sweet Spot
                            </button>

                            {/* Pain Point Button */}
                            <button
                              onClick={() => {
                                const newState = !seasonalPainPointActive;
                                setSeasonalPainPointActive(newState);

                                // Trigger pain point calculation in the chart below
                                const chartContainer = document.querySelector('.seasonality-custom-panel .seasonax-container');
                                if (chartContainer) {
                                  const painPointBtn = chartContainer.querySelector('.pain-point-btn') as HTMLButtonElement;
                                  if (painPointBtn) painPointBtn.click();
                                }
                              }}
                              style={{
                                padding: '8px 16px',
                                background: seasonalPainPointActive
                                  ? 'linear-gradient(135deg, #aa0000 0%, #6d0000 100%)'
                                  : 'linear-gradient(135deg, #4d0000 0%, #260000 100%)',
                                border: seasonalPainPointActive
                                  ? '1px solid rgba(255, 0, 0, 0.8)'
                                  : '1px solid rgba(255, 0, 0, 0.4)',
                                borderRadius: '3px',
                                color: '#ff0044',
                                fontSize: '11px',
                                fontWeight: '700',
                                textTransform: 'uppercase',
                                cursor: 'pointer',
                                letterSpacing: '0.5px',
                                transition: 'all 0.2s ease',
                                boxShadow: seasonalPainPointActive ? '0 0 15px rgba(255, 0, 0, 0.4)' : 'none'
                              }}
                              onMouseEnter={(e) => {
                                if (!seasonalPainPointActive) {
                                  e.currentTarget.style.background = 'linear-gradient(135deg, #6d0000 0%, #360000 100%)';
                                  e.currentTarget.style.borderColor = 'rgba(255, 0, 0, 0.6)';
                                }
                              }}
                              onMouseLeave={(e) => {
                                if (!seasonalPainPointActive) {
                                  e.currentTarget.style.background = 'linear-gradient(135deg, #4d0000 0%, #260000 100%)';
                                  e.currentTarget.style.borderColor = 'rgba(255, 0, 0, 0.4)';
                                }
                              }}>
                              {seasonalPainPointActive ? 'âœ“ ' : ''}Pain Point
                            </button>
                          </div>

                          {/* Row 2: Monthly Returns */}
                          <div style={{
                            display: 'flex',
                            alignItems: 'center',
                            gap: '8px',
                            marginBottom: '16px',
                            padding: '6px 16px',
                            background: 'linear-gradient(135deg, #0a1628 0%, #000000 50%, #0a1628 100%)',
                            border: '1px solid rgba(255, 107, 0, 0.3)',
                            borderRadius: '4px',
                            boxShadow: 'inset 0 2px 4px rgba(255, 255, 255, 0.05), inset 0 -2px 4px rgba(0, 0, 0, 0.5)'
                          }}>
                            {/* Bullish 30-Day */}
                            <div style={{
                              padding: '6px 12px',
                              background: 'linear-gradient(135deg, #002600 0%, #001300 100%)',
                              border: '1px solid rgba(0, 255, 100, 0.4)',
                              borderRadius: '3px',
                              textAlign: 'center',
                              minWidth: '100px'
                            }}>
                              <div style={{ fontSize: '9px', color: '#00ff66', fontWeight: '700', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '2px' }}>BULLISH</div>
                              <div style={{ fontSize: '10px', color: '#fff', fontWeight: '600' }}>
                                {seasonalBest30Day ? seasonalBest30Day.period.replace(' - ', ' - ') : 'Loading...'}
                              </div>
                              <div style={{ fontSize: '12px', color: '#00ff66', fontWeight: '700', marginTop: '2px' }}>
                                {seasonalBest30Day ? `+${seasonalBest30Day.return.toFixed(2)}%` : '--'}
                              </div>
                            </div>

                            {/* 12 Monthly Returns */}
                            {seasonalMonthlyData && seasonalMonthlyData.map((monthData, i) => {
                              const ret = monthData.outperformance;
                              const isPositive = ret > 0;
                              const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                              return (
                                <div key={monthData.month} style={{
                                  padding: '6px 8px',
                                  background: '#0a0a0a',
                                  border: `1px solid ${isPositive ? 'rgba(0, 255, 100, 0.3)' : 'rgba(255, 0, 0, 0.3)'}`,
                                  borderRadius: '3px',
                                  textAlign: 'center',
                                  minWidth: '60px',
                                  cursor: 'pointer',
                                  transition: 'all 0.2s ease'
                                }}
                                  onMouseEnter={(e) => {
                                    e.currentTarget.style.background = '#1a1a1a';
                                    e.currentTarget.style.borderColor = isPositive ? 'rgba(0, 255, 100, 0.5)' : 'rgba(255, 0, 0, 0.5)';
                                  }}
                                  onMouseLeave={(e) => {
                                    e.currentTarget.style.background = '#0a0a0a';
                                    e.currentTarget.style.borderColor = isPositive ? 'rgba(0, 255, 100, 0.3)' : 'rgba(255, 0, 0, 0.3)';
                                  }}>
                                  <div style={{ fontSize: '9px', color: '#ffffff', fontWeight: '700', marginBottom: '2px', opacity: 1 }}>{monthNames[i]}</div>
                                  <div style={{ fontSize: '11px', color: isPositive ? '#00ff66' : '#ff0044', fontWeight: '700' }}>
                                    {isPositive ? '+' : ''}{ret.toFixed(2)}%
                                  </div>
                                </div>
                              );
                            })}
                            {!seasonalMonthlyData && ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'].map((month) => (
                              <div key={month} style={{
                                padding: '6px 8px',
                                background: '#0a0a0a',
                                border: '1px solid rgba(100, 100, 100, 0.3)',
                                borderRadius: '3px',
                                textAlign: 'center',
                                minWidth: '60px'
                              }}>
                                <div style={{ fontSize: '9px', color: '#666', fontWeight: '700', marginBottom: '2px' }}>{month}</div>
                                <div style={{ fontSize: '11px', color: '#666', fontWeight: '700' }}>--</div>
                              </div>
                            ))}

                            {/* Bearish 30-Day */}
                            <div style={{
                              padding: '6px 12px',
                              background: 'linear-gradient(135deg, #260000 0%, #130000 100%)',
                              border: '1px solid rgba(255, 0, 0, 0.4)',
                              borderRadius: '3px',
                              textAlign: 'center',
                              minWidth: '100px'
                            }}>
                              <div style={{ fontSize: '9px', color: '#ff0044', fontWeight: '700', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '2px' }}>BEARISH</div>
                              <div style={{ fontSize: '10px', color: '#fff', fontWeight: '600' }}>
                                {seasonalWorst30Day ? seasonalWorst30Day.period.replace(' - ', ' - ') : 'Loading...'}
                              </div>
                              <div style={{ fontSize: '12px', color: '#ff0044', fontWeight: '700', marginTop: '2px' }}>
                                {seasonalWorst30Day ? `${seasonalWorst30Day.return.toFixed(2)}%` : '--'}
                              </div>
                            </div>
                          </div>

                          {/* Seasonality Chart - Let it render with built-in almanac */}
                          <div className="seasonality-custom-panel" style={{ minHeight: '450px', overflow: 'auto', background: '#000', borderRadius: '4px', border: '1px solid rgba(255, 107, 0, 0.2)', marginTop: '8px', paddingTop: '10px' }}>
                            <SeasonalityChart
                              initialSymbol={seasonalSymbol}
                              autoStart={true}
                              hideControls={false}
                              onSymbolChange={(symbol) => setSeasonalSymbol(symbol)}
                              externalElectionMode={seasonalElectionMode}
                              externalYears={seasonalYears}
                              onMonthlyDataLoaded={(monthlyData, best30Day, worst30Day) => {
                                setSeasonalMonthlyData(monthlyData);
                                setSeasonalBest30Day(best30Day);
                                setSeasonalWorst30Day(worst30Day);
                              }}
                            />
                          </div>
                        </div>
                      )}
                      {calendarTab === 'Screener' && (
                        <div style={{ overflow: 'auto', height: '100%' }}>
                          {/* Screener Header Controls */}
                          <div style={{
                            padding: '12px 20px',
                            background: '#000814',
                            borderBottom: '1px solid rgba(218, 165, 32, 0.25)',
                            boxShadow: '0 2px 8px rgba(0, 0, 0, 0.9)',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '16px',
                            flexWrap: 'nowrap',
                            overflowX: 'auto'
                          }}>
                            {/* Title */}
                            <h2 style={{
                              fontSize: '16px',
                              fontWeight: '700',
                              color: '#DAA520',
                              letterSpacing: '2px',
                              textTransform: 'uppercase',
                              textShadow: '0 2px 4px rgba(0, 0, 0, 1)',
                              whiteSpace: 'nowrap',
                              margin: 0,
                              flexShrink: 0
                            }}>
                              SEASONAL PATTERNS
                            </h2>

                            {/* Filter Buttons */}
                            <button
                              onClick={() => setSeasonalScreenerFilters(prev => ({ ...prev, highWinRate: !prev.highWinRate }))}
                              style={{
                                padding: '7px 14px',
                                background: seasonalScreenerFilters.highWinRate ? '#DAA520' : '#000000',
                                border: '1px solid rgba(218, 165, 32, 0.4)',
                                borderRadius: '3px',
                                color: seasonalScreenerFilters.highWinRate ? '#000' : '#DAA520',
                                fontSize: '11px',
                                fontWeight: '600',
                                cursor: 'pointer',
                                boxShadow: '0 2px 4px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.08)',
                                transition: 'all 0.2s ease',
                                whiteSpace: 'nowrap',
                                flexShrink: 0
                              }}>
                              {seasonalScreenerFilters.highWinRate ? 'âœ“ ' : ''}60%+ Win Rate
                            </button>

                            <button
                              onClick={() => setSeasonalScreenerFilters(prev => ({ ...prev, startingSoon: !prev.startingSoon }))}
                              style={{
                                padding: '7px 14px',
                                background: seasonalScreenerFilters.startingSoon ? '#DAA520' : '#000000',
                                border: '1px solid rgba(218, 165, 32, 0.4)',
                                borderRadius: '3px',
                                color: seasonalScreenerFilters.startingSoon ? '#000' : '#DAA520',
                                fontSize: '11px',
                                fontWeight: '600',
                                cursor: 'pointer',
                                boxShadow: '0 2px 4px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.08)',
                                transition: 'all 0.2s ease',
                                whiteSpace: 'nowrap',
                                flexShrink: 0
                              }}>
                              {seasonalScreenerFilters.startingSoon ? 'âœ“ ' : ''}Starting in 1-3 Days
                            </button>

                            <button
                              onClick={() => setSeasonalScreenerFilters(prev => ({ ...prev, fiftyTwoWeek: !prev.fiftyTwoWeek }))}
                              style={{
                                padding: '7px 14px',
                                background: seasonalScreenerFilters.fiftyTwoWeek ? '#DAA520' : '#000000',
                                border: '1px solid rgba(218, 165, 32, 0.4)',
                                borderRadius: '3px',
                                color: seasonalScreenerFilters.fiftyTwoWeek ? '#000' : '#DAA520',
                                fontSize: '11px',
                                fontWeight: '600',
                                cursor: 'pointer',
                                boxShadow: '0 2px 4px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.08)',
                                transition: 'all 0.2s ease',
                                whiteSpace: 'nowrap',
                                flexShrink: 0
                              }}>
                              {seasonalScreenerFilters.fiftyTwoWeek ? 'âœ“ ' : ''}52WK H/L
                            </button>

                            {/* Spacer */}
                            <div style={{ flex: 1, minWidth: '20px' }} />

                            {/* Index Selector */}
                            <select
                              value={seasonalScreenerMarket}
                              onChange={(e) => setSeasonalScreenerMarket(e.target.value)}
                              style={{
                                padding: '7px 12px',
                                background: '#000000',
                                border: '1px solid rgba(218, 165, 32, 0.4)',
                                borderRadius: '3px',
                                color: '#ffffff',
                                fontSize: '12px',
                                fontWeight: '600',
                                cursor: 'pointer',
                                boxShadow: '0 2px 4px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.08)',
                                minWidth: '130px',
                                flexShrink: 0
                              }}>
                              <option value="S&P 500">S&P 500</option>
                              <option value="NASDAQ 100">NASDAQ 100</option>
                              <option value="DOW JONES">DOW JONES</option>
                            </select>

                            {/* Years Selector */}
                            <select
                              value={seasonalScreenerYears}
                              onChange={(e) => setSeasonalScreenerYears(e.target.value)}
                              style={{
                                padding: '7px 12px',
                                background: '#000000',
                                border: '1px solid rgba(218, 165, 32, 0.4)',
                                borderRadius: '3px',
                                color: '#ffffff',
                                fontSize: '12px',
                                fontWeight: '600',
                                cursor: 'pointer',
                                boxShadow: '0 2px 4px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.08)',
                                minWidth: '110px',
                                flexShrink: 0
                              }}>
                              <option value="10Y">10 Years</option>
                              <option value="15Y">15 Years</option>
                              <option value="20Y">20 Years</option>
                            </select>

                            {/* Start Scan Button */}
                            <button
                              onClick={() => {
                                setSeasonalScanStarted(true);
                              }}
                              style={{
                                padding: '7px 18px',
                                background: 'linear-gradient(135deg, #ff6b00 0%, #ff4500 100%)',
                                border: '1px solid rgba(255, 107, 0, 0.6)',
                                borderRadius: '3px',
                                color: '#ffffff',
                                fontSize: '12px',
                                fontWeight: '700',
                                textTransform: 'uppercase',
                                cursor: 'pointer',
                                boxShadow: '0 3px 6px rgba(255, 107, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.2)',
                                transition: 'all 0.2s ease',
                                letterSpacing: '1px',
                                whiteSpace: 'nowrap',
                                flexShrink: 0
                              }}>
                              START SCAN
                            </button>
                          </div>

                          {/* Screener Content - Only show after scan started */}
                          <style>{`
                            .seasonality-screener-wrapper .pro-hero {
                              display: none !important;
                            }
                          `}</style>
                          {seasonalScanStarted && (
                            <SeasonalScreenerWrapper
                              market={seasonalScreenerMarket}
                              timePeriod={seasonalScreenerYears}
                              filters={seasonalScreenerFilters}
                              trigger={seasonalScanStarted}
                            />
                          )}
                          {!seasonalScanStarted && (
                            <div style={{
                              display: 'flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              height: 'calc(100% - 100px)',
                              color: '#666',
                              fontSize: '15px',
                              fontWeight: '600'
                            }}>
                              Click START SCAN to begin analysis
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                )}
                {activeSidebarPanel === 'trades' && (
                  <div className="h-full overflow-y-auto overflow-x-hidden" style={{
                    background: '#000000',
                    borderBottom: '2px solid rgba(30, 58, 138, 0.4)',
                    boxShadow: '0 4px 20px rgba(0, 0, 0, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.05)',
                    maxHeight: '100vh',
                    overflowY: 'scroll'
                  }}>
                    {/* Premium Title Section */}
                    <div className="px-6 py-6 relative overflow-hidden">
                      <div className="absolute inset-0 opacity-30" style={{
                        background: 'radial-gradient(ellipse at top, rgba(30, 58, 138, 0.1) 0%, transparent 70%)'
                      }} />
                      <div className="absolute inset-0 opacity-20" style={{
                        background: 'linear-gradient(90deg, transparent 0%, rgba(30, 58, 138, 0.05) 50%, transparent 100%)'
                      }} />

                      <div className="relative z-10 flex items-center justify-center">
                        <div className="text-center">
                          <h1 className="text-4xl font-bold tracking-wider uppercase mb-1" style={{
                            fontFamily: '"JetBrains Mono", monospace',
                            background: 'linear-gradient(135deg, #ffffff 0%, #93c5fd 25%, #3b82f6 50%, #93c5fd 75%, #ffffff 100%)',
                            WebkitBackgroundClip: 'text',
                            WebkitTextFillColor: 'transparent',
                            textShadow: '0 2px 10px rgba(59, 130, 246, 0.3)',
                            filter: 'drop-shadow(0 1px 2px rgba(0, 0, 0, 0.8))'
                          }}>
                            Build A Trade
                          </h1>
                        </div>

                        <button
                          onClick={() => setActiveSidebarPanel(null)}
                          className="absolute top-6 right-6 text-gray-400 hover:text-white transition-colors"
                          aria-label="Close panel"
                        >
                          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                          </svg>
                        </button>
                      </div>
                    </div>

                    {/* Panel Content */}
                    <div className="px-6 pb-48" style={{ minHeight: '100%' }}>
                      {/* Search Bar Section */}
                      <div className="mb-6">
                        <label className="block text-sm font-bold text-gray-400 mb-2 uppercase tracking-wider" style={{ fontFamily: 'monospace' }}>
                          Enter Ticker Symbol
                        </label>
                        <div className="flex gap-3 mb-4">
                          <div className="flex-1">
                            <input
                              type="text"
                              value={buildTradeTickerInput}
                              onChange={(e) => setBuildTradeTickerInput(e.target.value.toUpperCase())}
                              onKeyPress={(e) => e.key === 'Enter' && handleBuildTradeScan()}
                              placeholder="Type ticker (e.g., AAPL, TSLA, SPY)"
                              className="w-full px-4 py-3 bg-black border-2 rounded-lg font-mono text-lg text-white placeholder-gray-600 focus:outline-none transition-all"
                              style={{
                                borderColor: 'rgba(59, 130, 246, 0.3)',
                                boxShadow: '0 2px 8px rgba(0, 0, 0, 0.6)',
                              }}
                              onFocus={(e) => {
                                e.currentTarget.style.borderColor = 'rgba(59, 130, 246, 0.8)';
                                e.currentTarget.style.boxShadow = '0 0 0 3px rgba(59, 130, 246, 0.2), 0 2px 8px rgba(0, 0, 0, 0.6)';
                              }}
                              onBlur={(e) => {
                                e.currentTarget.style.borderColor = 'rgba(59, 130, 246, 0.3)';
                                e.currentTarget.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.6)';
                              }}
                            />
                          </div>
                          <div>
                            <select
                              value={buildTradeTimeframe}
                              onChange={(e) => setBuildTradeTimeframe(e.target.value as '1D' | '3D')}
                              className="px-4 py-3 bg-black border-2 rounded-lg font-mono text-sm text-white focus:outline-none transition-all"
                              style={{
                                borderColor: 'rgba(59, 130, 246, 0.3)',
                                boxShadow: '0 2px 8px rgba(0, 0, 0, 0.6)',
                                minWidth: '100px'
                              }}
                            >
                              <option value="1D">1 DAY</option>
                              <option value="3D">3 DAYS</option>
                            </select>
                          </div>
                        </div>

                        <button
                          onClick={handleBuildTradeScan}
                          disabled={buildTradeScanning || !buildTradeTickerInput.trim()}
                          className="w-full py-3 rounded-lg font-bold uppercase tracking-wider transition-all"
                          style={{
                            background: buildTradeScanning ? 'rgba(59, 130, 246, 0.3)' : 'linear-gradient(135deg, #3b82f6 0%, #1e40af 100%)',
                            color: '#ffffff',
                            border: '2px solid rgba(59, 130, 246, 0.5)',
                            boxShadow: buildTradeScanning ? 'none' : '0 4px 12px rgba(59, 130, 246, 0.4)',
                            cursor: buildTradeScanning ? 'not-allowed' : 'pointer',
                            opacity: buildTradeScanning ? 0.6 : 1
                          }}
                        >
                          {buildTradeScanning ? (
                            buildTradeScanProgress ?
                              `Scanning... ${buildTradeScanProgress.current}/${buildTradeScanProgress.total}` :
                              'Scanning...'
                          ) : (
                            'Scan For Opportunities'
                          )}
                        </button>
                      </div>

                      {/* Analysis Results - ALWAYS SHOW */}
                      {(buildTradeSweetSpot || buildTradePainPoint || buildTradeHVSignals.hv10Day || buildTradeHVSignals.hv20Day || buildTradeHVSignals.hv52Week || buildTradeIntensity || buildTradeStability || !buildTradeScanning) && (
                        <div>
                          {/* Dealer Workbench Gauges - TOP PRIORITY */}
                          {(buildTradeIntensity || buildTradeStability) && (
                            <div className="mb-6 grid grid-cols-2 gap-4" style={{ position: 'relative', zIndex: 10 }}>
                              {/* Intensity Gauge */}
                              {buildTradeIntensity && (
                                <div className="p-4 rounded-lg" style={{
                                  background: 'rgba(59, 130, 246, 0.1)',
                                  border: '1px solid rgba(59, 130, 246, 0.3)'
                                }}>
                                  <div className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2" style={{ fontFamily: 'monospace' }}>
                                    Dealer Intensity
                                  </div>
                                  <div className={`text-lg font-bold mb-1 ${buildTradeIntensity.color}`} style={{ fontFamily: 'monospace' }}>
                                    {buildTradeIntensity.signal}
                                  </div>
                                  <div className="text-sm text-gray-400" style={{ fontFamily: 'monospace' }}>
                                    Score: {buildTradeIntensity.score.toFixed(2)}
                                  </div>
                                </div>
                              )}

                              {/* Stability Gauge */}
                              {buildTradeStability && (
                                <div className="p-4 rounded-lg" style={{
                                  background: 'rgba(168, 85, 247, 0.1)',
                                  border: '1px solid rgba(168, 85, 247, 0.3)'
                                }}>
                                  <div className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2" style={{ fontFamily: 'monospace' }}>
                                    Market Stability
                                  </div>
                                  <div className={`text-lg font-bold mb-1 ${buildTradeStability.color}`} style={{ fontFamily: 'monospace' }}>
                                    {buildTradeStability.stability}
                                  </div>
                                  <div className="text-sm text-gray-400" style={{ fontFamily: 'monospace' }}>
                                    SI: {buildTradeStability.si.toFixed(2)}
                                  </div>
                                  <div className="text-xs text-gray-500 mt-1" style={{ fontFamily: 'monospace' }}>
                                    {buildTradeStability.behavior}
                                  </div>
                                </div>
                              )}
                            </div>
                          )}

                          {/* Seasonality Analysis Results */}
                          {(buildTradeSweetSpot || buildTradePainPoint) && (
                            <div className="mb-6 grid grid-cols-2 gap-4">
                              {buildTradeSweetSpot && (
                                <div className="p-4 rounded-lg" style={{
                                  background: 'rgba(34, 197, 94, 0.1)',
                                  border: '1px solid rgba(34, 197, 94, 0.3)'
                                }}>
                                  <div className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2" style={{ fontFamily: 'monospace' }}>
                                    Sweet Spot
                                  </div>
                                  <div className="text-sm font-bold text-green-400 mb-1" style={{ fontFamily: 'monospace' }}>
                                    {buildTradeSweetSpot.period}
                                  </div>
                                  <div className="text-lg font-bold text-green-400" style={{ fontFamily: 'monospace' }}>
                                    +{buildTradeSweetSpot.totalReturn.toFixed(2)}%
                                  </div>
                                </div>
                              )}
                              {buildTradePainPoint && (
                                <div className="p-4 rounded-lg" style={{
                                  background: 'rgba(239, 68, 68, 0.1)',
                                  border: '1px solid rgba(239, 68, 68, 0.3)'
                                }}>
                                  <div className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2" style={{ fontFamily: 'monospace' }}>
                                    Pain Point
                                  </div>
                                  <div className="text-sm font-bold text-red-400 mb-1" style={{ fontFamily: 'monospace' }}>
                                    {buildTradePainPoint.period}
                                  </div>
                                  <div className="text-lg font-bold text-red-400" style={{ fontFamily: 'monospace' }}>
                                    {buildTradePainPoint.totalReturn.toFixed(2)}%
                                  </div>
                                </div>
                              )}
                            </div>
                          )}

                          {/* Historical Volatility Signals */}
                          {(buildTradeHVSignals.hv10Day || buildTradeHVSignals.hv20Day || buildTradeHVSignals.hv52Week) && (
                            <div className="mb-6 p-4 rounded-lg" style={{
                              background: 'rgba(255, 140, 0, 0.1)',
                              border: '1px solid rgba(255, 140, 0, 0.3)'
                            }}>
                              <div className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-3" style={{ fontFamily: 'monospace' }}>
                                HV Screener Signals
                              </div>
                              <div className="flex flex-wrap gap-2">
                                {buildTradeHVSignals.hv10Day && (
                                  <div className="px-3 py-2 rounded-lg font-bold" style={{
                                    background: 'rgba(34, 197, 94, 0.2)',
                                    border: '1px solid rgba(34, 197, 94, 0.4)',
                                    color: '#22c55e',
                                    fontSize: '13px',
                                    fontFamily: 'monospace'
                                  }}>
                                    âœ“ 10-Day HV Near Low
                                  </div>
                                )}
                                {buildTradeHVSignals.hv20Day && (
                                  <div className="px-3 py-2 rounded-lg font-bold" style={{
                                    background: 'rgba(34, 197, 94, 0.2)',
                                    border: '1px solid rgba(34, 197, 94, 0.4)',
                                    color: '#22c55e',
                                    fontSize: '13px',
                                    fontFamily: 'monospace'
                                  }}>
                                    âœ“ 20-Day HV Near Low
                                  </div>
                                )}
                                {buildTradeHVSignals.hv52Week && (
                                  <div className="px-3 py-2 rounded-lg font-bold" style={{
                                    background: 'rgba(34, 197, 94, 0.2)',
                                    border: '1px solid rgba(34, 197, 94, 0.4)',
                                    color: '#22c55e',
                                    fontSize: '13px',
                                    fontFamily: 'monospace'
                                  }}>
                                    âœ“ 52-Week HV Near Low
                                  </div>
                                )}
                              </div>
                            </div>
                          )}

                          {/* RRG Screener Status - ALWAYS SHOW */}
                          <div className="mb-6 p-4 rounded-lg" style={{
                            background: 'rgba(16, 185, 129, 0.1)',
                            border: '1px solid rgba(16, 185, 129, 0.3)'
                          }}>
                            <div className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-3" style={{ fontFamily: 'monospace' }}>
                              RRG Screener Status (vs SPY)
                            </div>
                            {buildTradeRRGSignal.dominantQuadrant ? (
                              <>
                                <div className="flex flex-wrap gap-2 mb-3">
                                  <div className="px-3 py-2 rounded-lg font-bold" style={{
                                    background: buildTradeRRGSignal.dominantQuadrant === 'leading' ? 'rgba(34, 197, 94, 0.2)' :
                                      buildTradeRRGSignal.dominantQuadrant === 'improving' ? 'rgba(59, 130, 246, 0.2)' :
                                        buildTradeRRGSignal.dominantQuadrant === 'weakening' ? 'rgba(234, 179, 8, 0.2)' : 'rgba(239, 68, 68, 0.2)',
                                    border: buildTradeRRGSignal.dominantQuadrant === 'leading' ? '1px solid rgba(34, 197, 94, 0.4)' :
                                      buildTradeRRGSignal.dominantQuadrant === 'improving' ? '1px solid rgba(59, 130, 246, 0.4)' :
                                        buildTradeRRGSignal.dominantQuadrant === 'weakening' ? '1px solid rgba(234, 179, 8, 0.4)' : '1px solid rgba(239, 68, 68, 0.4)',
                                    color: buildTradeRRGSignal.dominantQuadrant === 'leading' ? '#22c55e' :
                                      buildTradeRRGSignal.dominantQuadrant === 'improving' ? '#3b82f6' :
                                        buildTradeRRGSignal.dominantQuadrant === 'weakening' ? '#eab308' : '#ef4444',
                                    fontSize: '13px',
                                    fontFamily: 'monospace',
                                    textTransform: 'uppercase' as const
                                  }}>
                                    {buildTradeRRGSignal.dominantQuadrant}
                                  </div>
                                  <div className="px-3 py-2 rounded-lg font-bold" style={{
                                    background: 'rgba(16, 185, 129, 0.2)',
                                    border: '1px solid rgba(16, 185, 129, 0.4)',
                                    color: '#10b981',
                                    fontSize: '13px',
                                    fontFamily: 'monospace'
                                  }}>
                                    {buildTradeRRGSignal.consistency}/4 Consistent
                                  </div>
                                </div>
                                <div className="grid grid-cols-2 gap-3 text-xs mb-2" style={{ fontFamily: 'monospace' }}>
                                  <div>
                                    <span className="text-gray-400">RS Ratio:</span>
                                    <span className="ml-2 text-white font-bold">{buildTradeRRGSignal.rsRatio.toFixed(2)}</span>
                                  </div>
                                  <div>
                                    <span className="text-gray-400">RS Momentum:</span>
                                    <span className="ml-2 text-white font-bold">{buildTradeRRGSignal.rsMomentum.toFixed(2)}</span>
                                  </div>
                                </div>
                                <div className="mt-3 text-xs" style={{ fontFamily: 'monospace' }}>
                                  <div className="text-gray-400 mb-2">Timeframe Breakdown:</div>
                                  <div className="grid grid-cols-4 gap-2">
                                    {Object.entries(buildTradeRRGSignal.timeframes).map(([tf, quad]) => (
                                      <div key={tf} className="px-2 py-1 rounded text-center" style={{
                                        background: quad === 'leading' ? 'rgba(34, 197, 94, 0.1)' :
                                          quad === 'improving' ? 'rgba(59, 130, 246, 0.1)' :
                                            quad === 'weakening' ? 'rgba(234, 179, 8, 0.1)' : 'rgba(239, 68, 68, 0.1)',
                                        border: quad === 'leading' ? '1px solid rgba(34, 197, 94, 0.3)' :
                                          quad === 'improving' ? '1px solid rgba(59, 130, 246, 0.3)' :
                                            quad === 'weakening' ? '1px solid rgba(234, 179, 8, 0.3)' : '1px solid rgba(239, 68, 68, 0.3)',
                                        color: quad === 'leading' ? '#22c55e' :
                                          quad === 'improving' ? '#3b82f6' :
                                            quad === 'weakening' ? '#eab308' : '#ef4444'
                                      }}>
                                        <div className="font-bold">{tf.toUpperCase()}</div>
                                        <div className="text-xs" style={{ textTransform: 'capitalize' }}>{quad}</div>
                                      </div>
                                    ))}
                                  </div>
                                </div>
                              </>
                            ) : (
                              <div className="text-sm text-gray-500 font-bold" style={{ fontFamily: 'monospace' }}>
                                âœ— RRG data unavailable
                              </div>
                            )}
                          </div>

                          {/* Market Regime Status - ALWAYS SHOW */}
                          <div className="mb-6 p-4 rounded-lg" style={{
                            background: 'rgba(75, 85, 99, 0.1)',
                            border: '1px solid rgba(75, 85, 99, 0.3)'
                          }}>
                            <div className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-3" style={{ fontFamily: 'monospace' }}>
                              Market Regime Status
                            </div>
                            {buildTradeMarketRegime.length > 0 ? (
                              <div className="space-y-3">
                                {buildTradeMarketRegime.map((regime, index) => (
                                  <div key={index} className="p-3 rounded-lg" style={{
                                    background: regime.highlightType === 'gold' ? 'rgba(218, 165, 32, 0.1)' : 'rgba(147, 51, 234, 0.1)',
                                    border: regime.highlightType === 'gold' ? '1px solid rgba(218, 165, 32, 0.3)' : '1px solid rgba(147, 51, 234, 0.3)'
                                  }}>
                                    <div className="flex flex-wrap gap-2 mb-3">
                                      <div className="px-3 py-2 rounded-lg font-bold" style={{
                                        background: regime.highlightType === 'gold' ? 'rgba(218, 165, 32, 0.2)' : 'rgba(147, 51, 234, 0.2)',
                                        border: regime.highlightType === 'gold' ? '1px solid rgba(218, 165, 32, 0.4)' : '1px solid rgba(147, 51, 234, 0.4)',
                                        color: regime.highlightType === 'gold' ? '#daa520' : '#9333ea',
                                        fontSize: '13px',
                                        fontFamily: 'monospace',
                                        textTransform: 'uppercase' as const
                                      }}>
                                        â­ {regime.highlightType === 'gold' ? 'BEST OF FRAME' : 'INDUSTRY PICK'}
                                      </div>
                                      <div className="px-3 py-2 rounded-lg font-bold" style={{
                                        background: regime.trend === 'bullish' ? 'rgba(34, 197, 94, 0.2)' : 'rgba(239, 68, 68, 0.2)',
                                        border: regime.trend === 'bullish' ? '1px solid rgba(34, 197, 94, 0.4)' : '1px solid rgba(239, 68, 68, 0.4)',
                                        color: regime.trend === 'bullish' ? '#22c55e' : '#ef4444',
                                        fontSize: '13px',
                                        fontFamily: 'monospace',
                                        textTransform: 'capitalize' as const
                                      }}>
                                        {regime.trend}
                                      </div>
                                    </div>
                                    <div className="grid grid-cols-2 gap-3 text-xs" style={{ fontFamily: 'monospace' }}>
                                      <div>
                                        <span className="text-gray-400">Timeframe:</span>
                                        <span className="ml-2 text-white font-bold" style={{ textTransform: 'capitalize' }}>{regime.timeframe}</span>
                                      </div>
                                      <div>
                                        <span className="text-gray-400">Industry:</span>
                                        <span className="ml-2 text-white font-bold">{regime.industry}</span>
                                      </div>
                                      <div className="col-span-2">
                                        <span className="text-gray-400">Relative Performance:</span>
                                        <span className={`ml-2 font-bold ${regime.relativePerformance >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                          {regime.relativePerformance >= 0 ? '+' : ''}{regime.relativePerformance.toFixed(2)}%
                                        </span>
                                      </div>
                                    </div>
                                  </div>
                                ))}
                              </div>
                            ) : (
                              <div className="text-sm text-gray-500 font-bold" style={{ fontFamily: 'monospace' }}>
                                âœ— Not found in Market Regime picks
                              </div>
                            )}
                          </div>

                          {/* Expected Range - ALWAYS SHOW */}
                          <div className="mb-6 p-4 rounded-lg" style={{
                            background: 'rgba(75, 85, 99, 0.1)',
                            border: '1px solid rgba(75, 85, 99, 0.3)'
                          }}>
                            <div className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-3" style={{ fontFamily: 'monospace' }}>
                              Expected Range (80% / 90% Probability)
                            </div>
                            {buildTradeExpectedRange ? (
                              <div className="space-y-4">
                                {/* Weekly Range */}
                                <div className="p-3 rounded-lg" style={{
                                  background: 'rgba(59, 130, 246, 0.1)',
                                  border: '1px solid rgba(59, 130, 246, 0.3)'
                                }}>
                                  <div className="text-sm font-bold text-blue-400 mb-2" style={{ fontFamily: 'monospace' }}>
                                    ðŸ“… WEEKLY (IV: {(buildTradeExpectedRange.weeklyIV * 100).toFixed(2)}%)
                                  </div>
                                  <div className="grid grid-cols-2 gap-3 text-xs" style={{ fontFamily: 'monospace' }}>
                                    <div>
                                      <span className="text-gray-400">80% Range:</span>
                                      <div className="ml-2 mt-1">
                                        <div className="text-green-400 font-bold">${buildTradeExpectedRange.weekly80Call.toFixed(2)} (Call)</div>
                                        <div className="text-red-400 font-bold">${buildTradeExpectedRange.weekly80Put.toFixed(2)} (Put)</div>
                                      </div>
                                    </div>
                                    <div>
                                      <span className="text-gray-400">90% Range:</span>
                                      <div className="ml-2 mt-1">
                                        <div className="text-green-400 font-bold">${buildTradeExpectedRange.weekly90Call.toFixed(2)} (Call)</div>
                                        <div className="text-red-400 font-bold">${buildTradeExpectedRange.weekly90Put.toFixed(2)} (Put)</div>
                                      </div>
                                    </div>
                                  </div>
                                </div>
                                {/* Monthly Range */}
                                <div className="p-3 rounded-lg" style={{
                                  background: 'rgba(168, 85, 247, 0.1)',
                                  border: '1px solid rgba(168, 85, 247, 0.3)'
                                }}>
                                  <div className="text-sm font-bold text-purple-400 mb-2" style={{ fontFamily: 'monospace' }}>
                                    ðŸ“… MONTHLY (IV: {(buildTradeExpectedRange.monthlyIV * 100).toFixed(2)}%)
                                  </div>
                                  <div className="grid grid-cols-2 gap-3 text-xs" style={{ fontFamily: 'monospace' }}>
                                    <div>
                                      <span className="text-gray-400">80% Range:</span>
                                      <div className="ml-2 mt-1">
                                        <div className="text-green-400 font-bold">${buildTradeExpectedRange.monthly80Call.toFixed(2)} (Call)</div>
                                        <div className="text-red-400 font-bold">${buildTradeExpectedRange.monthly80Put.toFixed(2)} (Put)</div>
                                      </div>
                                    </div>
                                    <div>
                                      <span className="text-gray-400">90% Range:</span>
                                      <div className="ml-2 mt-1">
                                        <div className="text-green-400 font-bold">${buildTradeExpectedRange.monthly90Call.toFixed(2)} (Call)</div>
                                        <div className="text-red-400 font-bold">${buildTradeExpectedRange.monthly90Put.toFixed(2)} (Put)</div>
                                      </div>
                                    </div>
                                  </div>
                                </div>
                                <div className="text-xs text-gray-400 mt-2" style={{ fontFamily: 'monospace' }}>
                                  Current Price: <span className="text-white font-bold">${buildTradeExpectedRange.currentPrice.toFixed(2)}</span>
                                </div>
                              </div>
                            ) : (
                              <div className="text-sm text-gray-500 font-bold" style={{ fontFamily: 'monospace' }}>
                                âš  Expected Range calculation in progress...
                              </div>
                            )}
                          </div>

                          {/* Events Analysis - ALWAYS SHOW */}
                          {buildTradeEvents.length > 0 && (
                            <div className="mb-6 p-4 rounded-lg" style={{
                              background: 'rgba(75, 85, 99, 0.1)',
                              border: '1px solid rgba(75, 85, 99, 0.3)'
                            }}>
                              <div className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-3" style={{ fontFamily: 'monospace' }}>
                                Relevant Events (Within 1 Month)
                              </div>
                              <div className="space-y-4">
                                {buildTradeEvents.map((event, index) => (
                                  <div key={index} className="p-3 rounded-lg" style={{
                                    background: 'rgba(34, 197, 94, 0.1)',
                                    border: '1px solid rgba(34, 197, 94, 0.3)'
                                  }}>
                                    <div className="flex justify-between items-center mb-3">
                                      <div className="text-sm font-bold text-green-400" style={{ fontFamily: 'monospace' }}>
                                        ðŸŽ¯ {event.eventName}
                                      </div>
                                      <div className="text-xs text-gray-400" style={{ fontFamily: 'monospace' }}>
                                        {event.eventDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} â€¢ {event.occurrences} occurrences
                                      </div>
                                    </div>
                                    <canvas
                                      ref={(canvas) => {
                                        if (!canvas) return;
                                        const ctx = canvas.getContext('2d');
                                        if (!ctx) return;

                                        const dpr = window.devicePixelRatio || 1;
                                        const width = 550;
                                        const height = 234;
                                        canvas.width = width * dpr;
                                        canvas.height = height * dpr;
                                        canvas.style.width = `${width}px`;
                                        canvas.style.height = `${height}px`;
                                        ctx.scale(dpr, dpr);

                                        const padding = { top: 25, right: 30, bottom: 45, left: 60 };
                                        const chartWidth = width - padding.left - padding.right;
                                        const chartHeight = height - padding.top - padding.bottom;

                                        ctx.fillStyle = '#000000';
                                        ctx.fillRect(0, 0, width, height);

                                        const returns = event.data.map(d => d.avgReturn);
                                        const maxReturn = Math.max(...returns, 0);
                                        const minReturn = Math.min(...returns, 0);
                                        const range = Math.max(Math.abs(maxReturn), Math.abs(minReturn)) * 1.2;

                                        // Draw horizontal gridlines with labels
                                        ctx.strokeStyle = '#333333';
                                        ctx.lineWidth = 0.5;
                                        ctx.fillStyle = '#FFFFFF';
                                        ctx.font = '10px "JetBrains Mono", monospace';
                                        ctx.textAlign = 'right';

                                        for (let i = 0; i <= 8; i++) {
                                          const y = padding.top + (chartHeight * i / 8);
                                          const pct = range - (range * 2 * i / 8);

                                          ctx.strokeStyle = i === 4 ? '#666666' : '#333333';
                                          ctx.lineWidth = i === 4 ? 1.5 : 0.5;
                                          ctx.beginPath();
                                          ctx.moveTo(padding.left, y);
                                          ctx.lineTo(padding.left + chartWidth, y);
                                          ctx.stroke();

                                          ctx.fillStyle = '#FFFFFF';
                                          ctx.fillText(`${pct >= 0 ? '+' : ''}${pct.toFixed(2)}%`, padding.left - 8, y + 4);
                                        }

                                        // Draw vertical line at Event day (index 5 out of 13 points: -5 to +7)
                                        const zeroY = padding.top + chartHeight / 2;
                                        const eventX = padding.left + (chartWidth * 5 / 12);
                                        ctx.strokeStyle = '#FFD700';
                                        ctx.lineWidth = 2;
                                        ctx.setLineDash([5, 3]);
                                        ctx.beginPath();
                                        ctx.moveTo(eventX, padding.top);
                                        ctx.lineTo(eventX, padding.top + chartHeight);
                                        ctx.stroke();
                                        ctx.setLineDash([]);

                                        // Draw performance line
                                        ctx.strokeStyle = '#22c55e';
                                        ctx.lineWidth = 2.5;
                                        ctx.beginPath();
                                        event.data.forEach((point, i) => {
                                          const x = padding.left + (chartWidth * i / (event.data.length - 1));
                                          const y = zeroY - (point.avgReturn / range) * (chartHeight / 2);
                                          if (i === 0) ctx.moveTo(x, y);
                                          else ctx.lineTo(x, y);
                                        });
                                        ctx.stroke();

                                        // Draw x-axis labels (trading days relative to event)
                                        ctx.fillStyle = '#FFFFFF';
                                        ctx.font = '10px "JetBrains Mono", monospace';
                                        ctx.textAlign = 'center';
                                        // Event data: -5 to +7 trading days (13 points)
                                        ctx.fillText('-5d', padding.left, height - 28);
                                        ctx.fillText('-3d', padding.left + chartWidth * 2 / 12, height - 28);
                                        ctx.fillText('Event', padding.left + chartWidth * 5 / 12, height - 28);
                                        ctx.fillText('+3d', padding.left + chartWidth * 8 / 12, height - 28);
                                        ctx.fillText('+7d', padding.left + chartWidth, height - 28);

                                        // Add forward performance label
                                        ctx.fillStyle = '#888888';
                                        ctx.font = '11px "JetBrains Mono", monospace';
                                        ctx.fillText('Event Performance', width / 2, height - 8);
                                      }}
                                    />
                                  </div>
                                ))}
                              </div>
                            </div>
                          )}

                          {/* Pattern Analysis - ALWAYS SHOW */}
                          {buildTradePatterns.length > 0 && (
                            <div className="mb-6 p-4 rounded-lg" style={{
                              background: 'rgba(75, 85, 99, 0.1)',
                              border: '1px solid rgba(75, 85, 99, 0.3)'
                            }}>
                              <div className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-3" style={{ fontFamily: 'monospace' }}>
                                Pattern Analysis
                              </div>
                              <div className="space-y-5">
                                {/* Group patterns by base type */}
                                {(() => {
                                  const baseTypes = ['52W High', '52W Low', '8-11% UP', '8-11% DOWN', '18-22% UP', '18-22% DOWN'];
                                  return baseTypes.map(baseType => {
                                    const cooldownPattern = buildTradePatterns.find(p => p.patternName.startsWith(baseType) && p.patternName.includes('90d Cooldown'));
                                    const annualPattern = buildTradePatterns.find(p => p.patternName.startsWith(baseType) && p.patternName.includes('Annual'));

                                    if (!cooldownPattern && !annualPattern) return null;

                                    return (
                                      <div key={baseType} className="p-3 rounded-lg" style={{
                                        background: 'rgba(0, 206, 209, 0.05)',
                                        border: '1px solid rgba(0, 206, 209, 0.3)'
                                      }}>
                                        <div className="text-sm font-bold text-cyan-400 mb-3" style={{ fontFamily: 'monospace' }}>
                                          ðŸ“Š {baseType}
                                        </div>
                                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>
                                          {/* 90d Cooldown Chart */}
                                          {cooldownPattern && (
                                            <div>
                                              <div className="flex justify-between items-center mb-2">
                                                <div className="text-xs font-bold text-cyan-400" style={{ fontFamily: 'monospace' }}>
                                                  90d Cooldown
                                                </div>
                                                <div className="text-xs text-gray-400" style={{ fontFamily: 'monospace' }}>
                                                  {cooldownPattern.occurrences} occ
                                                </div>
                                              </div>
                                              <canvas
                                                ref={(canvas) => {
                                                  if (!canvas) return;
                                                  const ctx = canvas.getContext('2d');
                                                  if (!ctx) return;

                                                  const dpr = window.devicePixelRatio || 1;
                                                  const width = 550;
                                                  const height = 234;
                                                  canvas.width = width * dpr;
                                                  canvas.height = height * dpr;
                                                  canvas.style.width = `${width}px`;
                                                  canvas.style.height = `${height}px`;
                                                  ctx.scale(dpr, dpr);

                                                  const padding = { top: 25, right: 30, bottom: 45, left: 60 };
                                                  const chartWidth = width - padding.left - padding.right;
                                                  const chartHeight = height - padding.top - padding.bottom;

                                                  ctx.fillStyle = '#000000';
                                                  ctx.fillRect(0, 0, width, height);

                                                  const returns = cooldownPattern.data.map(d => d.avgReturn);
                                                  const maxReturn = Math.max(...returns, 0);
                                                  const minReturn = Math.min(...returns, 0);
                                                  const range = Math.max(Math.abs(maxReturn), Math.abs(minReturn)) * 1.2;

                                                  // Draw horizontal gridlines with labels
                                                  ctx.strokeStyle = '#333333';
                                                  ctx.lineWidth = 0.5;
                                                  ctx.fillStyle = '#FFFFFF';
                                                  ctx.font = '10px "JetBrains Mono", monospace';
                                                  ctx.textAlign = 'right';

                                                  for (let i = 0; i <= 8; i++) {
                                                    const y = padding.top + (chartHeight * i / 8);
                                                    const pct = range - (range * 2 * i / 8);

                                                    ctx.strokeStyle = i === 4 ? '#666666' : '#333333';
                                                    ctx.lineWidth = i === 4 ? 1.5 : 0.5;
                                                    ctx.beginPath();
                                                    ctx.moveTo(padding.left, y);
                                                    ctx.lineTo(padding.left + chartWidth, y);
                                                    ctx.stroke();

                                                    ctx.fillStyle = '#FFFFFF';
                                                    ctx.fillText(`${pct >= 0 ? '+' : ''}${pct.toFixed(2)}%`, padding.left - 8, y + 4);
                                                  }

                                                  // Draw vertical line at Day 0 (today/pattern occurrence)
                                                  const zeroY = padding.top + chartHeight / 2;
                                                  ctx.strokeStyle = '#3B82F6';
                                                  ctx.lineWidth = 2;
                                                  ctx.setLineDash([5, 3]);
                                                  ctx.beginPath();
                                                  ctx.moveTo(padding.left, padding.top);
                                                  ctx.lineTo(padding.left, padding.top + chartHeight);
                                                  ctx.stroke();
                                                  ctx.setLineDash([]);

                                                  // Draw performance line
                                                  ctx.strokeStyle = '#00CED1';
                                                  ctx.lineWidth = 2.5;
                                                  ctx.beginPath();
                                                  cooldownPattern.data.forEach((point, i) => {
                                                    const x = padding.left + (chartWidth * i / (cooldownPattern.data.length - 1));
                                                    const y = zeroY - (point.avgReturn / range) * (chartHeight / 2);
                                                    if (i === 0) ctx.moveTo(x, y);
                                                    else ctx.lineTo(x, y);
                                                  });
                                                  ctx.stroke();

                                                  // Draw x-axis labels (show every 5 days)
                                                  ctx.fillStyle = '#FFFFFF';
                                                  ctx.font = '10px "JetBrains Mono", monospace';
                                                  ctx.textAlign = 'center';
                                                  const totalDays = cooldownPattern.data.length - 1;
                                                  const xLabelInterval = Math.ceil(totalDays / 6);

                                                  for (let i = 0; i <= totalDays; i += xLabelInterval) {
                                                    const x = padding.left + (chartWidth * i / totalDays);
                                                    ctx.fillText(`Day ${i}`, x, height - 28);
                                                  }
                                                  if (totalDays % xLabelInterval !== 0) {
                                                    ctx.fillText(`Day ${totalDays}`, padding.left + chartWidth, height - 28);
                                                  }

                                                  // Add forward performance label
                                                  ctx.fillStyle = '#888888';
                                                  ctx.font = '11px "JetBrains Mono", monospace';
                                                  ctx.fillText('Forward Performance', width / 2, height - 8);
                                                }}
                                              />
                                            </div>
                                          )}
                                          {/* Annual Chart */}
                                          {annualPattern && (
                                            <div>
                                              <div className="flex justify-between items-center mb-2">
                                                <div className="text-xs font-bold" style={{ fontFamily: 'monospace', color: '#FFD700' }}>
                                                  Annual Average
                                                </div>
                                                <div className="text-xs text-gray-400" style={{ fontFamily: 'monospace' }}>
                                                  {annualPattern.occurrences} occ
                                                </div>
                                              </div>
                                              <canvas
                                                ref={(canvas) => {
                                                  if (!canvas) return;
                                                  const ctx = canvas.getContext('2d');
                                                  if (!ctx) return;

                                                  const dpr = window.devicePixelRatio || 1;
                                                  const width = 550;
                                                  const height = 234;
                                                  canvas.width = width * dpr;
                                                  canvas.height = height * dpr;
                                                  canvas.style.width = `${width}px`;
                                                  canvas.style.height = `${height}px`;
                                                  ctx.scale(dpr, dpr);

                                                  const padding = { top: 25, right: 30, bottom: 45, left: 60 };
                                                  const chartWidth = width - padding.left - padding.right;
                                                  const chartHeight = height - padding.top - padding.bottom;

                                                  ctx.fillStyle = '#000000';
                                                  ctx.fillRect(0, 0, width, height);

                                                  const returns = annualPattern.data.map(d => d.avgReturn);
                                                  const maxReturn = Math.max(...returns, 0);
                                                  const minReturn = Math.min(...returns, 0);
                                                  const range = Math.max(Math.abs(maxReturn), Math.abs(minReturn)) * 1.2;

                                                  // Draw horizontal gridlines with labels
                                                  ctx.strokeStyle = '#333333';
                                                  ctx.lineWidth = 0.5;
                                                  ctx.fillStyle = '#FFFFFF';
                                                  ctx.font = '10px "JetBrains Mono", monospace';
                                                  ctx.textAlign = 'right';

                                                  for (let i = 0; i <= 8; i++) {
                                                    const y = padding.top + (chartHeight * i / 8);
                                                    const pct = range - (range * 2 * i / 8);

                                                    ctx.strokeStyle = i === 4 ? '#666666' : '#333333';
                                                    ctx.lineWidth = i === 4 ? 1.5 : 0.5;
                                                    ctx.beginPath();
                                                    ctx.moveTo(padding.left, y);
                                                    ctx.lineTo(padding.left + chartWidth, y);
                                                    ctx.stroke();

                                                    ctx.fillStyle = '#FFFFFF';
                                                    ctx.fillText(`${pct >= 0 ? '+' : ''}${pct.toFixed(2)}%`, padding.left - 8, y + 4);
                                                  }

                                                  // Draw vertical line at Day 0 (today/pattern occurrence)
                                                  const zeroY = padding.top + chartHeight / 2;
                                                  ctx.strokeStyle = '#3B82F6';
                                                  ctx.lineWidth = 2;
                                                  ctx.setLineDash([5, 3]);
                                                  ctx.beginPath();
                                                  ctx.moveTo(padding.left, padding.top);
                                                  ctx.lineTo(padding.left, padding.top + chartHeight);
                                                  ctx.stroke();
                                                  ctx.setLineDash([]);

                                                  // Draw performance line
                                                  ctx.strokeStyle = '#FFD700';
                                                  ctx.lineWidth = 2.5;
                                                  ctx.beginPath();
                                                  annualPattern.data.forEach((point, i) => {
                                                    const x = padding.left + (chartWidth * i / (annualPattern.data.length - 1));
                                                    const y = zeroY - (point.avgReturn / range) * (chartHeight / 2);
                                                    if (i === 0) ctx.moveTo(x, y);
                                                    else ctx.lineTo(x, y);
                                                  });
                                                  ctx.stroke();

                                                  // Draw x-axis labels (show every 5 days)
                                                  ctx.fillStyle = '#FFFFFF';
                                                  ctx.font = '10px "JetBrains Mono", monospace';
                                                  ctx.textAlign = 'center';
                                                  const totalDays = annualPattern.data.length - 1;
                                                  const xLabelInterval = Math.ceil(totalDays / 6);

                                                  for (let i = 0; i <= totalDays; i += xLabelInterval) {
                                                    const x = padding.left + (chartWidth * i / totalDays);
                                                    ctx.fillText(`Day ${i}`, x, height - 28);
                                                  }
                                                  if (totalDays % xLabelInterval !== 0) {
                                                    ctx.fillText(`Day ${totalDays}`, padding.left + chartWidth, height - 28);
                                                  }

                                                  // Add forward performance label
                                                  ctx.fillStyle = '#888888';
                                                  ctx.font = '11px "JetBrains Mono", monospace';
                                                  ctx.fillText('Forward Performance', width / 2, height - 8);
                                                }}
                                              />
                                            </div>
                                          )}
                                        </div>
                                      </div>
                                    );
                                  });
                                })()}
                              </div>
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>

        {/* ? NEW: Drawing Properties Panel */}
        <DrawingPropertiesPanel
          selectedDrawing={selectedDrawing}
          isOpen={showPropertiesPanel}
          onClose={() => setShowPropertiesPanel(false)}
          onUpdate={handleDrawingPropertiesUpdate}
          position={propertiesPanelPosition}
        />

        {/* ? NEW: Right-Click Context Menu */}
        {showContextMenu && contextMenuDrawing && createPortal(
          <div
            className="fixed z-[9999] bg-[#131722] border border-[#2a2e39] rounded-lg shadow-2xl min-w-[200px]"
            style={{
              left: Math.min(contextMenuPosition.x, window.innerWidth - 220),
              top: Math.min(contextMenuPosition.y, window.innerHeight - 300)
            }}
            onClick={(e) => e.stopPropagation()}
          >
            <div className="py-1">
              {/* Properties */}
              <button
                onClick={() => {
                  setShowPropertiesPanel(true);
                  setPropertiesPanelPosition(contextMenuPosition);
                  setShowContextMenu(false);
                }}
                className="w-full text-left px-4 py-2 text-sm text-white hover:bg-[#2a2e39] transition-colors flex items-center"
              >
                <span className="mr-3">??</span>
                Properties...
              </button>

              <div className="border-t border-[#2a2e39] my-1"></div>

              {/* Copy/Paste/Duplicate */}
              <button
                onClick={() => {
                  handleCopyDrawing(contextMenuDrawing);
                  setShowContextMenu(false);
                }}
                className="w-full text-left px-4 py-2 text-sm text-white hover:bg-[#2a2e39] transition-colors flex items-center"
              >
                <span className="mr-3">??</span>
                Copy
              </button>

              {drawingClipboard.length > 0 && (
                <button
                  onClick={() => {
                    handlePasteDrawing();
                    setShowContextMenu(false);
                  }}
                  className="w-full text-left px-4 py-2 text-sm text-white hover:bg-[#2a2e39] transition-colors flex items-center"
                >
                  <span className="mr-3">??</span>
                  Paste
                </button>
              )}

              <button
                onClick={() => {
                  handleDuplicateDrawing(contextMenuDrawing);
                  setShowContextMenu(false);
                }}
                className="w-full text-left px-4 py-2 text-sm text-white hover:bg-[#2a2e39] transition-colors flex items-center"
              >
                <span className="mr-3">?</span>
                Duplicate
              </button>

              <div className="border-t border-[#2a2e39] my-1"></div>

              {/* Layer Management */}
              <button
                onClick={() => {
                  bringDrawingToFront(contextMenuDrawing);
                  setShowContextMenu(false);
                }}
                className="w-full text-left px-4 py-2 text-sm text-white hover:bg-[#2a2e39] transition-colors flex items-center"
              >
                <span className="mr-3">??</span>
                Bring to Front
              </button>

              <button
                onClick={() => {
                  sendDrawingToBack(contextMenuDrawing);
                  setShowContextMenu(false);
                }}
                className="w-full text-left px-4 py-2 text-sm text-white hover:bg-[#2a2e39] transition-colors flex items-center"
              >
                <span className="mr-3">??</span>
                Send to Back
              </button>

              <div className="border-t border-[#2a2e39] my-1"></div>

              {/* Lock/Unlock */}
              <button
                onClick={() => {
                  updateDrawing(contextMenuDrawing.id, { isLocked: !contextMenuDrawing.isLocked });
                  setShowContextMenu(false);
                }}
                className="w-full text-left px-4 py-2 text-sm text-white hover:bg-[#2a2e39] transition-colors flex items-center"
              >
                <span className="mr-3">{contextMenuDrawing.isLocked ? '??' : '??'}</span>
                {contextMenuDrawing.isLocked ? 'Unlock' : 'Lock'}
              </button>

              <div className="border-t border-[#2a2e39] my-1"></div>

              {/* Delete */}
              <button
                onClick={() => {
                  handleDeleteDrawing(contextMenuDrawing);
                  setShowContextMenu(false);
                }}
                className="w-full text-left px-4 py-2 text-sm text-[#f23645] hover:bg-[#2a2e39] transition-colors flex items-center"
              >
                <span className="mr-3">???</span>
                Delete
              </button>
            </div>
          </div>,
          document.body
        )}

        {/* ? NEW: Drawing Toolbar Enhancement with Magnet Mode */}
        {(activeTool || selectedDrawing) && (
          <div className="fixed top-4 right-4 z-[9998] flex items-center space-x-2 bg-[#131722] border border-[#2a2e39] rounded-lg p-2">
            {/* Magnet Mode Toggle */}
            <button
              onClick={() => setMagnetMode(!magnetMode)}
              className={`px-3 py-1.5 text-xs rounded transition-colors ${magnetMode
                ? 'bg-[#2962ff] text-white'
                : 'bg-[#1e222d] text-[#868993] hover:text-white'
                }`}
              title="Magnet Mode - Snap to OHLC values"
            >
              ?? Magnet
            </button>

            {/* Show Handles Toggle */}
            <button
              onClick={() => setShowDrawingHandles(!showDrawingHandles)}
              className={`px-3 py-1.5 text-xs rounded transition-colors ${showDrawingHandles
                ? 'bg-[#2962ff] text-white'
                : 'bg-[#1e222d] text-[#868993] hover:text-white'
                }`}
              title="Show/Hide Drawing Handles"
            >
              ?? Handles
            </button>

            {/* Clear All Drawings */}
            <button
              onClick={() => {
                if (confirm('Delete all drawings?')) {
                  setDrawings([]);
                  setSelectedDrawing(null);
                  setSelectedDrawings([]);
                }
              }}
              className="px-3 py-1.5 text-xs bg-[#f23645] text-white rounded hover:bg-[#cc2c3b] transition-colors"
              title="Clear All Drawings"
            >
              ??? Clear
            </button>
          </div>
        )}

        {/* ETF Holdings Modal */}
        {selectedETF && (
          <ETFHoldingsModal
            isOpen={true}
            onClose={() => setSelectedETF(null)}
            etfSymbol={selectedETF.symbol}
            etfName={selectedETF.name}
          />
        )}

        {/* Alert Creation Dialog */}
        {showAlertDialog && newAlertPrice !== null && createPortal(
          <div className="fixed inset-0 z-[99999] flex items-center justify-center" style={{ backgroundColor: 'rgba(0, 0, 0, 0.9)' }}>
            <div style={{
              background: '#000000',
              border: '1px solid rgba(255, 107, 0, 0.4)',
              boxShadow: '0 10px 40px rgba(0, 0, 0, 0.9)',
            }} className="rounded p-6 w-[520px] max-h-[85vh] overflow-auto">
              <div className="flex items-center justify-between mb-5" style={{
                borderBottom: '1px solid rgba(255, 107, 0, 0.3)',
                paddingBottom: '12px'
              }}>
                <h3 style={{
                  color: '#ff6b00',
                  fontFamily: 'monospace',
                  fontSize: '20px',
                  fontWeight: '700',
                  textTransform: 'uppercase',
                  letterSpacing: '1.5px'
                }}>Create Alert</h3>
                <button
                  onClick={() => {
                    setShowAlertDialog(false);
                    setNewAlertPrice(null);
                  }}
                  style={{ color: '#666' }}
                  className="hover:text-white transition-colors"
                >
                  <TbX className="w-6 h-6" />
                </button>
              </div>

              <form onSubmit={(e) => {
                e.preventDefault();
                const formData = new FormData(e.currentTarget);

                const newAlert: PriceAlert = {
                  id: Date.now().toString(),
                  symbol: formData.get('symbol') as string || config.symbol,
                  price: Number(formData.get('price')) || newAlertPrice,
                  condition: formData.get('condition') as any,
                  message: formData.get('message') as string,
                  triggered: false,
                  createdAt: new Date(),
                  once: formData.get('once') === 'on',
                  soundEnabled: formData.get('sound') === 'on',
                  emailEnabled: formData.get('email') === 'on',
                  type: selectedAlertType,
                  ...(selectedAlertType === 'options' && {
                    optionsData: {
                      strike: Number(formData.get('strike')),
                      expiration: formData.get('expiration') as string,
                      optionType: formData.get('optionType') as 'call' | 'put',
                      metric: formData.get('metric') as any,
                      value: Number(formData.get('value'))
                    }
                  }),
                  ...(selectedAlertType === 'technical' && {
                    technicalData: {
                      indicator: formData.get('indicator') as string,
                      value: Number(formData.get('techValue'))
                    }
                  }),
                  ...((formData.get('condition') === 'staysInRange' || formData.get('condition') === 'breaksOutOfRange') && {
                    rangeData: {
                      upper: Number(formData.get('rangeUpper')),
                      lower: Number(formData.get('rangeLower')),
                      duration: Number(formData.get('rangeDuration')) || 60
                    }
                  })
                };

                setAlerts([...alerts, newAlert]);
                setShowAlertDialog(false);
                setNewAlertPrice(null);
              }}>

                <div className="space-y-4">
                  {/* Alert Type Badge */}
                  <div className="flex items-center gap-3 mb-3" style={{
                    background: '#0a0a0a',
                    border: '1px solid rgba(255, 107, 0, 0.25)',
                    padding: '12px 16px',
                    borderRadius: '2px'
                  }}>
                    {selectedAlertType === 'price' && <TbCurrencyDollar style={{ color: '#ff6b00', fontSize: '24px', strokeWidth: 2 }} />}
                    {selectedAlertType === 'options' && <TbChartCandle style={{ color: '#ff6b00', fontSize: '24px', strokeWidth: 2 }} />}
                    {selectedAlertType === 'technical' && <TbChartInfographic style={{ color: '#ff6b00', fontSize: '24px', strokeWidth: 2 }} />}
                    <span style={{
                      color: '#ff6b00',
                      fontSize: '12px',
                      fontWeight: '700',
                      textTransform: 'uppercase',
                      letterSpacing: '1.5px',
                      fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                      WebkitFontSmoothing: 'antialiased',
                      MozOsxFontSmoothing: 'grayscale'
                    }}>{selectedAlertType} Alert</span>
                  </div>

                  {/* Symbol & Price */}
                  <div style={{
                    background: '#000000',
                    border: '1px solid rgba(255, 107, 0, 0.25)',
                    padding: '18px',
                    borderRadius: '2px',
                    boxShadow: 'none'
                  }}>
                    <div className="mb-4">
                      <label style={{
                        color: '#fff',
                        fontSize: '10px',
                        fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                        textTransform: 'uppercase',
                        letterSpacing: '1.2px',
                        fontWeight: '700',
                        WebkitFontSmoothing: 'antialiased',
                        display: 'block',
                        marginBottom: '10px'
                      }}>Symbol</label>
                      <input
                        type="text"
                        name="symbol"
                        defaultValue={config.symbol}
                        style={{
                          width: '100%',
                          background: '#0a0a0a',
                          color: '#fff',
                          fontWeight: '700',
                          fontSize: '16px',
                          fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                          letterSpacing: '1px',
                          WebkitFontSmoothing: 'antialiased',
                          border: '1px solid rgba(255, 255, 255, 0.15)',
                          borderRadius: '2px',
                          padding: '12px 14px'
                        }}
                        onFocus={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.5)'}
                        onBlur={(e) => e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.15)'}
                      />
                    </div>
                    <div>
                      <label style={{
                        color: '#fff',
                        fontSize: '10px',
                        fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                        textTransform: 'uppercase',
                        letterSpacing: '1.2px',
                        fontWeight: '700',
                        WebkitFontSmoothing: 'antialiased',
                        display: 'block',
                        marginBottom: '10px'
                      }}>Alert Price</label>
                      <input
                        type="number"
                        name="price"
                        step="0.01"
                        defaultValue={newAlertPrice.toFixed(2)}
                        style={{
                          width: '100%',
                          background: '#0a0a0a',
                          color: '#ff6b00',
                          fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                          fontWeight: '700',
                          fontSize: '24px',
                          letterSpacing: '-0.5px',
                          WebkitFontSmoothing: 'antialiased',
                          border: '1px solid rgba(255, 255, 255, 0.15)',
                          borderRadius: '2px',
                          padding: '12px 14px'
                        }}
                        onFocus={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.5)'}
                        onBlur={(e) => e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.15)'}
                      />
                    </div>
                  </div>

                  {/* Condition */}
                  <div>
                    <label style={{
                      display: 'block',
                      color: '#fff',
                      fontSize: '10px',
                      fontWeight: '700',
                      marginBottom: '10px',
                      textTransform: 'uppercase',
                      letterSpacing: '1.5px',
                      fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                      WebkitFontSmoothing: 'antialiased'
                    }}>Condition</label>
                    <select
                      name="condition"
                      defaultValue="crossesAbove"
                      style={{
                        width: '100%',
                        background: '#000000',
                        color: '#fff',
                        border: '1px solid rgba(255, 255, 255, 0.15)',
                        borderRadius: '2px',
                        padding: '12px 14px',
                        fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                        fontSize: '14px',
                        fontWeight: '500',
                        cursor: 'pointer',
                        WebkitFontSmoothing: 'antialiased',
                        boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
                      }}
                      className="focus:outline-none transition-all"
                      onFocus={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.5)'}
                      onBlur={(e) => e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.15)'}
                    >
                      <optgroup label="Price Crosses" style={{ background: '#0a0a0a', color: '#ff6b00', fontWeight: '700' }}>
                        <option value="crossesAbove" style={{ background: '#000', color: '#fff' }}>â†‘ Crosses Above</option>
                        <option value="crossesBelow" style={{ background: '#000', color: '#fff' }}>â†“ Crosses Below</option>
                      </optgroup>
                      <optgroup label="Price Levels" style={{ background: '#0a0a0a', color: '#ff6b00', fontWeight: '700' }}>
                        <option value="above" style={{ background: '#000', color: '#fff' }}>â–² Above</option>
                        <option value="below" style={{ background: '#000', color: '#fff' }}>â–¼ Below</option>
                      </optgroup>
                      <optgroup label="Close Above (Timeframe)" style={{ background: '#0a0a0a', color: '#ff6b00', fontWeight: '700' }}>
                        <option value="closeAbove5m" style={{ background: '#000', color: '#fff' }}>Close Above on 5M</option>
                        <option value="closeAbove15m" style={{ background: '#000', color: '#fff' }}>Close Above on 15M</option>
                        <option value="closeAbove30m" style={{ background: '#000', color: '#fff' }}>Close Above on 30M</option>
                        <option value="closeAbove1h" style={{ background: '#000', color: '#fff' }}>Close Above on 1H</option>
                        <option value="closeAbove4h" style={{ background: '#000', color: '#fff' }}>Close Above on 4H</option>
                        <option value="closeAbove1d" style={{ background: '#000', color: '#fff' }}>Close Above on 1D</option>
                      </optgroup>
                      <optgroup label="Close Below (Timeframe)" style={{ background: '#0a0a0a', color: '#ff6b00', fontWeight: '700' }}>
                        <option value="closeBelow5m" style={{ background: '#000', color: '#fff' }}>Close Below on 5M</option>
                        <option value="closeBelow15m" style={{ background: '#000', color: '#fff' }}>Close Below on 15M</option>
                        <option value="closeBelow30m" style={{ background: '#000', color: '#fff' }}>Close Below on 30M</option>
                        <option value="closeBelow1h" style={{ background: '#000', color: '#fff' }}>Close Below on 1H</option>
                        <option value="closeBelow4h" style={{ background: '#000', color: '#fff' }}>Close Below on 4H</option>
                        <option value="closeBelow1d" style={{ background: '#000', color: '#fff' }}>Close Below on 1D</option>
                      </optgroup>
                      <optgroup label="Range Conditions" style={{ background: '#0a0a0a', color: '#ff6b00', fontWeight: '700' }}>
                        <option value="staysInRange" style={{ background: '#000', color: '#fff' }}>Stays Within Range</option>
                        <option value="breaksOutOfRange" style={{ background: '#000', color: '#fff' }}>Breaks Out of Range</option>
                      </optgroup>
                    </select>
                  </div>

                  {/* Range Configuration (conditional) */}
                  <div id="rangeConfig" style={{ display: 'none' }}>
                    <div className="grid grid-cols-2 gap-3">
                      <div>
                        <label style={{
                          display: 'block',
                          color: '#fff',
                          fontSize: '10px',
                          fontWeight: '700',
                          marginBottom: '10px',
                          textTransform: 'uppercase',
                          letterSpacing: '1.5px',
                          fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                          WebkitFontSmoothing: 'antialiased'
                        }}>Upper Range</label>
                        <input
                          type="number"
                          name="rangeUpper"
                          step="0.01"
                          placeholder="Upper price"
                          style={{
                            width: '100%',
                            background: '#000000',
                            color: '#fff',
                            border: '1px solid rgba(255, 255, 255, 0.15)',
                            borderRadius: '2px',
                            padding: '12px 14px',
                            fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                            fontSize: '14px',
                            fontWeight: '500',
                            WebkitFontSmoothing: 'antialiased',
                            boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
                          }}
                          onFocus={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.5)'}
                          onBlur={(e) => e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.15)'}
                        />
                      </div>
                      <div>
                        <label style={{
                          display: 'block',
                          color: '#fff',
                          fontSize: '10px',
                          fontWeight: '700',
                          marginBottom: '10px',
                          textTransform: 'uppercase',
                          letterSpacing: '1.5px',
                          fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                          WebkitFontSmoothing: 'antialiased'
                        }}>Lower Range</label>
                        <input
                          type="number"
                          name="rangeLower"
                          step="0.01"
                          placeholder="Lower price"
                          style={{
                            width: '100%',
                            background: '#000000',
                            color: '#fff',
                            border: '1px solid rgba(255, 255, 255, 0.15)',
                            borderRadius: '2px',
                            padding: '12px 14px',
                            fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                            fontSize: '14px',
                            fontWeight: '500',
                            WebkitFontSmoothing: 'antialiased',
                            boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
                          }}
                          onFocus={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.5)'}
                          onBlur={(e) => e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.15)'}
                        />
                      </div>
                    </div>
                    <div className="mt-3">
                      <label style={{
                        display: 'block',
                        color: '#fff',
                        fontSize: '10px',
                        fontWeight: '700',
                        marginBottom: '10px',
                        textTransform: 'uppercase',
                        letterSpacing: '1.5px',
                        fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                        WebkitFontSmoothing: 'antialiased'
                      }}>Time Period (minutes)</label>
                      <input
                        type="number"
                        name="rangeDuration"
                        min="1"
                        defaultValue="60"
                        placeholder="Duration in minutes"
                        style={{
                          width: '100%',
                          background: '#000000',
                          color: '#fff',
                          border: '1px solid rgba(255, 255, 255, 0.15)',
                          borderRadius: '2px',
                          padding: '12px 14px',
                          fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                          fontSize: '14px',
                          fontWeight: '500',
                          WebkitFontSmoothing: 'antialiased',
                          boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
                        }}
                        onFocus={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.5)'}
                        onBlur={(e) => e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.15)'}
                      />
                    </div>
                  </div>

                  <script dangerouslySetInnerHTML={{
                    __html: `
 document.querySelector('select[name="condition"]')?.addEventListener('change', (e) => {
 const rangeConfig = document.getElementById('rangeConfig');
 if (e.target.value === 'staysInRange' || e.target.value === 'breaksOutOfRange') {
 rangeConfig.style.display = 'block';
 } else {
 rangeConfig.style.display = 'none';
 }
 });
 `
                  }} />

                  {/* Options-specific fields */}
                  {selectedAlertType === 'options' && (
                    <>
                      <div className="grid grid-cols-2 gap-3">
                        <div>
                          <label style={{
                            display: 'block',
                            color: '#ff6b00',
                            fontSize: '10px',
                            fontWeight: '700',
                            marginBottom: '10px',
                            textTransform: 'uppercase',
                            letterSpacing: '1.5px',
                            fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                            WebkitFontSmoothing: 'antialiased'
                          }}>Strike</label>
                          <input
                            type="number"
                            name="strike"
                            step="0.5"
                            defaultValue={Math.round(newAlertPrice)}
                            style={{
                              width: '100%',
                              background: '#000000',
                              color: '#fff',
                              border: '1px solid rgba(255, 255, 255, 0.15)',
                              borderRadius: '2px',
                              padding: '12px 14px',
                              fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                              fontSize: '14px',
                              fontWeight: '500',
                              WebkitFontSmoothing: 'antialiased',
                              boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
                            }}
                            className="focus:outline-none transition-all"
                            onFocus={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.5)'}
                            onBlur={(e) => e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.15)'}
                            required
                          />
                        </div>
                        <div>
                          <label style={{
                            display: 'block',
                            color: '#ff6b00',
                            fontSize: '10px',
                            fontWeight: '700',
                            marginBottom: '10px',
                            textTransform: 'uppercase',
                            letterSpacing: '1.5px',
                            fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                            WebkitFontSmoothing: 'antialiased'
                          }}>Type</label>
                          <select
                            name="optionType"
                            defaultValue="call"
                            style={{
                              width: '100%',
                              background: '#000000',
                              color: '#fff',
                              border: '1px solid rgba(255, 255, 255, 0.15)',
                              borderRadius: '2px',
                              padding: '12px 14px',
                              fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                              fontSize: '14px',
                              fontWeight: '500',
                              cursor: 'pointer',
                              WebkitFontSmoothing: 'antialiased',
                              boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
                            }}
                            className="focus:outline-none transition-all"
                            onFocus={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.5)'}
                            onBlur={(e) => e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.15)'}
                          >
                            <option value="call">Call</option>
                            <option value="put">Put</option>
                          </select>
                        </div>
                      </div>
                      <div>
                        <label style={{
                          display: 'block',
                          color: '#ff6b00',
                          fontSize: '10px',
                          fontWeight: '700',
                          marginBottom: '10px',
                          textTransform: 'uppercase',
                          letterSpacing: '1.5px',
                          fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                          WebkitFontSmoothing: 'antialiased'
                        }}>Expiration</label>
                        <input
                          type="date"
                          name="expiration"
                          defaultValue={new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}
                          style={{
                            width: '100%',
                            background: '#000000',
                            color: '#fff',
                            border: '1px solid rgba(255, 255, 255, 0.15)',
                            borderRadius: '2px',
                            padding: '12px 14px',
                            fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                            fontSize: '14px',
                            fontWeight: '500',
                            WebkitFontSmoothing: 'antialiased',
                            boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
                          }}
                          className="focus:outline-none transition-all"
                          onFocus={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.5)'}
                          onBlur={(e) => e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.15)'}
                          required
                        />
                      </div>
                      <div className="grid grid-cols-2 gap-3">
                        <div>
                          <label style={{
                            display: 'block',
                            color: '#ff6b00',
                            fontSize: '10px',
                            fontWeight: '700',
                            marginBottom: '10px',
                            textTransform: 'uppercase',
                            letterSpacing: '1.5px',
                            fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                            WebkitFontSmoothing: 'antialiased'
                          }}>Metric</label>
                          <select
                            name="metric"
                            defaultValue="iv"
                            style={{
                              width: '100%',
                              background: '#000000',
                              color: '#fff',
                              border: '1px solid rgba(255, 255, 255, 0.15)',
                              borderRadius: '2px',
                              padding: '12px 14px',
                              fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                              fontSize: '14px',
                              fontWeight: '500',
                              cursor: 'pointer',
                              WebkitFontSmoothing: 'antialiased',
                              boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
                            }}
                            className="focus:outline-none transition-all"
                            onFocus={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.5)'}
                            onBlur={(e) => e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.15)'}
                          >
                            <option value="iv">IV</option>
                            <option value="volume">Volume</option>
                            <option value="oi">Open Interest</option>
                            <option value="delta">Delta</option>
                          </select>
                        </div>
                        <div>
                          <label style={{
                            display: 'block',
                            color: '#ff6b00',
                            fontSize: '10px',
                            fontWeight: '700',
                            marginBottom: '10px',
                            textTransform: 'uppercase',
                            letterSpacing: '1.5px',
                            fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                            WebkitFontSmoothing: 'antialiased'
                          }}>Value</label>
                          <input
                            type="number"
                            name="value"
                            step="0.01"
                            defaultValue="0.5"
                            style={{
                              width: '100%',
                              background: '#000000',
                              color: '#fff',
                              border: '1px solid rgba(255, 255, 255, 0.15)',
                              borderRadius: '2px',
                              padding: '12px 14px',
                              fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                              fontSize: '14px',
                              fontWeight: '500',
                              WebkitFontSmoothing: 'antialiased',
                              boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
                            }}
                            className="focus:outline-none transition-all"
                            onFocus={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.5)'}
                            onBlur={(e) => e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.15)'}
                            required
                          />
                        </div>
                      </div>
                    </>
                  )}

                  {/* Message */}
                  <div>
                    <label style={{
                      display: 'block',
                      color: '#ff6b00',
                      fontSize: '10px',
                      fontWeight: '700',
                      marginBottom: '10px',
                      textTransform: 'uppercase',
                      letterSpacing: '1.5px',
                      fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                      WebkitFontSmoothing: 'antialiased'
                    }}>Message (Optional)</label>
                    <textarea
                      name="message"
                      placeholder="Add a custom message for this alert..."
                      rows={2}
                      style={{
                        width: '100%',
                        background: '#000000',
                        color: '#fff',
                        border: '1px solid rgba(255, 255, 255, 0.15)',
                        borderRadius: '2px',
                        padding: '12px 14px',
                        fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                        fontSize: '14px',
                        fontWeight: '400',
                        resize: 'none',
                        WebkitFontSmoothing: 'antialiased',
                        boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
                      }}
                      className="focus:outline-none transition-all"
                      onFocus={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.5)'}
                      onBlur={(e) => e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.15)'}
                    />
                  </div>

                  {/* Notification Options */}
                  <div style={{
                    background: '#0a0a0a',
                    border: '1px solid rgba(255, 255, 255, 0.1)',
                    padding: '14px 16px',
                    borderRadius: '2px'
                  }}>
                    <div style={{
                      color: '#fff',
                      fontSize: '10px',
                      fontWeight: '700',
                      textTransform: 'uppercase',
                      letterSpacing: '1.5px',
                      marginBottom: '12px',
                      fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                      WebkitFontSmoothing: 'antialiased'
                    }}>Notification Settings</div>
                    <div className="space-y-3">
                      <label className="flex items-center gap-3 cursor-pointer" style={{ transition: 'all 0.2s' }}>
                        <input type="checkbox" name="sound" defaultChecked style={{
                          width: '18px',
                          height: '18px',
                          accentColor: '#ff6b00',
                          cursor: 'pointer'
                        }} />
                        <TbBell style={{ color: '#ff6b00', fontSize: '18px', strokeWidth: 2 }} />
                        <span style={{
                          color: '#fff',
                          fontSize: '13px',
                          fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                          fontWeight: '500',
                          WebkitFontSmoothing: 'antialiased'
                        }}>Play sound notification</span>
                      </label>
                      <label className="flex items-center gap-3 cursor-pointer" style={{ transition: 'all 0.2s' }}>
                        <input type="checkbox" name="email" style={{
                          width: '18px',
                          height: '18px',
                          accentColor: '#ff6b00',
                          cursor: 'pointer'
                        }} />
                        <TbMail style={{ color: '#ff6b00', fontSize: '18px', strokeWidth: 2 }} />
                        <span style={{
                          color: '#fff',
                          fontSize: '13px',
                          fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                          fontWeight: '500',
                          WebkitFontSmoothing: 'antialiased'
                        }}>Send email notification</span>
                      </label>
                      <label className="flex items-center gap-3 cursor-pointer" style={{ transition: 'all 0.2s' }}>
                        <input type="checkbox" name="once" defaultChecked style={{
                          width: '18px',
                          height: '18px',
                          accentColor: '#ff6b00',
                          cursor: 'pointer'
                        }} />
                        <TbCheck style={{ color: '#ff6b00', fontSize: '18px', strokeWidth: 2 }} />
                        <span style={{
                          color: '#fff',
                          fontSize: '13px',
                          fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                          fontWeight: '500',
                          WebkitFontSmoothing: 'antialiased'
                        }}>Trigger only once</span>
                      </label>
                    </div>
                  </div>

                  {/* Action Buttons */}
                  <div className="flex gap-4 pt-5" style={{
                    borderTop: '2px solid rgba(255, 107, 0, 0.25)',
                    paddingTop: '20px',
                    marginTop: '8px'
                  }}>
                    <button
                      type="button"
                      onClick={() => {
                        setShowAlertDialog(false);
                        setNewAlertPrice(null);
                      }}
                      style={{
                        flex: 1,
                        background: 'linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%)',
                        color: '#999',
                        padding: '14px 20px',
                        borderRadius: '2px',
                        border: '1px solid rgba(255, 255, 255, 0.15)',
                        fontWeight: '700',
                        fontSize: '12px',
                        fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                        textTransform: 'uppercase',
                        letterSpacing: '1.5px',
                        cursor: 'pointer',
                        transition: 'all 0.2s',
                        WebkitFontSmoothing: 'antialiased',
                        boxShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.background = 'linear-gradient(135deg, #252525 0%, #1a1a1a 100%)';
                        e.currentTarget.style.color = '#ccc';
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.background = 'linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%)';
                        e.currentTarget.style.color = '#999';
                      }}
                    >
                      Cancel
                    </button>
                    <button
                      type="submit"
                      style={{
                        flex: 1,
                        background: 'linear-gradient(135deg, #ff6b00 0%, #ff8533 100%)',
                        color: '#000',
                        padding: '14px 20px',
                        borderRadius: '2px',
                        border: '1px solid #ff8533',
                        fontWeight: '800',
                        fontSize: '12px',
                        fontFamily: 'system-ui, -apple-system, "Segoe UI", sans-serif',
                        textTransform: 'uppercase',
                        letterSpacing: '1.5px',
                        cursor: 'pointer',
                        transition: 'all 0.2s',
                        WebkitFontSmoothing: 'antialiased',
                        boxShadow: '0 4px 20px rgba(255, 107, 0, 0.5), 0 2px 4px rgba(0, 0, 0, 0.3)'
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.transform = 'translateY(-1px)';
                        e.currentTarget.style.boxShadow = '0 6px 25px rgba(255, 107, 0, 0.6), 0 4px 6px rgba(0, 0, 0, 0.4)';
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.transform = 'translateY(0)';
                        e.currentTarget.style.boxShadow = '0 4px 20px rgba(255, 107, 0, 0.5), 0 2px 4px rgba(0, 0, 0, 0.3)';
                      }}
                    >
                      Create Alert
                    </button>
                  </div>
                </div>
              </form>
            </div>
          </div>,
          document.body
        )}
      </div>

      {/* Guide Chatbot */}
      <GuideChatbot />

      {/* Notes & Alerts Box - Show when Guide AI button is active (panel visible) */}
      {isGuideAIOpen && (
        <div className="fixed right-0 z-[9999]" style={{ top: '70%', width: '30%', height: '30%' }}>
          <div className="w-full h-full flex flex-col relative" style={{
            background: '#000000',
            border: '2px solid rgba(255, 107, 0, 0.5)',
            borderRight: 'none',
            borderTop: '2px solid rgba(255, 107, 0, 0.4)'
          }}>

            {/* Header */}
            <div className="px-4 py-2 border-b relative" style={{
              background: 'linear-gradient(180deg, rgba(255, 107, 0, 0.12) 0%, rgba(0, 0, 0, 0.4) 100%)',
              borderColor: 'rgba(255, 107, 0, 0.3)'
            }}>
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <div className="w-6 h-6 rounded flex items-center justify-center" style={{
                    background: 'rgba(255, 107, 0, 0.2)',
                    border: '1px solid rgba(255, 107, 0, 0.5)'
                  }}>
                    <span style={{ fontSize: '14px' }}>ðŸ“‹</span>
                  </div>
                  <h3 className="text-xs font-bold uppercase tracking-widest" style={{
                    color: '#ffffff',
                    letterSpacing: '1.5px'
                  }}>
                    NOTES & ALERTS
                  </h3>
                </div>
                <span className="text-xs font-mono font-semibold" style={{ color: '#10b981' }}>
                  {alerts.filter(a => !a.triggered).length}
                </span>
              </div>
            </div>

            {/* Content Area */}
            <div className="flex-1 overflow-y-auto p-2" style={{
              background: '#0a0a0a',
              scrollbarWidth: 'thin',
              scrollbarColor: 'rgba(255, 107, 0, 0.6) rgba(0, 0, 0, 0.4)'
            }}>
              {/* Notes Input */}
              <div className="mb-2">
                <textarea
                  placeholder="Add your notes here..."
                  className="w-full p-2 text-xs font-mono resize-none"
                  rows={3}
                  value={quickNotes}
                  onChange={(e) => setQuickNotes(e.target.value)}
                  style={{
                    background: 'rgba(26, 26, 26, 0.8)',
                    border: '1px solid rgba(255, 107, 0, 0.4)',
                    borderRadius: '4px',
                    color: '#ffffff',
                    outline: 'none'
                  }}
                  onFocus={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.7)'}
                  onBlur={(e) => e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.4)'}
                />
              </div>

              {/* Alerts List */}
              <div className="space-y-1.5">
                {alerts.filter(a => !a.triggered).map(alert => (
                  <div
                    key={alert.id}
                    className="relative"
                    style={{
                      background: 'rgba(26, 26, 26, 0.9)',
                      border: '1px solid rgba(255, 107, 0, 0.3)',
                      borderRadius: '4px',
                      padding: '8px 10px',
                      transition: 'all 0.2s ease',
                      cursor: 'pointer'
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.6)';
                      e.currentTarget.style.transform = 'translateX(-2px)';
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.borderColor = 'rgba(255, 107, 0, 0.3)';
                      e.currentTarget.style.transform = 'translateX(0)';
                    }}
                  >
                    <div className="flex items-center justify-between mb-1">
                      <div className="flex items-center gap-2">
                        <span className="px-1.5 py-0.5 rounded text-xs font-bold uppercase" style={{
                          background: 'rgba(255, 107, 0, 0.2)',
                          color: '#ff8833',
                          border: '1px solid rgba(255, 107, 0, 0.5)',
                          fontSize: '9px',
                          letterSpacing: '0.5px'
                        }}>
                          {alert.type}
                        </span>
                        <span className="text-xs font-mono font-bold" style={{ color: '#ffffff' }}>
                          {alert.symbol}
                        </span>
                      </div>
                      <span className="text-sm font-bold font-mono" style={{ color: '#ff6b00' }}>
                        ${alert.price.toFixed(2)}
                      </span>
                    </div>

                    <div className="text-xs" style={{ color: '#cccccc' }}>
                      {alert.condition.replace(/([A-Z])/g, ' $1').trim()}
                    </div>

                    {alert.message && (
                      <div className="text-xs mt-1 pt-1" style={{
                        color: '#999999',
                        borderTop: '1px solid rgba(255, 107, 0, 0.15)',
                        fontStyle: 'italic'
                      }}>
                        {alert.message}
                      </div>
                    )}
                  </div>
                ))}

                {alerts.filter(a => !a.triggered).length === 0 && (
                  <div className="flex flex-col items-center justify-center py-4">
                    <div className="w-12 h-12 rounded flex items-center justify-center mb-2" style={{
                      background: 'rgba(255, 107, 0, 0.1)',
                      border: '1px solid rgba(255, 107, 0, 0.3)'
                    }}>
                      <span style={{ fontSize: '24px' }}>ðŸ””</span>
                    </div>
                    <p className="text-xs font-semibold mb-1" style={{ color: '#ffffff' }}>
                      No Active Alerts
                    </p>
                    <p className="text-xs text-center px-4" style={{ color: '#666666' }}>
                      Set alerts from the sidebar
                    </p>
                  </div>
                )}
              </div>
            </div>

            {/* Footer */}
            <div className="px-3 py-1.5 border-t" style={{
              background: 'rgba(0, 0, 0, 0.9)',
              borderColor: 'rgba(255, 107, 0, 0.25)'
            }}>
              <div className="flex items-center justify-between text-xs">
                <span className="font-mono font-bold" style={{ color: '#ffffff' }}>
                  {config.symbol}
                </span>
                <span className="font-mono font-semibold" style={{ color: '#10b981' }}>
                  {new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </span>
              </div>
            </div>
          </div>
        </div>
      )}
    </>
  );
}





